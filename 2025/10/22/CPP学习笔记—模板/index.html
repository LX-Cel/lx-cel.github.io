<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>CPP学习笔记—模板 | 星海流光</title><meta name="author" content="秋风、萧瑟"><meta name="copyright" content="秋风、萧瑟"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="一、 什么是C++模板 (What are C++ Templates?)C++模板是 泛型编程（Generic Programming） 的核心工具。它允许我们编写与类型无关的代码，即编写一份代码，可以用于多种不同的数据类型。 可以把模板想象成一个 “代码的蓝图”或“配方” 。它本身并不是一个可以直接运行的函数或类，而是一个指令，告诉编译器如何根据我们提供的具体类型（如 int, double,">
<meta property="og:type" content="article">
<meta property="og:title" content="CPP学习笔记—模板">
<meta property="og:url" content="https://lx-cel.github.io/2025/10/22/CPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E6%A8%A1%E6%9D%BF/index.html">
<meta property="og:site_name" content="星海流光">
<meta property="og:description" content="一、 什么是C++模板 (What are C++ Templates?)C++模板是 泛型编程（Generic Programming） 的核心工具。它允许我们编写与类型无关的代码，即编写一份代码，可以用于多种不同的数据类型。 可以把模板想象成一个 “代码的蓝图”或“配方” 。它本身并不是一个可以直接运行的函数或类，而是一个指令，告诉编译器如何根据我们提供的具体类型（如 int, double,">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://lx-cel.github.io/img/47.jpg">
<meta property="article:published_time" content="2025-10-22T14:31:08.000Z">
<meta property="article:modified_time" content="2025-10-21T16:00:00.000Z">
<meta property="article:author" content="秋风、萧瑟">
<meta property="article:tag" content="学习笔记">
<meta property="article:tag" content="cpp">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://lx-cel.github.io/img/47.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://lx-cel.github.io/2025/10/22/CPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E6%A8%A1%E6%9D%BF/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'CPP学习笔记—模板',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/Cecilia.jpeg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">50</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/47.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">星海流光</span></a><a class="nav-page-title" href="/"><span class="site-name">CPP学习笔记—模板</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">CPP学习笔记—模板</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-10-22T14:31:08.000Z" title="发表于 2025-10-22 22:31:08">2025-10-22</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-10-21T16:00:00.000Z" title="更新于 2025-10-22 00:00:00">2025-10-22</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/cpp/">cpp</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h3 id="一、-什么是C-模板-What-are-C-Templates"><a href="#一、-什么是C-模板-What-are-C-Templates" class="headerlink" title="一、 什么是C++模板 (What are C++ Templates?)"></a>一、 什么是C++模板 (What are C++ Templates?)</h3><p>C++模板是 <strong>泛型编程（Generic Programming）</strong> 的核心工具。它允许我们编写与类型无关的代码，即编写一份代码，可以用于多种不同的数据类型。</p>
<p>可以把模板想象成一个 <strong>“代码的蓝图”或“配方”</strong> 。它本身并不是一个可以直接运行的函数或类，而是一个指令，告诉编译器如何根据我们提供的具体类型（如 <code>int</code>, <code>double</code>, <code>std::string</code> 或自定义类）来生成一个特定版本的函数或类。</p>
<p>这个在编译时根据模板生成具体类型代码的过程，称为<strong>模板实例化（Template Instantiation）</strong>。</p>
<h3 id="二、-为什么需要模板-Why-Do-We-Need-Templates"><a href="#二、-为什么需要模板-Why-Do-We-Need-Templates" class="headerlink" title="二、 为什么需要模板 (Why Do We Need Templates?)"></a>二、 为什么需要模板 (Why Do We Need Templates?)</h3><p>假设我们要写一个交换两个整数值的函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap_int</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果现在还需要交换两个 <code>double</code> 或 <code>string</code> 类型的值，我们就必须重载这个函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap_double</span><span class="params">(<span class="type">double</span>&amp; a, <span class="type">double</span>&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap_string</span><span class="params">(std::string&amp; a, std::string&amp; b)</span> </span>&#123;</span><br><span class="line">    std::string temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你会发现，这些函数的<strong>逻辑完全一样</strong>，唯一的区别就是处理的数据类型不同。这种代码重复是冗余且难以维护的。模板就是为了解决这个问题而生的。</p>
<p>使用模板，我们可以只写一个通用的 <code>swap</code> 函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap_generic</span><span class="params">(T&amp; a, T&amp; b)</span> </span>&#123;</span><br><span class="line">    T temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，这个 <code>swap_generic</code> 函数可以用于任何支持拷贝和赋值操作的类型。</p>
<h3 id="三、-模板的类型与使用"><a href="#三、-模板的类型与使用" class="headerlink" title="三、 模板的类型与使用"></a>三、 模板的类型与使用</h3><p>C++中的模板主要分为以下几类：</p>
<h4 id="1-函数模板-Function-Templates"><a href="#1-函数模板-Function-Templates" class="headerlink" title="1. 函数模板 (Function Templates)"></a>1. 函数模板 (Function Templates)</h4><p>这是最常见的模板形式，用于创建通用的函数。</p>
<p><strong>语法:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, ...&gt;</span><br><span class="line"><span class="function">return_type <span class="title">function_name</span><span class="params">(parameter_list)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>template &lt;...&gt;</code>: 模板声明，尖括号中是模板参数列表。</li>
<li><code>typename</code> 和 <code>class</code>: 在模板参数列表中，<code>typename</code> 和 <code>class</code> 关键字是完全等价的，可以互换使用。<code>typename</code> 在某些情况下更清晰地表明这是一个类型参数。</li>
<li><code>T1, T2</code>: 模板参数，通常用大写字母表示（如 <code>T</code>, <code>U</code>, <code>V</code>），它们是类型的占位符。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个简单的泛型max函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">max</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a &gt; b) ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 模板参数自动推导 (Template Argument Deduction)</span></span><br><span class="line">    <span class="comment">// 编译器看到 max(10, 20) 的调用，推导出 T 的类型是 int</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Max of 10, 20 is: &quot;</span> &lt;&lt; <span class="built_in">max</span>(<span class="number">10</span>, <span class="number">20</span>) &lt;&lt; std::endl; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编译器推导出 T 的类型是 double</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Max of 3.14, 2.71 is: &quot;</span> &lt;&lt; <span class="built_in">max</span>(<span class="number">3.14</span>, <span class="number">2.71</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编译器推导出 T 的类型是 char</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Max of &#x27;a&#x27;, &#x27;z&#x27; is: &quot;</span> &lt;&lt; <span class="built_in">max</span>(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;z&#x27;</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 显式指定模板参数 (Explicit Specification)</span></span><br><span class="line">    <span class="comment">// 当自动推导失败或不符合预期时，可以显式指定</span></span><br><span class="line">    <span class="comment">// 例如，max(10, 20.5) 会编译错误，因为编译器无法确定 T 是 int 还是 double</span></span><br><span class="line">    <span class="comment">// 我们可以显式指定 T 为 double</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Max of 10, 20.5 is: &quot;</span> &lt;&lt; <span class="built_in">max</span>&lt;<span class="type">double</span>&gt;(<span class="number">10</span>, <span class="number">20.5</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-类模板-Class-Templates"><a href="#2-类模板-Class-Templates" class="headerlink" title="2. 类模板 (Class Templates)"></a>2. 类模板 (Class Templates)</h4><p>类模板用于创建通用的类，例如容器（如 <code>vector</code>, <code>stack</code>）、智能指针等。</p>
<p><strong>语法:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ... 成员变量和成员函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">someMethod</span><span class="params">(T param)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T memberVar;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>示例：一个简单的栈（Stack）类</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> T&amp; element)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">T&amp; <span class="title">top</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;T&gt; elements;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// **注意：**类模板的成员函数定义在类外时，必须再次使用 template&lt;...&gt; 声明</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> Stack&lt;T&gt;::<span class="built_in">push</span>(<span class="type">const</span> T&amp; element) &#123;</span><br><span class="line">    elements.<span class="built_in">push_back</span>(element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> Stack&lt;T&gt;::<span class="built_in">pop</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;Stack&lt;T&gt;::pop(): empty stack&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    elements.<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T&amp; Stack&lt;T&gt;::<span class="built_in">top</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;Stack&lt;T&gt;::top(): empty stack&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> elements.<span class="built_in">back</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> Stack&lt;T&gt;::<span class="built_in">isEmpty</span>() <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> elements.<span class="built_in">empty</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 实例化一个处理 int 类型的栈</span></span><br><span class="line">    <span class="comment">// 对于类模板，必须显式指定模板参数</span></span><br><span class="line">    Stack&lt;<span class="type">int</span>&gt; intStack;</span><br><span class="line">    intStack.<span class="built_in">push</span>(<span class="number">10</span>);</span><br><span class="line">    intStack.<span class="built_in">push</span>(<span class="number">20</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Top of intStack: &quot;</span> &lt;&lt; intStack.<span class="built_in">top</span>() &lt;&lt; std::endl; <span class="comment">// 输出 20</span></span><br><span class="line">    intStack.<span class="built_in">pop</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Top of intStack after pop: &quot;</span> &lt;&lt; intStack.<span class="built_in">top</span>() &lt;&lt; std::endl; <span class="comment">// 输出 10</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实例化一个处理 std::string 类型的栈</span></span><br><span class="line">    Stack&lt;std::string&gt; stringStack;</span><br><span class="line">    stringStack.<span class="built_in">push</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    stringStack.<span class="built_in">push</span>(<span class="string">&quot;World&quot;</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Top of stringStack: &quot;</span> &lt;&lt; stringStack.<span class="built_in">top</span>() &lt;&lt; std::endl; <span class="comment">// 输出 &quot;World&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-变量模板-Variable-Templates-C-14"><a href="#3-变量模板-Variable-Templates-C-14" class="headerlink" title="3. 变量模板 (Variable Templates) (C++14)"></a>3. 变量模板 (Variable Templates) (C++14)</h4><p>C++14 引入了变量模板，允许我们定义一个模板化的变量。</p>
<p><strong>语法:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">constexpr</span> T my_variable = some_value;</span><br></pre></td></tr></table></figure>

<p><strong>示例：定义一个泛型的 PI 值</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">constexpr</span> T pi = <span class="built_in">T</span>(<span class="number">3.1415926535897932385</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 float 版本的 pi</span></span><br><span class="line">    <span class="type">float</span> pi_f = pi&lt;<span class="type">float</span>&gt;;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Pi (float): &quot;</span> &lt;&lt; std::<span class="built_in">setprecision</span>(<span class="number">10</span>) &lt;&lt; pi_f &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 double 版本的 pi</span></span><br><span class="line">    <span class="type">double</span> pi_d = pi&lt;<span class="type">double</span>&gt;;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Pi (double): &quot;</span> &lt;&lt; std::<span class="built_in">setprecision</span>(<span class="number">20</span>) &lt;&lt; pi_d &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 也可以直接使用</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Pi (int): &quot;</span> &lt;&lt; pi&lt;<span class="type">int</span>&gt; &lt;&lt; std::endl; <span class="comment">// 会被截断为 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-别名模板-Alias-Templates-C-11"><a href="#4-别名模板-Alias-Templates-C-11" class="headerlink" title="4. 别名模板 (Alias Templates) (C++11)"></a>4. 别名模板 (Alias Templates) (C++11)</h4><p>C++11 引入了 <code>using</code> 关键字来创建模板化的别名，比 <code>typedef</code> 更加强大和直观。</p>
<p><strong>语法:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> NewTypeName = SomeExistingType&lt;T, ...&gt;;</span><br></pre></td></tr></table></figure>

<p><strong>示例：为 <code>std::map</code> 创建一个更简洁的别名</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个别名模板，表示一个键为 std::string，值为泛型 T 的 map</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> StringMap = std::map&lt;std::string, T&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以用于更复杂的类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> VecPtr = std::vector&lt;T*&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用别名模板，代码更清晰</span></span><br><span class="line">    StringMap&lt;<span class="type">int</span>&gt; ageMap;</span><br><span class="line">    ageMap[<span class="string">&quot;Alice&quot;</span>] = <span class="number">30</span>;</span><br><span class="line">    ageMap[<span class="string">&quot;Bob&quot;</span>] = <span class="number">25</span>;</span><br><span class="line"></span><br><span class="line">    VecPtr&lt;<span class="type">double</span>&gt; doublePointers;</span><br><span class="line">    doublePointers.<span class="built_in">push_back</span>(<span class="keyword">new</span> <span class="built_in">double</span>(<span class="number">3.14</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... 清理 new 出来的内存</span></span><br><span class="line">    <span class="keyword">delete</span> doublePointers[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="四、-模板的进阶主题"><a href="#四、-模板的进阶主题" class="headerlink" title="四、 模板的进阶主题"></a>四、 模板的进阶主题</h3><h4 id="1-非类型模板参数-Non-Type-Template-Parameters"><a href="#1-非类型模板参数-Non-Type-Template-Parameters" class="headerlink" title="1. 非类型模板参数 (Non-Type Template Parameters)"></a>1. 非类型模板参数 (Non-Type Template Parameters)</h4><p>模板参数不仅可以是类型，还可以是具体的<strong>常量表达式</strong>，如整型、指针、引用等。</p>
<p><strong>示例：一个固定大小的数组类</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span> <span class="comment">// std::array 就是一个很好的例子</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// T 是类型参数，N 是非类型参数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="type">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FixedArray</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T&amp; <span class="keyword">operator</span>[](<span class="type">size_t</span> index) &#123; <span class="keyword">return</span> data[index]; &#125;</span><br><span class="line">    <span class="type">const</span> T&amp; <span class="keyword">operator</span>[](<span class="type">size_t</span> index) <span class="type">const</span> &#123; <span class="keyword">return</span> data[index]; &#125;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> N; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T data[N]; <span class="comment">// 数组的大小在编译时就已确定</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个包含10个int的数组</span></span><br><span class="line">    FixedArray&lt;<span class="type">int</span>, <span class="number">10</span>&gt; intArray;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; intArray.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        intArray[i] = i * i;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;intArray[3] = &quot;</span> &lt;&lt; intArray[<span class="number">3</span>] &lt;&lt; std::endl; <span class="comment">// 输出 9</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个包含5个double的数组</span></span><br><span class="line">    FixedArray&lt;<span class="type">double</span>, <span class="number">5</span>&gt; doubleArray;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>std::array&lt;T, N&gt;</code> 就是使用这种技术实现的。</p>
<h4 id="2-模板特化-Template-Specialization"><a href="#2-模板特化-Template-Specialization" class="headerlink" title="2. 模板特化 (Template Specialization)"></a>2. 模板特化 (Template Specialization)</h4><p>有时候，一个通用的模板实现对于某个或某些特定类型可能不是最优的，或者根本不可行。这时，我们可以为这些特定类型提供一个“特供版”的实现，这就是模板特化。</p>
<h5 id="a-全特化-Full-Specialization"><a href="#a-全特化-Full-Specialization" class="headerlink" title="a. 全特化 (Full Specialization)"></a>a. 全特化 (Full Specialization)</h5><p>为模板的一个特定实例提供完整的、独立的定义。</p>
<p><strong>示例：比较两个 C 风格字符串</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span> <span class="comment">// for strcmp</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通用模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Comparer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">areEqual</span><span class="params">(<span class="type">const</span> T&amp; a, <span class="type">const</span> T&amp; b)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Using generic Comparer&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> a == b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对 const char* 类型的全特化版本</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Comparer</span>&lt;<span class="type">const</span> <span class="type">char</span>*&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">areEqual</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* a, <span class="type">const</span> <span class="type">char</span>* b)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Using specialized Comparer for const char*&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">strcmp</span>(a, b) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Comparer&lt;<span class="type">int</span>&gt;::<span class="built_in">areEqual</span>(<span class="number">10</span>, <span class="number">10</span>); <span class="comment">// 调用通用版本</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* s1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* s2 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    Comparer&lt;<span class="type">const</span> <span class="type">char</span>*&gt;::<span class="built_in">areEqual</span>(s1, s2); <span class="comment">// 调用特化版本</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通用模板比较 <code>const char*</code> 时，比较的是指针地址，这通常不是我们想要的。特化版本使用 <code>strcmp</code> 来比较字符串内容，这才是正确的行为。</p>
<h5 id="b-偏特化-Partial-Specialization"><a href="#b-偏特化-Partial-Specialization" class="headerlink" title="b. 偏特化 (Partial Specialization)"></a>b. 偏特化 (Partial Specialization)</h5><p>如果不想为某个具体类型特化，而是为<strong>某一类</strong>符合特定模式的类型进行特化，可以使用偏特化。偏特化只能用于类模板。</p>
<p><strong>示例：对所有指针类型进行特化</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通用版本</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TypeInfo</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;It&#x27;s a non-pointer type.&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对所有 T* (指针) 类型进行偏特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TypeInfo</span>&lt;T*&gt; &#123;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;It&#x27;s a pointer type!&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一个例子：对两个模板参数相同的 Pair 类进行偏特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Pair</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Pair</span>&lt;T, T&gt; &#123; <span class="comment">// 当 T 和 U 是同一种类型时的特化版本</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    TypeInfo&lt;<span class="type">int</span>&gt;::<span class="built_in">print</span>();      <span class="comment">// 匹配通用版本</span></span><br><span class="line">    TypeInfo&lt;<span class="type">double</span>*&gt;::<span class="built_in">print</span>();  <span class="comment">// 匹配 T* 偏特化版本</span></span><br><span class="line">    TypeInfo&lt;<span class="type">char</span>*&gt;::<span class="built_in">print</span>();    <span class="comment">// 匹配 T* 偏特化版本</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-变长参数模板-Variadic-Templates-C-11"><a href="#3-变长参数模板-Variadic-Templates-C-11" class="headerlink" title="3. 变长参数模板 (Variadic Templates) (C++11)"></a>3. 变长参数模板 (Variadic Templates) (C++11)</h4><p>C++11 引入了变长参数模板，允许模板接受任意数量、任意类型的参数。这对于实现 <code>printf</code>、<code>std::tuple</code>、<code>std::function</code> 等功能至关重要。</p>
<p><strong>语法:</strong><br>使用 <code>...</code> 来表示一个“参数包”（parameter pack）。</p>
<p><strong>示例：一个通用的 <code>print</code> 函数</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本情况：当没有参数时，停止递归</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归定义：处理第一个参数，然后用剩余的参数递归调用自己</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(T first, Args... args)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; first &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 处理第一个参数</span></span><br><span class="line">    <span class="built_in">print</span>(args...);           <span class="comment">// 递归调用，参数包 `args` 被展开</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello&quot;</span>, <span class="number">10</span>, <span class="number">3.14</span>, <span class="string">&#x27;a&#x27;</span>); <span class="comment">// 输出: Hello 10 3.14 a </span></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);          <span class="comment">// 输出: 1 2 3 4 5 </span></span><br><span class="line">    <span class="built_in">print</span>();                       <span class="comment">// 输出一个换行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>C++17 折叠表达式 (Fold Expressions)</strong><br>C++17 引入了折叠表达式，使得处理参数包更加简洁：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_cpp17</span><span class="params">(Args... args)</span> </span>&#123;</span><br><span class="line">    ( (std::cout &lt;&lt; args &lt;&lt; <span class="string">&quot; &quot;</span>), ... ); <span class="comment">// C++17 折叠表达式</span></span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="五、-模板的编译与实现机制"><a href="#五、-模板的编译与实现机制" class="headerlink" title="五、 模板的编译与实现机制"></a>五、 模板的编译与实现机制</h3><h4 id="1-编译时代码生成"><a href="#1-编译时代码生成" class="headerlink" title="1. 编译时代码生成"></a>1. 编译时代码生成</h4><p>模板本身不产生任何代码。只有当模板被<strong>实例化</strong>时（即被一个具体的类型使用时），编译器才会根据模板和指定的类型生成实际的 C++ 代码。<br>例如，<code>max(10, 20)</code> 会让编译器生成一个 <code>int max(int, int)</code> 的函数实例。<code>max(3.14, 2.71)</code> 会生成另一个 <code>double max(double, double)</code> 的函数实例。</p>
<h4 id="2-“包含模型”-Inclusion-Model"><a href="#2-“包含模型”-Inclusion-Model" class="headerlink" title="2. “包含模型” (Inclusion Model)"></a>2. “包含模型” (Inclusion Model)</h4><p>由于编译器需要在编译时访问模板的<strong>完整定义</strong>（而不仅仅是声明）来生成代码，所以模板的实现（函数体、类成员函数定义）通常必须放在头文件（<code>.h</code> 或 <code>.hpp</code>）中。</p>
<p>如果你将模板的声明放在 <code>.h</code> 文件，而将定义放在 <code>.cpp</code> 文件，那么在另一个 <code>.cpp</code> 文件中包含这个头文件并使用模板时，编译器将找不到模板的定义，导致链接错误（unresolved external symbol）。</p>
<p><strong>正确做法：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// my_template.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MY_TEMPLATE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MY_TEMPLATE_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">my_print</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义和声明都在头文件中</span></span><br><span class="line">    std::cout &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h3 id="六、-模板的优缺点"><a href="#六、-模板的优缺点" class="headerlink" title="六、 模板的优缺点"></a>六、 模板的优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol>
<li><strong>代码重用</strong>：一次编写，多处使用，减少了代码冗余。</li>
<li><strong>类型安全</strong>：所有类型检查都在编译时进行，不会有运行时的类型错误。</li>
<li><strong>高性能</strong>：模板是编译时多态，没有运行时开销（如虚函数的vtable查询）。生成的代码是针对特定类型高度优化的，与手写非模板代码的性能相当。</li>
<li><strong>泛型编程能力</strong>：是实现强大、灵活库（如STL）的基础。</li>
</ol>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol>
<li><strong>编译时间长</strong>：每次实例化都会生成新的代码，这会增加编译器的负担，导致编译时间变长。</li>
<li><strong>代码膨胀 (Code Bloat)</strong>：如果一个模板被多种类型大量实例化，最终生成的可执行文件体积可能会变大。</li>
<li><strong>错误信息复杂</strong>：模板代码的编译错误信息通常非常冗长、复杂，难以阅读和调试。因为错误可能发生在模板实例化的深层嵌套中。</li>
<li><strong>接口和实现紧耦合</strong>：模板的实现必须暴露在头文件中，破坏了接口与实现分离的原则。</li>
</ol>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>C++模板是一种极其强大的元编程工具，是现代C++的基石之一。它从简单的函数和类模板，到复杂的变长参数和特化技术，为开发者提供了编写高度通用、类型安全且高性能代码的能力。虽然它有编译时间长和错误信息复杂等缺点，但其带来的巨大优势使得它在系统编程、库开发等领域不可或缺。熟练掌握模板是成为一名高级C++程序员的必经之路。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://lx-cel.github.io">秋风、萧瑟</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://lx-cel.github.io/2025/10/22/CPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E6%A8%A1%E6%9D%BF/">https://lx-cel.github.io/2025/10/22/CPP学习笔记—模板/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://lx-cel.github.io" target="_blank">星海流光</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a><a class="post-meta__tags" href="/tags/cpp/">cpp</a></div><div class="post-share"><div class="social-share" data-image="/img/47.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/10/22/CPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E7%8E%B0%E4%BB%A3C-%E7%9A%84%E7%89%B9%E6%80%A7/" title="CPP学习笔记—现代C++的特性"><img class="cover" src="/img/48.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">CPP学习笔记—现代C++的特性</div></div><div class="info-2"><div class="info-item-1">C++11 被认为是 C++ 语言的一次重生，标志着“现代 C++”的开端。后续的标准则在这个基础上不断完善、增强和现代化。  一、 C++11：现代 C++ 的基石C++11 是一次巨大的飞跃，引入了大量深刻影响 C++ 编程范式的特性。 1. 语言核心增强 (提升易用性和表达力) auto 关键字：  是什么：自动类型推导。编译器可以根据变量的初始化表达式自动推导出其类型。 为什么需要：避免编写冗长、复杂的类型名，特别是对于 STL 迭代器和模板类型。 示例：1234// 旧式std::vector&lt;int&gt;::iterator it = my_vector.begin();// C++11auto it_new = my_vector.begin(); // 自动推导为 std::vector&lt;int&gt;::iterator   nullptr：  是什么：一个类型安全的空指针常量，类型为 std::nullptr_t。 为什么需要：解决了旧 NULL (通常是 0 或 (void*)0)...</div></div></div></a><a class="pagination-related" href="/2025/10/20/Linux%E5%91%BD%E4%BB%A4/" title="Linux命令"><img class="cover" src="/img/46.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Linux命令</div></div><div class="info-2"><div class="info-item-1">第一部分：Linux 命令行的基石在开始学习具体命令之前，理解几个核心概念至关重要。 1. 什么是 Shell？你输入的命令并不是由 Linux 内核直接处理的。你是在和一个叫做 Shell 的程序交互。Shell 是一个命令解释器，它接收你输入的命令，解释它们，然后请求操作系统（Linux 内核）来执行。  常见的 Shell： bash (Bourne Again SHell)：绝大多数 Linux 发行版的默认 Shell。 zsh (Z Shell)：功能更强大，配置更灵活，是很多开发者的最爱。 fish (Friendly Interactive SHell)：开箱即用，有很好的自动补全和语法高亮功能。    本介绍将以最常见的 bash 为例。 2. 命令的基本结构一个典型的 Linux 命令遵循以下结构： 1command [options] [arguments]   command (命令)：你要执行的程序的名称，例如 ls, cp, mkdir。 options (选项&#x2F;标志)：用来修改命令的行为。通常以一个或两个破折号 (- 或 --)...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/08/16/CPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/" title="CPP学习笔记—lambda表达式"><img class="cover" src="/img/24.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-16</div><div class="info-item-2">CPP学习笔记—lambda表达式</div></div><div class="info-2"><div class="info-item-1">Lambda 表达式是 C++11 引入的一项革命性特性，它极大地改变了 C++ 的编程风格，尤其是在与标准模板库（STL）配合使用时。它允许我们在代码中需要一个函数的地方，直接定义一个匿名的、临时的函数对象。  1. 什么是 Lambda 表达式？简单来说，Lambda 表达式就是一个可调用的代码单元，可以把它理解为一个匿名的内联函数。与普通函数不同，它可以在函数内部定义，并且可以“捕获”其所在作用域中的变量。 2. 为什么需要 Lambda 表达式？在 C++11 之前，如果想向一个算法（如 std::sort）传递一个简单的、一次性的比较逻辑，通常需要：  定义一个全局函数或静态成员函数：这会污染命名空间，并且逻辑与使用它的地方相隔甚远。 定义一个函数对象（Functor）：需要编写一个完整的类，重载 operator()。这非常繁琐。  Lambda 的优势：  代码局部性：将逻辑直接写在使用它的地方，代码更紧凑，可读性更高。 简洁性：避免了编写独立的函数或函数对象类的样板代码。 状态捕获：可以方便地访问和使用其定义作用域内的变量，这是普通函数难以做到的。   3....</div></div></div></a><a class="pagination-related" href="/2025/07/26/CPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E6%8C%87%E9%92%88/" title="CPP学习笔记—指针"><img class="cover" src="/img/21.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-26</div><div class="info-item-2">CPP学习笔记—指针</div></div><div class="info-2"><div class="info-item-1">一、指针到底是什么？—— 内存地址的“房卡”想象一下计算机的内存是一家长长的酒店，里面有无数的房间，每个房间都有一个独一无二的门牌号（内存地址）。  普通变量：就像一个房间，里面存放着具体的东西（值）。 1int age = 25; // 在一个叫 `age` 的房间里，放了数字 25。  指针：它本身也是一个变量，但它里面存放的不是普通的东西，而是一张房卡。这张房卡上写着另一个房间的门牌号。   所以，指针是一个存储了另一个变量内存地址的变量。通过这张“房卡”，我们就能找到并操作那个特定的“房间”。  二、两大核心操作符：&amp; (取地址) 和 * (解引用)要玩转指针，必须掌握这两个“魔法”操作符。 1. &amp; (取地址符) —— “制作房卡”&amp; 符号的作用是获取一个变量的内存地址。可以把它读作“…的地址”。 12345int age = 25;       // 一个存放 25 的房间 `age`int* p_age = &amp;age;  // 创建一张叫 `p_age` 的房卡，                    // 上面记录 `age`...</div></div></div></a><a class="pagination-related" href="/2025/07/26/CPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93%EF%BC%88STL%EF%BC%89%E4%B8%AD%E7%9A%84%E5%AE%B9%E5%99%A8/" title="CPP学习笔记—标准模板库（STL）中的容器"><img class="cover" src="/img/22.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-26</div><div class="info-item-2">CPP学习笔记—标准模板库（STL）中的容器</div></div><div class="info-2"><div class="info-item-1">一、什么是容器？为什么它如此重要？简单来说，C++ 容器是用来存储和管理一组对象的类模板。它们就像是工具箱里不同种类的收纳盒：有的适合快速取放（像数组），有的适合保持物品有序（像分类文件柜），还有的适合快速查找（像带索引的卡片盒）。 使用 STL 容器的好处是巨大的：  代码更简洁：你无需从零开始实现链表、哈希表等复杂数据结构。 性能更优越：STL 容器经过了高度优化，性能通常比手写的要好。 代码更安全：它们处理了内存管理的细节，减少了内存泄漏和越界访问的风险。 互操作性强：所有容器都遵循一套统一的接口（如 begin(), end(), size()），可以与 STL 的迭代器和算法无缝协作，威力倍增。   二、容器的分类与概览C++ 的容器主要分为四大类，分别是序列容器、关联容器、无序关联容器和容器适配器。    类别 容器 特点    序列容器 vector, deque, list, array 元素按线性顺序排列，可通过位置访问。   关联容器 map, set, multimap, multiset 元素根据键值自动排序，查找速度快 (O(log...</div></div></div></a><a class="pagination-related" href="/2025/08/27/CPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E5%A4%9A%E6%80%81/" title="CPP学习笔记—多态"><img class="cover" src="/img/31.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-27</div><div class="info-item-2">CPP学习笔记—多态</div></div><div class="info-2"><div class="info-item-1">什么是多态？多态，从字面意思上看，是“多种形态”的意思。在 C++ 中，多态是面向对象编程（OOP）的三大核心特性之一（另外两个是封装和继承）。它允许你使用一个统一的接口来处理不同类型的对象，使得程序具有更好的可扩展性和灵活性。 一个通俗的例子是：你有一个通用的“遥控器”（接口），这个遥控器上有个“开&#x2F;关”按钮。当你用这个遥控器对着电视机按“开&#x2F;关”，电视机就会打开或关闭；当你用同一个遥控器对着空调按“开&#x2F;关”，空调就会打开或关闭。遥控器本身并不知道它控制的是电视机还是空调，它只知道发出一个“开&#x2F;关”的指令。具体执行这个指令的是哪个设备，以及这个设备如何执行（电视机是点亮屏幕，空调是启动压缩机），是在运行时才决定的。 在 C++ 中，这个“遥控器”就是基类指针或引用，而“电视机”和“空调”就是派生类对象。 C++ 中的多态分类C++ 中的多态主要分为两类：  静态多态（编译时多态）：在程序编译期间就已经确定了函数调用的地址。它的执行速度快，但灵活性稍差。 动态多态（运行时多态）：在程序运行期间才能确定调用哪个函数。这是我们通常所说的...</div></div></div></a><a class="pagination-related" href="/2025/08/29/CPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/" title="CPP学习笔记—智能指针"><img class="cover" src="/img/34.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-29</div><div class="info-item-2">CPP学习笔记—智能指针</div></div><div class="info-2"><div class="info-item-1">1. 为什么需要智能指针？在 C&#x2F;C++ 中，内存管理是一个核心但又极易出错的话题。传统的内存管理依赖于程序员手动使用 new 和 delete (或 malloc 和 free) 来申请和释放内存。这导致了几个经典的问题：  内存泄漏 (Memory Leaks)：忘记调用 delete。当一个动态分配的对象不再被使用，但其内存没有被释放时，这块内存就无法被再次使用，造成了内存泄漏。长时间运行的程序中，内存泄漏会耗尽系统资源，导致程序崩溃。 悬挂指针 (Dangling Pointers)：一个指针指向的内存已经被释放，但指针本身没有被置为 nullptr。如果之后不小心通过这个悬挂指针访问或修改内存，会导致未定义行为（Undefined Behavior），通常表现为程序崩溃或数据损坏。 重复释放 (Double Free)：对同一块内存调用两次或多次 delete。这也是一种严重的未定义行为，通常会导致程序崩溃。 异常安全问题：在 new 和 delete 之间如果发生异常，delete 语句可能永远不会被执行，从而导致内存泄漏。  12345678void...</div></div></div></a><a class="pagination-related" href="/2025/08/28/CPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/" title="CPP学习笔记—深拷贝与浅拷贝"><img class="cover" src="/img/32.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-28</div><div class="info-item-2">CPP学习笔记—深拷贝与浅拷贝</div></div><div class="info-2"><div class="info-item-1">C++ 中的深拷贝（Deep Copy）和浅拷贝（Shallow Copy）是一个 C++ 实际开发中至关重要的核心概念，因为它直接关系到程序的正确性和内存安全。  1. 问题的根源：指针和动态内存要理解深拷贝和浅拷贝，首先必须明白问题的根源在哪里。如果一个类只包含基本数据类型（如 int, double）或者不持有动态资源的对象（如 std::string，它自己内部处理好了深拷贝），那么我们通常不需要关心这个问题。 问题出现在当一个类的成员变量是指针，并且这个指针指向了在堆（Heap）上动态分配的内存时。 来看一个简单的例子，一个自定义的字符串包装类： 123456789101112131415161718class MyString &#123;private:    char* _data;    size_t _len;public:    MyString(const char* s = &quot;&quot;) &#123;        _len = strlen(s);        _data = new char[_len + 1]; //...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="giscus-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/Cecilia.jpeg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">秋风、萧瑟</div><div class="author-info-description">梦想是用技术创造一个美好的世界</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">50</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">本站于2024年12月25日正式上线,博客内容主要是记录个人学习和技术分享,也欢迎技术交流!!!</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81-%E4%BB%80%E4%B9%88%E6%98%AFC-%E6%A8%A1%E6%9D%BF-What-are-C-Templates"><span class="toc-text">一、 什么是C++模板 (What are C++ Templates?)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%A8%A1%E6%9D%BF-Why-Do-We-Need-Templates"><span class="toc-text">二、 为什么需要模板 (Why Do We Need Templates?)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81-%E6%A8%A1%E6%9D%BF%E7%9A%84%E7%B1%BB%E5%9E%8B%E4%B8%8E%E4%BD%BF%E7%94%A8"><span class="toc-text">三、 模板的类型与使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF-Function-Templates"><span class="toc-text">1. 函数模板 (Function Templates)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%B1%BB%E6%A8%A1%E6%9D%BF-Class-Templates"><span class="toc-text">2. 类模板 (Class Templates)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%8F%98%E9%87%8F%E6%A8%A1%E6%9D%BF-Variable-Templates-C-14"><span class="toc-text">3. 变量模板 (Variable Templates) (C++14)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%88%AB%E5%90%8D%E6%A8%A1%E6%9D%BF-Alias-Templates-C-11"><span class="toc-text">4. 别名模板 (Alias Templates) (C++11)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81-%E6%A8%A1%E6%9D%BF%E7%9A%84%E8%BF%9B%E9%98%B6%E4%B8%BB%E9%A2%98"><span class="toc-text">四、 模板的进阶主题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%9D%9E%E7%B1%BB%E5%9E%8B%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0-Non-Type-Template-Parameters"><span class="toc-text">1. 非类型模板参数 (Non-Type Template Parameters)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%A8%A1%E6%9D%BF%E7%89%B9%E5%8C%96-Template-Specialization"><span class="toc-text">2. 模板特化 (Template Specialization)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#a-%E5%85%A8%E7%89%B9%E5%8C%96-Full-Specialization"><span class="toc-text">a. 全特化 (Full Specialization)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#b-%E5%81%8F%E7%89%B9%E5%8C%96-Partial-Specialization"><span class="toc-text">b. 偏特化 (Partial Specialization)</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%8F%98%E9%95%BF%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF-Variadic-Templates-C-11"><span class="toc-text">3. 变长参数模板 (Variadic Templates) (C++11)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E3%80%81-%E6%A8%A1%E6%9D%BF%E7%9A%84%E7%BC%96%E8%AF%91%E4%B8%8E%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6"><span class="toc-text">五、 模板的编译与实现机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%BC%96%E8%AF%91%E6%97%B6%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90"><span class="toc-text">1. 编译时代码生成</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E2%80%9C%E5%8C%85%E5%90%AB%E6%A8%A1%E5%9E%8B%E2%80%9D-Inclusion-Model"><span class="toc-text">2. “包含模型” (Inclusion Model)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AD%E3%80%81-%E6%A8%A1%E6%9D%BF%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">六、 模板的优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%82%B9"><span class="toc-text">优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9"><span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/10/24/CPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E7%BB%93%E6%9E%84%E5%8C%96%E7%BB%91%E5%AE%9A/" title="CPP学习笔记—结构化绑定"><img src="/img/52.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CPP学习笔记—结构化绑定"/></a><div class="content"><a class="title" href="/2025/10/24/CPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E7%BB%93%E6%9E%84%E5%8C%96%E7%BB%91%E5%AE%9A/" title="CPP学习笔记—结构化绑定">CPP学习笔记—结构化绑定</a><time datetime="2025-10-24T07:52:23.000Z" title="发表于 2025-10-24 15:52:23">2025-10-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/10/22/CPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/" title="CPP学习笔记—策略模式"><img src="/img/51.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CPP学习笔记—策略模式"/></a><div class="content"><a class="title" href="/2025/10/22/CPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/" title="CPP学习笔记—策略模式">CPP学习笔记—策略模式</a><time datetime="2025-10-22T15:37:59.000Z" title="发表于 2025-10-22 23:37:59">2025-10-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/10/22/CPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94std-function%E7%9A%84%E7%94%A8%E6%B3%95/" title="CPP学习笔记—std::function的用法"><img src="/img/50.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CPP学习笔记—std::function的用法"/></a><div class="content"><a class="title" href="/2025/10/22/CPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94std-function%E7%9A%84%E7%94%A8%E6%B3%95/" title="CPP学习笔记—std::function的用法">CPP学习笔记—std::function的用法</a><time datetime="2025-10-22T15:33:26.000Z" title="发表于 2025-10-22 23:33:26">2025-10-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/10/22/CPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%92%8C%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89/" title="CPP学习笔记—右值引用和移动语义"><img src="/img/49.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CPP学习笔记—右值引用和移动语义"/></a><div class="content"><a class="title" href="/2025/10/22/CPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%92%8C%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89/" title="CPP学习笔记—右值引用和移动语义">CPP学习笔记—右值引用和移动语义</a><time datetime="2025-10-22T15:26:41.000Z" title="发表于 2025-10-22 23:26:41">2025-10-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/10/22/CPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E7%8E%B0%E4%BB%A3C-%E7%9A%84%E7%89%B9%E6%80%A7/" title="CPP学习笔记—现代C++的特性"><img src="/img/48.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CPP学习笔记—现代C++的特性"/></a><div class="content"><a class="title" href="/2025/10/22/CPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E7%8E%B0%E4%BB%A3C-%E7%9A%84%E7%89%B9%E6%80%A7/" title="CPP学习笔记—现代C++的特性">CPP学习笔记—现代C++的特性</a><time datetime="2025-10-22T14:43:46.000Z" title="发表于 2025-10-22 22:43:46">2025-10-22</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 - 2025 By 秋风、萧瑟</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'none',
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }
      
      const script = document.createElement('script')
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.isShuoshuo
  const option = null

  const getGiscusTheme = theme => theme === 'dark' ? 'dark' : 'light'

  const createScriptElement = config => {
    const ele = document.createElement('script')
    Object.entries(config).forEach(([key, value]) => {
      ele.setAttribute(key, value)
    })
    return ele
  }

  const loadGiscus = (el = document, key) => {
    const mappingConfig = isShuoshuo
      ? { 'data-mapping': 'specific', 'data-term': key }
      : { 'data-mapping': (option && option['data-mapping']) || 'pathname' }

    const giscusConfig = {
      src: 'https://giscus.app/client.js',
      'data-repo': 'LX-Cel/lx-cel.github.io',
      'data-repo-id': 'R_kgDONd3anw',
      'data-category-id': 'DIC_kwDONd3an84ClwRS',
      'data-theme': getGiscusTheme(document.documentElement.getAttribute('data-theme')),
      'data-reactions-enabled': '1',
      crossorigin: 'anonymous',
      async: true,
      ...option,
      ...mappingConfig
    }

    const scriptElement = createScriptElement(giscusConfig)

    el.querySelector('#giscus-wrap').appendChild(scriptElement)

    if (isShuoshuo) {
      window.shuoshuoComment.destroyGiscus = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }
  }

  const changeGiscusTheme = theme => {
    const iframe = document.querySelector('#giscus-wrap iframe')
    if (iframe) {
      const message = {
        giscus: {
          setConfig: {
            theme: getGiscusTheme(theme)
          }
        }
      }
      iframe.contentWindow.postMessage(message, 'https://giscus.app')
    }
  }

  btf.addGlobalFn('themeChange', changeGiscusTheme, 'giscus')

  if (isShuoshuo) {
    'Giscus' === 'Giscus'
      ? window.shuoshuoComment = { loadComment: loadGiscus }
      : window.loadOtherComment = loadGiscus
    return
  }

  if ('Giscus' === 'Giscus' || !false) {
    if (false) btf.loadComment(document.getElementById('giscus-wrap'), loadGiscus)
    else loadGiscus()
  } else {
    window.loadOtherComment = loadGiscus
  }
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>