<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>I/O多路复用 | 星海流光</title><meta name="author" content="秋风、萧瑟"><meta name="copyright" content="秋风、萧瑟"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="I&#x2F;O 多路复用（I&#x2F;O Multiplexing）是一种在计算机网络编程中至关重要的技术，也是构建高性能服务器的基石。  1. 背景：为什么需要 I&#x2F;O 多路复用？想象一下你要开发一个网络服务器，需要同时处理多个客户端的连接。我们来看看几种最原始的模型以及它们的缺陷。 模型一：阻塞 I&#x2F;O + 多进程&#x2F;多线程这是最直观的模型。主进程负责监听（li">
<meta property="og:type" content="article">
<meta property="og:title" content="I&#x2F;O多路复用">
<meta property="og:url" content="https://lx-cel.github.io/2025/10/20/I-O%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/index.html">
<meta property="og:site_name" content="星海流光">
<meta property="og:description" content="I&#x2F;O 多路复用（I&#x2F;O Multiplexing）是一种在计算机网络编程中至关重要的技术，也是构建高性能服务器的基石。  1. 背景：为什么需要 I&#x2F;O 多路复用？想象一下你要开发一个网络服务器，需要同时处理多个客户端的连接。我们来看看几种最原始的模型以及它们的缺陷。 模型一：阻塞 I&#x2F;O + 多进程&#x2F;多线程这是最直观的模型。主进程负责监听（li">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://lx-cel.github.io/img/45.jpg">
<meta property="article:published_time" content="2025-10-20T11:24:06.000Z">
<meta property="article:modified_time" content="2025-10-19T16:00:00.000Z">
<meta property="article:author" content="秋风、萧瑟">
<meta property="article:tag" content="学习笔记">
<meta property="article:tag" content="操作系统">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://lx-cel.github.io/img/45.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://lx-cel.github.io/2025/10/20/I-O%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'I/O多路复用',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><meta name="generator" content="Hexo 8.1.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/Cecilia.jpeg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">50</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/45.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">星海流光</span></a><a class="nav-page-title" href="/"><span class="site-name">I/O多路复用</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">I/O多路复用</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-10-20T11:24:06.000Z" title="发表于 2025-10-20 19:24:06">2025-10-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-10-19T16:00:00.000Z" title="更新于 2025-10-20 00:00:00">2025-10-20</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">4.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>15分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>I&#x2F;O 多路复用（I&#x2F;O Multiplexing）是一种在计算机网络编程中至关重要的技术，也是构建高性能服务器的基石。</p>
<hr>
<h3 id="1-背景：为什么需要-I-O-多路复用？"><a href="#1-背景：为什么需要-I-O-多路复用？" class="headerlink" title="1. 背景：为什么需要 I&#x2F;O 多路复用？"></a>1. 背景：为什么需要 I&#x2F;O 多路复用？</h3><p>想象一下你要开发一个网络服务器，需要同时处理多个客户端的连接。我们来看看几种最原始的模型以及它们的缺陷。</p>
<h4 id="模型一：阻塞-I-O-多进程-多线程"><a href="#模型一：阻塞-I-O-多进程-多线程" class="headerlink" title="模型一：阻塞 I&#x2F;O + 多进程&#x2F;多线程"></a>模型一：阻塞 I&#x2F;O + 多进程&#x2F;多线程</h4><p>这是最直观的模型。主进程负责监听（<code>listen</code>）新的连接请求。每当有一个新的客户端连接进来（<code>accept</code>），服务器就创建一个新的进程或线程专门为这个客户端服务。</p>
<ul>
<li><p><strong>工作流程</strong>：</p>
<ol>
<li>主线程&#x2F;进程 <code>accept()</code> 等待新连接，阻塞。</li>
<li>新连接到达，<code>accept()</code> 返回一个新的<code>socket</code>文件描述符（<code>fd</code>）。</li>
<li>创建一个子线程&#x2F;进程，将这个新的<code>fd</code>交给它处理。</li>
<li>子线程&#x2F;进程在这个<code>fd</code>上调用 <code>read()</code>&#x2F;<code>recv()</code>，等待客户端发送数据，阻塞。</li>
<li>数据到达，<code>read()</code> 返回，处理数据，然后可能调用 <code>write()</code>&#x2F;<code>send()</code>，也可能阻塞。</li>
<li>主线程&#x2F;进程继续循环，等待下一个连接。</li>
</ol>
</li>
<li><p><strong>缺点</strong>：</p>
<ul>
<li><strong>资源开销巨大</strong>：每来一个连接就要创建一个线程&#x2F;进程。线程需要栈空间（通常是 MB 级别），进程开销更大。当连接数成千上万时（即著名的 <strong>C10K 问题</strong>），系统资源会迅速耗尽。</li>
<li><strong>上下文切换频繁</strong>：大量的线程&#x2F;进程会导致 CPU 在它们之间频繁切换，这本身就是一笔巨大的性能开销。</li>
</ul>
</li>
</ul>
<h4 id="模型二：非阻塞-I-O-忙轮询-Busy-Polling"><a href="#模型二：非阻塞-I-O-忙轮询-Busy-Polling" class="headerlink" title="模型二：非阻塞 I&#x2F;O + 忙轮询 (Busy-Polling)"></a>模型二：非阻塞 I&#x2F;O + 忙轮询 (Busy-Polling)</h4><p>为了解决阻塞问题，我们可以将 <code>socket</code> 设置为非阻塞模式。</p>
<ul>
<li><p><strong>工作流程</strong>：</p>
<ol>
<li>将监听 <code>socket</code> 和所有已连接的 <code>socket</code> 都设置为非阻塞。</li>
<li>用一个循环，不断地遍历所有的 <code>socket</code> 文件描述符。</li>
<li>对监听 <code>socket</code> 尝试调用 <code>accept()</code>，如果有新连接就处理，没有就立即返回错误（如 <code>EWOULDBLOCK</code>）。</li>
<li>对已连接的 <code>socket</code> 尝试调用 <code>read()</code>，如果有数据就处理，没有就立即返回错误。</li>
</ol>
</li>
<li><p><strong>缺点</strong>：</p>
<ul>
<li><strong>CPU 100%</strong>：无论 <code>socket</code> 是否活跃，这个循环都在疯狂地、无差别地遍历所有 <code>socket</code>，进行大量的无效系统调用。这会导致 CPU 使用率飙升，大部分时间都在做无用功。</li>
</ul>
</li>
</ul>
<p>这两种模型都有致命的缺陷。我们需要一种更优雅的方式：<strong>既能避免为每个连接创建线程，又能避免 CPU 空转。</strong></p>
<hr>
<h3 id="2-核心思想：它到底是什么？"><a href="#2-核心思想：它到底是什么？" class="headerlink" title="2. 核心思想：它到底是什么？"></a>2. 核心思想：它到底是什么？</h3><p><strong>I&#x2F;O 多路复用</strong> 就是为了解决上述问题而生的。</p>
<p>它的核心思想可以概括为：<strong>将“等待”这个任务交给操作系统内核去做。</strong></p>
<ul>
<li><strong>“I&#x2F;O”</strong>：指的是网络 I&#x2F;O，如 <code>read</code>、<code>write</code>。</li>
<li><strong>“多路”</strong>：指的是多个网络连接，即多个 <code>socket</code> 文件描述符（<code>fd</code>）。</li>
<li><strong>“复用”</strong>：指的是复用同一个线程（或少量线程）来处理这些连接。</li>
</ul>
<p><strong>技术上讲，I&#x2F;O 多路复用是一种同步I&#x2F;O模型。</strong> 它的关键是一个能够<strong>同时监视多个文件描述符</strong>的系统调用（如 <code>select</code>, <code>poll</code>, <code>epoll</code>）。这个调用会<strong>阻塞</strong>，直到一个或多个 <code>fd</code> 变为“就绪”状态（比如可读、可写、或出错）。当调用返回时，它会告诉我们哪些 <code>fd</code> 已经准备好了，然后我们的单个线程就可以去依次处理这些就绪的 <code>fd</code>，而不会在未就绪的 <code>fd</code> 上浪费时间。</p>
<hr>
<h3 id="3-三种主要实现：select-poll-epoll"><a href="#3-三种主要实现：select-poll-epoll" class="headerlink" title="3. 三种主要实现：select, poll, epoll"></a>3. 三种主要实现：<code>select</code>, <code>poll</code>, <code>epoll</code></h3><p>这三种是 Linux 系统下 I&#x2F;O 多路复用的主要实现机制。</p>
<h4 id="A-select"><a href="#A-select" class="headerlink" title="A. select"></a>A. <code>select</code></h4><p><code>select</code> 是最早的、最通用的 I&#x2F;O 多路复用实现，几乎所有操作系统都支持。</p>
<ul>
<li><p><strong>工作方式</strong>：</p>
<ol>
<li>你需要创建三个文件描述符集合（<code>fd_set</code>），分别用于监视<strong>可读</strong>、<strong>可写</strong>和<strong>异常</strong>事件。<code>fd_set</code> 本质上是一个位图（bitmask）。</li>
<li>将你关心的 <code>fd</code> 添加到相应的集合中。</li>
<li>调用 <code>select(max_fd + 1, &amp;read_fds, &amp;write_fds, &amp;except_fds, &amp;timeout)</code>。</li>
<li><code>select</code> 函数会阻塞，直到有 <code>fd</code> 就绪或者超时。</li>
<li>函数返回后，<code>fd_set</code> 会被内核修改，只有那些就绪的 <code>fd</code> 对应的位仍然是 1。</li>
<li>你需要遍历整个 <code>fd_set</code>（从 0 到 <code>max_fd</code>），检查哪个 <code>fd</code> 对应的位是 1，然后处理它。</li>
</ol>
</li>
<li><p><strong>缺点</strong>：</p>
<ol>
<li><strong>最大连接数限制</strong>：<code>fd_set</code> 的大小是固定的（通常是 1024 或 2048），由 <code>FD_SETSIZE</code> 宏定义，这限制了 <code>select</code> 能同时监视的 <code>fd</code> 数量。</li>
<li><strong>重复的数据拷贝</strong>：每次调用 <code>select</code> 前，都需要重新构建 <code>fd_set</code>，因为内核会修改它。并且，每次调用时，都需要将这个 <code>fd_set</code> 从用户空间完整地拷贝到内核空间。连接数越多，拷贝开销越大。</li>
<li><strong>线性扫描开销</strong>：<code>select</code> 返回后，你只知道“有 <code>fd</code> 就绪了”，但不知道是哪几个。你必须遍历所有被监视的 <code>fd</code> 来找到就绪的那些。如果监视了 1000 个 <code>fd</code>，但只有 1 个就绪，你仍然要做 1000 次检查。这个开销是 O(N)，N 是被监视的 <code>fd</code> 总数。</li>
</ol>
</li>
</ul>
<h4 id="B-poll"><a href="#B-poll" class="headerlink" title="B. poll"></a>B. <code>poll</code></h4><p><code>poll</code> 是对 <code>select</code> 的改进，解决了 <code>select</code> 的一些问题。</p>
<ul>
<li><p><strong>工作方式</strong>：</p>
<ol>
<li><code>poll</code> 不再使用 <code>fd_set</code>，而是使用一个 <code>pollfd</code> 结构体数组。每个 <code>pollfd</code> 结构体包含 <code>fd</code>、关心的事件（<code>events</code>）和返回的实际发生的事件（<code>revents</code>）。</li>
<li>你创建一个 <code>pollfd</code> 数组，填入你关心的 <code>fd</code> 和事件。</li>
<li>调用 <code>poll(fds_array, num_fds, timeout)</code>。</li>
<li><code>poll</code> 返回后，你遍历这个数组，检查每个 <code>pollfd</code> 结构体的 <code>revents</code> 字段，来判断该 <code>fd</code> 是否就绪。</li>
</ol>
</li>
<li><p><strong>相比 <code>select</code> 的改进</strong>：</p>
<ol>
<li><strong>无最大连接数限制</strong>：它使用数组而非位图，理论上可以监视的 <code>fd</code> 数量只受限于系统内存。</li>
</ol>
</li>
<li><p><strong>仍然存在的缺点</strong>：</p>
<ol>
<li><strong>重复的数据拷贝</strong>：每次调用 <code>poll</code>，仍然需要将整个 <code>pollfd</code> 数组从用户空间拷贝到内核空间。</li>
<li><strong>线性扫描开销</strong>：<code>poll</code> 返回后，你仍然需要遍历整个 <code>pollfd</code> 数组来找到就绪的 <code>fd</code>。开销依然是 O(N)。</li>
</ol>
</li>
</ul>
<h4 id="C-epoll-Linux-特有"><a href="#C-epoll-Linux-特有" class="headerlink" title="C. epoll (Linux 特有)"></a>C. <code>epoll</code> (Linux 特有)</h4><p><code>epoll</code> 是对 <code>select</code> 和 <code>poll</code> 的重大改进，是 Linux 下实现高性能网络服务器的首选，它彻底解决了前两者的核心性能瓶瓶颈。</p>
<ul>
<li><p><strong>工作方式</strong>：<code>epoll</code> 将其功能分成了三个独立的系统调用。</p>
<ol>
<li><code>epoll_create()</code>: 在内核中创建一个 <code>epoll</code> 实例，并返回一个指向该实例的文件描述符（<code>epoll_fd</code>）。这个实例内部维护了需要监视的 <code>fd</code> 集合（通常是红黑树）和就绪 <code>fd</code> 列表（链表）。<strong>这个创建动作只需要一次</strong>。</li>
<li><code>epoll_ctl()</code>: 用于向 <code>epoll</code> 实例中<strong>添加</strong>（<code>EPOLL_CTL_ADD</code>）、<strong>修改</strong>（<code>EPOLL_CTL_MOD</code>）或<strong>删除</strong>（<code>EPOLL_CTL_DEL</code>）需要监视的 <code>fd</code>。每个 <code>fd</code> 只需要通过 <code>epoll_ctl</code> 添加一次，之后它就一直在内核的监视列表中，无需在每次等待时重复提交。</li>
<li><code>epoll_wait()</code>: 等待事件发生，类似于 <code>select</code> 和 <code>poll</code>。但它返回时，<strong>只会返回那些已经就绪的 <code>fd</code></strong>，而不是所有被监视的 <code>fd</code>。它会将就绪的 <code>fd</code> 列表从内核空间拷贝到用户空间的一个数组里。</li>
</ol>
</li>
<li><p><strong>相比 <code>select</code> 和 <code>poll</code> 的巨大优势</strong>：</p>
<ol>
<li><strong>无需重复拷贝</strong>：<code>fd</code> 列表通过 <code>epoll_ctl</code> 维护在内核中，调用 <code>epoll_wait</code> 时无需重复拷贝整个列表。</li>
<li><strong>没有线性扫描</strong>：<code>epoll</code> 的核心是事件驱动。当某个 <code>fd</code> 就绪时，内核会通过<strong>回调机制</strong>将其加入到一个就绪链表中。<code>epoll_wait</code> 只是检查这个链表是否为空，如果不为空，就返回链表中的内容。因此，其时间复杂度是 O(1)（或者说 O(k)，k 为就绪的 <code>fd</code> 数量），与被监视的 <code>fd</code> 总数无关！</li>
<li><strong>内存共享 (mmap)</strong>: <code>epoll</code> 通过 <code>mmap</code> 技术让内核和用户空间共享一块内存，进一步避免了不必要的内存拷贝。</li>
</ol>
</li>
</ul>
<hr>
<h3 id="4-详细对比：select-vs-poll-vs-epoll"><a href="#4-详细对比：select-vs-poll-vs-epoll" class="headerlink" title="4. 详细对比：select vs poll vs epoll"></a>4. 详细对比：<code>select</code> vs <code>poll</code> vs <code>epoll</code></h3><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left"><code>select</code></th>
<th align="left"><code>poll</code></th>
<th align="left"><code>epoll</code></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>底层数据结构</strong></td>
<td align="left">位图 (Bitmask)</td>
<td align="left">结构体数组 (Array of structs)</td>
<td align="left">红黑树 + 双向链表</td>
</tr>
<tr>
<td align="left"><strong>FD 数量限制</strong></td>
<td align="left">有，通常是 1024 (<code>FD_SETSIZE</code>)</td>
<td align="left">无 (受限于内存)</td>
<td align="left">无 (受限于内存)</td>
</tr>
<tr>
<td align="left"><strong>用户&#x2F;内核拷贝</strong></td>
<td align="left">每次调用都拷贝整个 <code>fd_set</code></td>
<td align="left">每次调用都拷贝整个 <code>pollfd</code> 数组</td>
<td align="left">初始 <code>epoll_ctl</code> 时拷贝，<code>epoll_wait</code> 只拷贝就绪的 fd</td>
</tr>
<tr>
<td align="left"><strong>内核扫描方式</strong></td>
<td align="left">线性扫描所有被监视的 fd</td>
<td align="left">线性扫描所有被监视的 fd</td>
<td align="left">事件回调，只处理活跃的 fd</td>
</tr>
<tr>
<td align="left"><strong>效率</strong></td>
<td align="left">O(N)</td>
<td align="left">O(N)</td>
<td align="left">O(1) 或 O(k) (k为活跃连接数)</td>
</tr>
<tr>
<td align="left"><strong>可移植性</strong></td>
<td align="left">非常好，所有主流系统支持</td>
<td align="left">较好，大部分 Unix-like 系统支持</td>
<td align="left">差，仅 Linux 2.6+ 支持</td>
</tr>
<tr>
<td align="left"><strong>API 使用</strong></td>
<td align="left">简单，但每次调用需重置 <code>fd_set</code></td>
<td align="left">简单</td>
<td align="left">稍复杂，分为 <code>create</code>, <code>ctl</code>, <code>wait</code></td>
</tr>
</tbody></table>
<p><strong>总结</strong>：在连接数少、且都比较活跃的情况下，<code>select</code> 和 <code>poll</code> 的性能尚可。但在高并发、大量连接（其中大部分是空闲的）场景下，<code>epoll</code> 的性能优势是压倒性的。</p>
<hr>
<h3 id="5-工作模式：水平触发-LT-vs-边沿触发-ET"><a href="#5-工作模式：水平触发-LT-vs-边沿触发-ET" class="headerlink" title="5. 工作模式：水平触发 (LT) vs 边沿触发 (ET)"></a>5. 工作模式：水平触发 (LT) vs 边沿触发 (ET)</h3><p>首先，我们要明白“触发”指的是什么。在 <code>epoll</code> 的语境下，“触发”是指<strong>当一个被监视的文件描述符（<code>fd</code>）满足了我们所关心的事件（如可读、可写）时，<code>epoll_wait</code> 会被唤醒并返回该 <code>fd</code></strong>。</p>
<p>LT 和 ET 的根本区别在于 <strong><code>epoll_wait</code> 被唤醒并返回的“时机”和“条件”</strong>。</p>
<h4 id="A、-水平触发-Level-Triggered-LT"><a href="#A、-水平触发-Level-Triggered-LT" class="headerlink" title="A、 水平触发 (Level Triggered, LT)"></a>A、 水平触发 (Level Triggered, LT)</h4><p>LT 是 <code>epoll</code> 的<strong>默认工作模式</strong>。它的行为模式非常直观，也和传统的 <code>select</code>、<code>poll</code> 类似。</p>
<p><strong>只要文件描述符处于某个我们关心的状态（State），<code>epoll_wait</code> 就会一直触发通知。</strong></p>
<ul>
<li><strong>对于读事件</strong>：只要该 <code>fd</code> 的内核接收缓冲区里<strong>有数据</strong>（缓冲区大小 &gt; 0），<code>epoll_wait</code> 每次被调用时都会返回这个 <code>fd</code>，告诉你“嘿，这里有数据，你可以读了！”。</li>
<li><strong>对于写事件</strong>：只要该 <code>fd</code> 的内核发送缓冲区<strong>没有满</strong>（还有空间可以写入），<code>epoll_wait</code> 每次被调用时都会返回这个 <code>fd</code>，告诉你“嘿，这里有地方，你可以写了！”。</li>
</ul>
<p>假设一个客户端发送了 1000 字节的数据到服务器。</p>
<ol>
<li><strong>数据到达</strong>：1000 字节数据进入了服务器端 <code>socket</code> 的内核接收缓冲区。</li>
<li><strong>第一次触发</strong>：应用程序调用 <code>epoll_wait</code>，它会立即返回，报告这个 <code>socket fd</code> 是可读的。</li>
<li><strong>不完整的处理</strong>：你的应用程序代码从这个 <code>fd</code> 中只读取了 500 字节，因为你程序里的 buffer 只有这么大。此时，内核缓冲区里还<strong>剩下 500 字节</strong>。</li>
<li><strong>再次调用 <code>epoll_wait</code></strong>：当你的事件循环下一次调用 <code>epoll_wait</code> 时，由于内核缓冲区里<strong>仍然有数据</strong>（满足“可读”状态），<code>epoll_wait</code> 会<strong>再一次</strong>立即返回，告诉你这个 <code>fd</code> 还是可读的。</li>
<li><strong>继续处理</strong>：你的程序再次读取剩下的 500 字节。现在内核缓冲区空了。</li>
<li><strong>停止触发</strong>：再下一次调用 <code>epoll_wait</code> 时，由于“可读”状态已经不存在，它将不会再因为这个 <code>fd</code> 而返回（除非有新数据到达）。</li>
</ol>
<ul>
<li><p><strong>优点</strong>：</p>
<ul>
<li><strong>编程简单，不易出错</strong>：它的逻辑非常稳健（robust）。即使你因为某些原因没有一次性把数据处理完，也不用担心数据会“丢失”事件通知。下一次循环 <code>epoll</code> 还会提醒你，给了你“亡羊补牢”的机会。</li>
<li><strong>与 <code>select</code>&#x2F;<code>poll</code> 兼容</strong>：行为模式一致，从旧模型迁移过来比较容易。</li>
</ul>
</li>
<li><p><strong>缺点</strong>：</p>
<ul>
<li><strong>可能导致不必要的唤醒</strong>：如果你的程序逻辑有问题，一直不去处理某个 <code>fd</code> 上的数据，<code>epoll_wait</code> 会被反复地、无效地唤醒，造成一点性能开销（尽管这个开销远小于 <code>select</code> 的 O(N) 扫描）。这在某种程度上是“惊群效应”的微缩版。</li>
</ul>
</li>
</ul>
<h4 id="B、-边沿触发-Edge-Triggered-ET"><a href="#B、-边沿触发-Edge-Triggered-ET" class="headerlink" title="B、 边沿触发 (Edge Triggered, ET)"></a>B、 边沿触发 (Edge Triggered, ET)</h4><p>ET 是一种更高性能但编程要求也更高的模式。要使用 ET 模式，你需要在 <code>epoll_ctl</code> 添加 <code>fd</code> 时明确指定 <code>EPOLLET</code> 标志。</p>
<p><strong>只有当文件描述符的状态发生变化（Transition &#x2F; Edge）时，<code>epoll_wait</code> 才会触发一次通知。</strong></p>
<ul>
<li><strong>对于读事件</strong>：只有当 <code>fd</code> 的内核接收缓冲区<strong>从空变为非空</strong>的那一刻，<code>epoll_wait</code> 才会返回这个 <code>fd</code>。之后，即使缓冲区里还有数据，只要没有<strong>新</strong>的数据到达，<code>epoll_wait</code> 也<strong>不会</strong>再返回这个 <code>fd</code>。</li>
<li><strong>对于写事件</strong>：只有当 <code>fd</code> 的内核发送缓冲区<strong>从满变为非满</strong>的那一刻，<code>epoll_wait</code> 才会返回这个 <code>fd</code>。</li>
</ul>
<p>同样，客户端发送了 1000 字节的数据到服务器。</p>
<ol>
<li><strong>数据到达</strong>：1000 字节数据进入内核缓冲区，状态从<strong>空 -&gt; 非空</strong>，一个“边沿”产生了。</li>
<li><strong>第一次触发</strong>：应用程序调用 <code>epoll_wait</code>，它会返回，报告这个 <code>socket fd</code> 可读。</li>
<li><strong>不完整的处理</strong>：你的应用程序只读取了 500 字节。内核缓冲区里还<strong>剩下 500 字节</strong>。</li>
<li><strong>再次调用 <code>epoll_wait</code></strong>：当你的事件循环下一次调用 <code>epoll_wait</code> 时，尽管缓冲区里还有数据，但因为<strong>没有新的“边沿”产生</strong>（状态没有从空变为非空），<code>epoll_wait</code> 将会<strong>阻塞</strong>，<strong>不会</strong>因为这个 <code>fd</code> 而返回！</li>
<li><strong>后果</strong>：剩下的 500 字节数据就被“遗忘”在缓冲区里了。你的程序将永远不会收到关于这 500 字节的通知，直到客户端<strong>发送下一批新数据</strong>，从而产生一个新的“边沿”。这就导致了数据处理的延迟甚至丢失。</li>
</ol>
<p>为了避免上述问题，使用 ET 模式时必须遵循一个黄金法则：</p>
<p><strong>当收到一个 ET 事件通知时，你必须持续地对该 <code>fd</code> 进行 I&#x2F;O 操作，直到该操作返回 <code>EAGAIN</code> 或 <code>EWOULDBLOCK</code> 错误为止。</strong></p>
<p>这意味着：</p>
<ul>
<li><strong>文件描述符必须设置为非阻塞（<code>O_NONBLOCK</code>）</strong>。这是绝对的前提，否则当缓冲区读完后，最后一次 <code>read()</code> 调用会永远阻塞你的程序。</li>
<li><strong>使用循环来处理 I&#x2F;O</strong>。</li>
</ul>
<p>正确的ET读操作代码伪代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// epoll_wait 返回了就绪的 fd</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 循环读取</span></span><br><span class="line">    bytes_read = read(fd, buffer, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bytes_read == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果错误是 EAGAIN 或 EWOULDBLOCK，说明数据已经读完了</span></span><br><span class="line">        <span class="keyword">if</span> (errno == EAGAIN || errno == EWOULDBLOCK) &#123;</span><br><span class="line">            <span class="comment">// 这不是一个真正的错误，只是一个信号：ET事件处理完毕</span></span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 其他错误，表示连接出错了</span></span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            close(fd);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bytes_read == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 对端关闭了连接</span></span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 成功读取了 bytes_read 字节的数据，处理它</span></span><br><span class="line">        process_data(buffer, bytes_read);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写操作同理，需要在一个循环里 <code>write()</code>，直到数据全部写完或者 <code>write()</code> 返回 <code>EAGAIN</code>。</p>
<ul>
<li><p><strong>优点</strong>：</p>
<ul>
<li><strong>性能极高</strong>：它极大地减少了 <code>epoll_wait</code> 被唤醒的次数，从而降低了系统调用的开销。一个事件只通知一次，非常高效，特别是在有大量连接但只有少数活跃的场景下。Nginx、Redis 等高性能组件都重度使用 ET 模式。</li>
<li><strong>避免“惊群”</strong>：在多线程环境下，一个事件不会被多个线程同时处理，因为只有一个线程会收到该事件的通知。</li>
</ul>
</li>
<li><p><strong>缺点</strong>：</p>
<ul>
<li><strong>编程复杂度高</strong>：逻辑比 LT 复杂得多，非常容易出错。如果忘记了循环处理 I&#x2F;O 直到 <code>EAGAIN</code>，就会导致数据饥饿（starvation）或连接假死。</li>
<li><strong>对程序员要求高</strong>：需要对非阻塞 I&#x2F;O 和事件循环有深刻的理解。</li>
</ul>
</li>
</ul>
<h4 id="C、-总结与对比"><a href="#C、-总结与对比" class="headerlink" title="C、 总结与对比"></a>C、 总结与对比</h4><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">水平触发 (Level Triggered, LT)</th>
<th align="left">边沿触发 (Edge Triggered, ET)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>触发条件</strong></td>
<td align="left">只要满足条件（缓冲区有数据&#x2F;有空间），就<strong>持续触发</strong></td>
<td align="left">仅在状态<strong>发生改变</strong>（空-&gt;非空，满-&gt;非满）时，<strong>触发一次</strong></td>
</tr>
<tr>
<td align="left"><strong>工作模式</strong></td>
<td align="left">状态驱动 (State-driven)</td>
<td align="left">变化驱动 (Transition-driven)</td>
</tr>
<tr>
<td align="left"><strong>处理要求</strong></td>
<td align="left">可以不一次性处理完所有数据，下次还会收到通知</td>
<td align="left"><strong>必须</strong>一次性处理完所有数据，直到返回 <code>EAGAIN</code>&#x2F;<code>EWOULDBLOCK</code></td>
</tr>
<tr>
<td align="left"><strong>依赖</strong></td>
<td align="left">无特殊依赖</td>
<td align="left"><strong>必须</strong>与非阻塞 I&#x2F;O (<code>O_NONBLOCK</code>) 配合使用</td>
</tr>
<tr>
<td align="left"><strong>编程复杂度</strong></td>
<td align="left"><strong>低</strong>，逻辑简单，容错性好</td>
<td align="left"><strong>高</strong>，逻辑复杂，易出错（如数据饥饿）</td>
</tr>
<tr>
<td align="left"><strong>性能</strong></td>
<td align="left">较好，但可能有不必要的唤醒</td>
<td align="left"><strong>极高</strong>，系统调用次数最少</td>
</tr>
<tr>
<td align="left"><strong>适用场景</strong></td>
<td align="left">绝大多数常规场景，追求稳健和开发效率</td>
<td align="left">追求极致性能的场景，如高性能服务器 (Nginx)、中间件 (Redis)</td>
</tr>
<tr>
<td align="left"><strong>比喻</strong></td>
<td align="left">水位传感器（持续报警）</td>
<td align="left">门铃（只响一次）</td>
</tr>
</tbody></table>
<ul>
<li><strong>如果你不确定用哪个，或者你是初学者，请使用默认的 LT 模式。</strong> 它的稳健性可以帮你避免很多难以调试的 bug。</li>
<li><strong>只有当你明确知道你的应用瓶颈在于 <code>epoll</code> 的唤醒次数，并且你对非阻塞 I&#x2F;O 的编程模型有十足的把握时，才考虑使用 ET 模式。</strong> ET 是为追求极致性能的专家准备的“利器”，用不好很容易伤到自己。</li>
</ul>
<hr>
<h3 id="6-优缺点与应用场景"><a href="#6-优缺点与应用场景" class="headerlink" title="6. 优缺点与应用场景"></a>6. 优缺点与应用场景</h3><h4 id="I-O-多路复用的优点"><a href="#I-O-多路复用的优点" class="headerlink" title="I&#x2F;O 多路复用的优点"></a>I&#x2F;O 多路复用的优点</h4><ul>
<li><strong>高并发，低资源消耗</strong>：可以用极少的线程（甚至单线程）处理成千上万的并发连接，极大地节省了内存和 CPU 上下文切换的开销。</li>
<li><strong>统一事件源</strong>：可以将网络 I&#x2F;O、文件 I&#x2F;O、信号等多种事件源放在一起统一处理。</li>
</ul>
<h4 id="I-O-多路复用的缺点"><a href="#I-O-多路复用的缺点" class="headerlink" title="I&#x2F;O 多路复用的缺点"></a>I&#x2F;O 多路复用的缺点</h4><ul>
<li><strong>编程复杂度高</strong>：相比简单的多线程阻塞模型，使用 <code>select/poll/epoll</code> 需要自己管理连接状态，编写状态机，处理起来更复杂，尤其是 <code>epoll</code> 的 ET 模式。</li>
<li><strong>不适用于 CPU 密集型任务</strong>：如果每个连接的业务逻辑需要大量的 CPU 计算，那么单线程模型会导致所有其他连接被阻塞。在这种情况下，”I&#x2F;O线程 + 工作线程池” 的模式会更合适。</li>
</ul>
<h4 id="经典应用"><a href="#经典应用" class="headerlink" title="经典应用"></a>经典应用</h4><p>I&#x2F;O 多路复用是所有高性能网络框架和服务器的基石：</p>
<ul>
<li><strong>Nginx</strong>：经典的高性能 Web 服务器，其事件驱动模型就是基于 <code>epoll</code>。</li>
<li><strong>Redis</strong>：著名的内存数据库，其单线程却能实现极高 QPS 的原因就在于它采用了 <code>epoll</code> 进行 I&#x2F;O 多路复用。</li>
<li><strong>Node.js</strong>：其异步、非阻塞的特性底层就是由 libuv 库实现的，而 libuv 在 Linux 上正是封装了 <code>epoll</code>。</li>
<li><strong>Netty (Java)</strong>：Java NIO 的高性能网络框架，其 Selector 机制也是对 <code>select/poll/epoll</code> 的封装。</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://lx-cel.github.io">秋风、萧瑟</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://lx-cel.github.io/2025/10/20/I-O%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/">https://lx-cel.github.io/2025/10/20/I-O多路复用/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://lx-cel.github.io" target="_blank">星海流光</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a><a class="post-meta__tags" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></div><div class="post-share"><div class="social-share" data-image="/img/45.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/10/20/Linux%E5%91%BD%E4%BB%A4/" title="Linux命令"><img class="cover" src="/img/46.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Linux命令</div></div><div class="info-2"><div class="info-item-1">第一部分：Linux 命令行的基石在开始学习具体命令之前，理解几个核心概念至关重要。 1. 什么是 Shell？你输入的命令并不是由 Linux 内核直接处理的。你是在和一个叫做 Shell 的程序交互。Shell 是一个命令解释器，它接收你输入的命令，解释它们，然后请求操作系统（Linux 内核）来执行。  常见的 Shell： bash (Bourne Again SHell)：绝大多数 Linux 发行版的默认 Shell。 zsh (Z Shell)：功能更强大，配置更灵活，是很多开发者的最爱。 fish (Friendly Interactive SHell)：开箱即用，有很好的自动补全和语法高亮功能。    本介绍将以最常见的 bash 为例。 2. 命令的基本结构一个典型的 Linux 命令遵循以下结构： 1command [options] [arguments]   command (命令)：你要执行的程序的名称，例如 ls, cp, mkdir。 options (选项&#x2F;标志)：用来修改命令的行为。通常以一个或两个破折号 (- 或 --)...</div></div></div></a><a class="pagination-related" href="/2025/10/20/%E9%9B%B6%E6%8B%B7%E8%B4%9D/" title="零拷贝"><img class="cover" src="/img/44.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">零拷贝</div></div><div class="info-2"><div class="info-item-1">摘要：什么是零拷贝？零拷贝（Zero-Copy） 并不是指完全没有数据拷贝，而是指尽可能地减少或避免在应用程序的用户空间（User Space）和操作系统的内核空间（Kernel Space）之间进行不必要的CPU数据拷贝。其核心目标是让数据在从一个I&#x2F;O设备（如硬盘）到另一个I&#x2F;O设备（如网卡）的传输过程中，最大限度地利用硬件（如DMA）来搬运数据，从而解放CPU，减少上下文切换，显著提升数据传输的性能和效率。  一、 理解背景：传统I&#x2F;O的痛点要理解零拷贝的价值，我们必须先了解传统的数据传输方式有多么“昂贵”。 假设我们要实现一个简单的文件服务器，其功能是：从磁盘读取一个文件，然后通过网络发送给客户端。 传统I&#x2F;O的操作流程： 我们用代码来看，通常是这样的： 12read(file_fd, buffer, len);write(socket_fd, buffer, len);  这个看似简单的两行代码，在操作系统层面会触发一系列复杂的步骤：  第一次拷贝（DMA Copy）：  应用程序调用 read()...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/10/20/Linux%E5%91%BD%E4%BB%A4/" title="Linux命令"><img class="cover" src="/img/46.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-20</div><div class="info-item-2">Linux命令</div></div><div class="info-2"><div class="info-item-1">第一部分：Linux 命令行的基石在开始学习具体命令之前，理解几个核心概念至关重要。 1. 什么是 Shell？你输入的命令并不是由 Linux 内核直接处理的。你是在和一个叫做 Shell 的程序交互。Shell 是一个命令解释器，它接收你输入的命令，解释它们，然后请求操作系统（Linux 内核）来执行。  常见的 Shell： bash (Bourne Again SHell)：绝大多数 Linux 发行版的默认 Shell。 zsh (Z Shell)：功能更强大，配置更灵活，是很多开发者的最爱。 fish (Friendly Interactive SHell)：开箱即用，有很好的自动补全和语法高亮功能。    本介绍将以最常见的 bash 为例。 2. 命令的基本结构一个典型的 Linux 命令遵循以下结构： 1command [options] [arguments]   command (命令)：你要执行的程序的名称，例如 ls, cp, mkdir。 options (选项&#x2F;标志)：用来修改命令的行为。通常以一个或两个破折号 (- 或 --)...</div></div></div></a><a class="pagination-related" href="/2025/10/20/%E9%9B%B6%E6%8B%B7%E8%B4%9D/" title="零拷贝"><img class="cover" src="/img/44.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-20</div><div class="info-item-2">零拷贝</div></div><div class="info-2"><div class="info-item-1">摘要：什么是零拷贝？零拷贝（Zero-Copy） 并不是指完全没有数据拷贝，而是指尽可能地减少或避免在应用程序的用户空间（User Space）和操作系统的内核空间（Kernel Space）之间进行不必要的CPU数据拷贝。其核心目标是让数据在从一个I&#x2F;O设备（如硬盘）到另一个I&#x2F;O设备（如网卡）的传输过程中，最大限度地利用硬件（如DMA）来搬运数据，从而解放CPU，减少上下文切换，显著提升数据传输的性能和效率。  一、 理解背景：传统I&#x2F;O的痛点要理解零拷贝的价值，我们必须先了解传统的数据传输方式有多么“昂贵”。 假设我们要实现一个简单的文件服务器，其功能是：从磁盘读取一个文件，然后通过网络发送给客户端。 传统I&#x2F;O的操作流程： 我们用代码来看，通常是这样的： 12read(file_fd, buffer, len);write(socket_fd, buffer, len);  这个看似简单的两行代码，在操作系统层面会触发一系列复杂的步骤：  第一次拷贝（DMA Copy）：  应用程序调用 read()...</div></div></div></a><a class="pagination-related" href="/2025/08/16/CPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/" title="CPP学习笔记—lambda表达式"><img class="cover" src="/img/24.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-16</div><div class="info-item-2">CPP学习笔记—lambda表达式</div></div><div class="info-2"><div class="info-item-1">Lambda 表达式是 C++11 引入的一项革命性特性，它极大地改变了 C++ 的编程风格，尤其是在与标准模板库（STL）配合使用时。它允许我们在代码中需要一个函数的地方，直接定义一个匿名的、临时的函数对象。  1. 什么是 Lambda 表达式？简单来说，Lambda 表达式就是一个可调用的代码单元，可以把它理解为一个匿名的内联函数。与普通函数不同，它可以在函数内部定义，并且可以“捕获”其所在作用域中的变量。 2. 为什么需要 Lambda 表达式？在 C++11 之前，如果想向一个算法（如 std::sort）传递一个简单的、一次性的比较逻辑，通常需要：  定义一个全局函数或静态成员函数：这会污染命名空间，并且逻辑与使用它的地方相隔甚远。 定义一个函数对象（Functor）：需要编写一个完整的类，重载 operator()。这非常繁琐。  Lambda 的优势：  代码局部性：将逻辑直接写在使用它的地方，代码更紧凑，可读性更高。 简洁性：避免了编写独立的函数或函数对象类的样板代码。 状态捕获：可以方便地访问和使用其定义作用域内的变量，这是普通函数难以做到的。   3....</div></div></div></a><a class="pagination-related" href="/2025/09/19/CPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94priority-queue/" title="CPP学习笔记—priority_queue"><img class="cover" src="/img/38.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-19</div><div class="info-item-2">CPP学习笔记—priority_queue</div></div><div class="info-2"><div class="info-item-1">1. priority_queue 是什么？std::priority_queue 是 C++ 标准模板库（STL）中的一个容器适配器，它提供了一种特殊的队列：优先级队列。 核心概念：优先出队与普通的队列（std::queue）遵循“先进先出”（FIFO）的原则不同，优先级队列中的元素并非根据其进入队列的顺序出队，而是根据其优先级。每次从队列中取出的元素（通过 top() 访问，pop() 移除），都是当前队列中优先级最高的那个。 默认情况下，对于数字，“大”的元素优先级更高；对于其他类型，使用 std::less 作为比较函数，即通过 operator&lt; 来判断优先级。 底层数据结构：堆 (Heap)priority_queue 的高效实现得益于其底层的堆数据结构。通常是最大堆 (Max-Heap)。  堆：一个特殊的完全二叉树，满足“堆属性”：父节点的值总是大于或等于（最大堆）或小于或等于（最小堆）其所有子节点的值。 最大堆 (Max-Heap)：根节点是整个堆中最大的元素。std::priority_queue 默认就是最大堆。 最小堆...</div></div></div></a><a class="pagination-related" href="/2025/10/22/CPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94std-function%E7%9A%84%E7%94%A8%E6%B3%95/" title="CPP学习笔记—std::function的用法"><img class="cover" src="/img/50.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-22</div><div class="info-item-2">CPP学习笔记—std::function的用法</div></div><div class="info-2"><div class="info-item-1">std::function 是 C++11 中引入的一个极其有用的工具，位于 &lt;functional&gt; 头文件中。它是一个通用的、多态的函数包装器。它的实例可以存储、复制和调用任何可调用 (Callable) 目标——包括普通函数、Lambda 表达式、函数指针、成员函数指针、以及函数对象（functors）。  1. std::function 是什么？一句话定义std::function 是一个类型安全的包装器，它可以持有任何符合其函数签名的可调用对象。 可以把它想象成一个“万能的函数指针”，但它比函数指针强大得多，因为它可以指向任何可调用的东西，而不仅仅是全局函数。 解决的问题：类型不统一的“可调用物”在 C++ 中，有很多东西都可以被“调用”，比如：  普通函数指针: void (*p_func)(int); 函数对象 (Functor): 一个重载了 operator() 的类的对象。每个函数对象都有自己独特的类型。 Lambda 表达式: 编译器会为每个 Lambda 生成一个唯一的、匿名的闭包类型。  在 std::function...</div></div></div></a><a class="pagination-related" href="/2025/10/03/CPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E5%BC%8F/" title="CPP学习笔记—初始化方式"><img class="cover" src="/img/39.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-03</div><div class="info-item-2">CPP学习笔记—初始化方式</div></div><div class="info-2"><div class="info-item-1">C++ 的初始化是一个庞大而精细的主题，从 C 语言的简单赋值风格，到 C++11 引入的统一初始化，其发展历程旨在解决二义性、提高类型安全性和代码一致性。 为什么初始化如此重要？在 C++ 中，一个未经初始化的变量（非静态局部变量）拥有一个不确定的值。读取这个值会导致未定义行为 (Undefined Behavior, UB)，这是 C++ 中最危险的陷阱之一，可能导致程序崩溃、数据损坏或看似正常运行但结果错误。  C++ 初始化方式的演变与分类我们可以大致将初始化方式分为两大类：C++11 之前的传统方式和 C++11 及其之后引入的统一初始化（大括号初始化）。 第一部分：C++11 之前的传统初始化方式在 C++11 之前，主要有以下几种初始化方式，它们的语法不统一，有时会带来困惑。 1. 默认初始化 (Default Initialization)当一个变量在定义时没有提供显式的初始值时，就会发生默认初始化。 语法： 1T object_name;  行为：  对于局部变量（在函数内定义）：如果 T 是内置类型（如 int, double,...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="giscus-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/Cecilia.jpeg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">秋风、萧瑟</div><div class="author-info-description">梦想是用技术创造一个美好的世界</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">50</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">本站于2024年12月25日正式上线,博客内容主要是记录个人学习和技术分享,也欢迎技术交流!!!</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%83%8C%E6%99%AF%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-I-O-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%EF%BC%9F"><span class="toc-text">1. 背景：为什么需要 I&#x2F;O 多路复用？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%9E%8B%E4%B8%80%EF%BC%9A%E9%98%BB%E5%A1%9E-I-O-%E5%A4%9A%E8%BF%9B%E7%A8%8B-%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-text">模型一：阻塞 I&#x2F;O + 多进程&#x2F;多线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%9E%8B%E4%BA%8C%EF%BC%9A%E9%9D%9E%E9%98%BB%E5%A1%9E-I-O-%E5%BF%99%E8%BD%AE%E8%AF%A2-Busy-Polling"><span class="toc-text">模型二：非阻塞 I&#x2F;O + 忙轮询 (Busy-Polling)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3%EF%BC%9A%E5%AE%83%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">2. 核心思想：它到底是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%B8%89%E7%A7%8D%E4%B8%BB%E8%A6%81%E5%AE%9E%E7%8E%B0%EF%BC%9Aselect-poll-epoll"><span class="toc-text">3. 三种主要实现：select, poll, epoll</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#A-select"><span class="toc-text">A. select</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#B-poll"><span class="toc-text">B. poll</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-epoll-Linux-%E7%89%B9%E6%9C%89"><span class="toc-text">C. epoll (Linux 特有)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%AF%A6%E7%BB%86%E5%AF%B9%E6%AF%94%EF%BC%9Aselect-vs-poll-vs-epoll"><span class="toc-text">4. 详细对比：select vs poll vs epoll</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F%EF%BC%9A%E6%B0%B4%E5%B9%B3%E8%A7%A6%E5%8F%91-LT-vs-%E8%BE%B9%E6%B2%BF%E8%A7%A6%E5%8F%91-ET"><span class="toc-text">5. 工作模式：水平触发 (LT) vs 边沿触发 (ET)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#A%E3%80%81-%E6%B0%B4%E5%B9%B3%E8%A7%A6%E5%8F%91-Level-Triggered-LT"><span class="toc-text">A、 水平触发 (Level Triggered, LT)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#B%E3%80%81-%E8%BE%B9%E6%B2%BF%E8%A7%A6%E5%8F%91-Edge-Triggered-ET"><span class="toc-text">B、 边沿触发 (Edge Triggered, ET)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C%E3%80%81-%E6%80%BB%E7%BB%93%E4%B8%8E%E5%AF%B9%E6%AF%94"><span class="toc-text">C、 总结与对比</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E4%BC%98%E7%BC%BA%E7%82%B9%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">6. 优缺点与应用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#I-O-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-text">I&#x2F;O 多路复用的优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#I-O-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-text">I&#x2F;O 多路复用的缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%8F%E5%85%B8%E5%BA%94%E7%94%A8"><span class="toc-text">经典应用</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/10/24/CPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E7%BB%93%E6%9E%84%E5%8C%96%E7%BB%91%E5%AE%9A/" title="CPP学习笔记—结构化绑定"><img src="/img/52.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CPP学习笔记—结构化绑定"/></a><div class="content"><a class="title" href="/2025/10/24/CPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E7%BB%93%E6%9E%84%E5%8C%96%E7%BB%91%E5%AE%9A/" title="CPP学习笔记—结构化绑定">CPP学习笔记—结构化绑定</a><time datetime="2025-10-24T07:52:23.000Z" title="发表于 2025-10-24 15:52:23">2025-10-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/10/22/CPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/" title="CPP学习笔记—策略模式"><img src="/img/51.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CPP学习笔记—策略模式"/></a><div class="content"><a class="title" href="/2025/10/22/CPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/" title="CPP学习笔记—策略模式">CPP学习笔记—策略模式</a><time datetime="2025-10-22T15:37:59.000Z" title="发表于 2025-10-22 23:37:59">2025-10-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/10/22/CPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94std-function%E7%9A%84%E7%94%A8%E6%B3%95/" title="CPP学习笔记—std::function的用法"><img src="/img/50.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CPP学习笔记—std::function的用法"/></a><div class="content"><a class="title" href="/2025/10/22/CPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94std-function%E7%9A%84%E7%94%A8%E6%B3%95/" title="CPP学习笔记—std::function的用法">CPP学习笔记—std::function的用法</a><time datetime="2025-10-22T15:33:26.000Z" title="发表于 2025-10-22 23:33:26">2025-10-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/10/22/CPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%92%8C%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89/" title="CPP学习笔记—右值引用和移动语义"><img src="/img/49.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CPP学习笔记—右值引用和移动语义"/></a><div class="content"><a class="title" href="/2025/10/22/CPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%92%8C%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89/" title="CPP学习笔记—右值引用和移动语义">CPP学习笔记—右值引用和移动语义</a><time datetime="2025-10-22T15:26:41.000Z" title="发表于 2025-10-22 23:26:41">2025-10-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/10/22/CPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E7%8E%B0%E4%BB%A3C-%E7%9A%84%E7%89%B9%E6%80%A7/" title="CPP学习笔记—现代C++的特性"><img src="/img/48.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CPP学习笔记—现代C++的特性"/></a><div class="content"><a class="title" href="/2025/10/22/CPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E7%8E%B0%E4%BB%A3C-%E7%9A%84%E7%89%B9%E6%80%A7/" title="CPP学习笔记—现代C++的特性">CPP学习笔记—现代C++的特性</a><time datetime="2025-10-22T14:43:46.000Z" title="发表于 2025-10-22 22:43:46">2025-10-22</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 - 2025 By 秋风、萧瑟</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'none',
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }
      
      const script = document.createElement('script')
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.isShuoshuo
  const option = null

  const getGiscusTheme = theme => theme === 'dark' ? 'dark' : 'light'

  const createScriptElement = config => {
    const ele = document.createElement('script')
    Object.entries(config).forEach(([key, value]) => {
      ele.setAttribute(key, value)
    })
    return ele
  }

  const loadGiscus = (el = document, key) => {
    const mappingConfig = isShuoshuo
      ? { 'data-mapping': 'specific', 'data-term': key }
      : { 'data-mapping': (option && option['data-mapping']) || 'pathname' }

    const giscusConfig = {
      src: 'https://giscus.app/client.js',
      'data-repo': 'LX-Cel/lx-cel.github.io',
      'data-repo-id': 'R_kgDONd3anw',
      'data-category-id': 'DIC_kwDONd3an84ClwRS',
      'data-theme': getGiscusTheme(document.documentElement.getAttribute('data-theme')),
      'data-reactions-enabled': '1',
      crossorigin: 'anonymous',
      async: true,
      ...option,
      ...mappingConfig
    }

    const scriptElement = createScriptElement(giscusConfig)

    el.querySelector('#giscus-wrap').appendChild(scriptElement)

    if (isShuoshuo) {
      window.shuoshuoComment.destroyGiscus = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }
  }

  const changeGiscusTheme = theme => {
    const iframe = document.querySelector('#giscus-wrap iframe')
    if (iframe) {
      const message = {
        giscus: {
          setConfig: {
            theme: getGiscusTheme(theme)
          }
        }
      }
      iframe.contentWindow.postMessage(message, 'https://giscus.app')
    }
  }

  btf.addGlobalFn('themeChange', changeGiscusTheme, 'giscus')

  if (isShuoshuo) {
    'Giscus' === 'Giscus'
      ? window.shuoshuoComment = { loadComment: loadGiscus }
      : window.loadOtherComment = loadGiscus
    return
  }

  if ('Giscus' === 'Giscus' || !false) {
    if (false) btf.loadComment(document.getElementById('giscus-wrap'), loadGiscus)
    else loadGiscus()
  } else {
    window.loadOtherComment = loadGiscus
  }
})()</script></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="输入要搜索的文章..." type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>