<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>零拷贝 | 星海流光</title><meta name="author" content="秋风、萧瑟"><meta name="copyright" content="秋风、萧瑟"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="摘要：什么是零拷贝？零拷贝（Zero-Copy） 并不是指完全没有数据拷贝，而是指尽可能地减少或避免在应用程序的用户空间（User Space）和操作系统的内核空间（Kernel Space）之间进行不必要的CPU数据拷贝。其核心目标是让数据在从一个I&#x2F;O设备（如硬盘）到另一个I&#x2F;O设备（如网卡）的传输过程中，最大限度地利用硬件（如DMA）来搬运数据，从而解放CPU，减少上下文">
<meta property="og:type" content="article">
<meta property="og:title" content="零拷贝">
<meta property="og:url" content="https://lx-cel.github.io/2025/10/20/%E9%9B%B6%E6%8B%B7%E8%B4%9D/index.html">
<meta property="og:site_name" content="星海流光">
<meta property="og:description" content="摘要：什么是零拷贝？零拷贝（Zero-Copy） 并不是指完全没有数据拷贝，而是指尽可能地减少或避免在应用程序的用户空间（User Space）和操作系统的内核空间（Kernel Space）之间进行不必要的CPU数据拷贝。其核心目标是让数据在从一个I&#x2F;O设备（如硬盘）到另一个I&#x2F;O设备（如网卡）的传输过程中，最大限度地利用硬件（如DMA）来搬运数据，从而解放CPU，减少上下文">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://lx-cel.github.io/img/44.jpg">
<meta property="article:published_time" content="2025-10-20T07:43:55.000Z">
<meta property="article:modified_time" content="2025-10-19T16:00:00.000Z">
<meta property="article:author" content="秋风、萧瑟">
<meta property="article:tag" content="学习笔记">
<meta property="article:tag" content="操作系统">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://lx-cel.github.io/img/44.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://lx-cel.github.io/2025/10/20/%E9%9B%B6%E6%8B%B7%E8%B4%9D/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '零拷贝',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/Cecilia.jpeg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">49</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/44.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">星海流光</span></a><a class="nav-page-title" href="/"><span class="site-name">零拷贝</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">零拷贝</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-10-20T07:43:55.000Z" title="发表于 2025-10-20 15:43:55">2025-10-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-10-19T16:00:00.000Z" title="更新于 2025-10-20 00:00:00">2025-10-20</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h3 id="摘要：什么是零拷贝？"><a href="#摘要：什么是零拷贝？" class="headerlink" title="摘要：什么是零拷贝？"></a><strong>摘要：什么是零拷贝？</strong></h3><p><strong>零拷贝（Zero-Copy）</strong> 并不是指完全没有数据拷贝，而是指<strong>尽可能地减少或避免在应用程序的用户空间（User Space）和操作系统的内核空间（Kernel Space）之间进行不必要的CPU数据拷贝</strong>。其核心目标是让数据在从一个I&#x2F;O设备（如硬盘）到另一个I&#x2F;O设备（如网卡）的传输过程中，最大限度地利用硬件（如DMA）来搬运数据，从而解放CPU，减少上下文切换，显著提升数据传输的性能和效率。</p>
<hr>
<h3 id="一、-理解背景：传统I-O的痛点"><a href="#一、-理解背景：传统I-O的痛点" class="headerlink" title="一、 理解背景：传统I&#x2F;O的痛点"></a><strong>一、 理解背景：传统I&#x2F;O的痛点</strong></h3><p>要理解零拷贝的价值，我们必须先了解传统的数据传输方式有多么“昂贵”。</p>
<p>假设我们要实现一个简单的文件服务器，其功能是：从磁盘读取一个文件，然后通过网络发送给客户端。</p>
<p><strong>传统I&#x2F;O的操作流程：</strong></p>
<p>我们用代码来看，通常是这样的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">read(file_fd, buffer, len);</span><br><span class="line">write(socket_fd, buffer, len);</span><br></pre></td></tr></table></figure>

<p>这个看似简单的两行代码，在操作系统层面会触发一系列复杂的步骤：</p>
<ol>
<li><p><strong>第一次拷贝（DMA Copy）：</strong></p>
<ul>
<li>应用程序调用 <code>read()</code> 系统调用，发起读文件请求。</li>
<li>CPU 发出指令，<strong>上下文从用户态切换到内核态</strong>。</li>
<li>DMA（Direct Memory Access）控制器介入，将磁盘上的文件数据直接拷贝到内核空间的一个缓冲区，我们称之为<strong>内核缓冲区（Page Cache）</strong>。这个过程由DMA完成，不占用CPU。</li>
</ul>
</li>
<li><p><strong>第二次拷贝（CPU Copy）：</strong></p>
<ul>
<li><code>read()</code> 系统调用需要返回数据给应用程序。</li>
<li>CPU 将数据从<strong>内核缓冲区</strong>拷贝到应用程序指定的<strong>用户缓冲区</strong>（<code>buffer</code>）。</li>
<li><code>read()</code> 调用返回，<strong>上下文从内核态切换回用户态</strong>。此时，数据已经到了我们的应用程序内存中。</li>
</ul>
</li>
<li><p><strong>第三次拷贝（CPU Copy）：</strong></p>
<ul>
<li>应用程序调用 <code>write()</code> 系统调用，发起网络发送请求。</li>
<li><strong>上下文再次从用户态切换到内核态</strong>。</li>
<li>CPU 将数据从<strong>用户缓冲区</strong>（<code>buffer</code>）拷贝到与网络套接字（Socket）关联的另一个内核缓冲区，即 <strong>Socket 缓冲区</strong>。</li>
</ul>
</li>
<li><p><strong>第四次拷贝（DMA Copy）：</strong></p>
<ul>
<li>数据已经准备好发送。</li>
<li>DMA 控制器将数据从 <strong>Socket 缓冲区</strong>拷贝到网卡的缓冲区（NIC Buffer）。</li>
<li>网卡将数据打包成网络帧，通过物理链路发送出去。</li>
<li><code>write()</code> 调用返回，<strong>上下文再次从内核态切换回用户态</strong>。</li>
</ul>
</li>
</ol>
<p><img src="/img_1/21.png" alt="传统I&#x2F;O"></p>
<p><strong>传统I&#x2F;O的成本总结：</strong></p>
<ul>
<li><strong>4 次数据拷贝</strong>：2次DMA拷贝 + 2次CPU拷贝。</li>
<li><strong>4 次上下文切换</strong>：2次 <code>read()</code> 切换 + 2次 <code>write()</code> 切换。</li>
</ul>
<p><strong>问题在哪里？</strong></p>
<ul>
<li><strong>CPU拷贝是多余的</strong>：在整个流程中，应用程序（用户空间）只是一个“中转站”。数据从内核缓冲区拷贝到用户缓冲区，又原封不动地拷贝回内核的Socket缓冲区。这个来回拷贝对于“数据传输”这个场景来说，是完全没有必要的，白白浪费了CPU周期和内存带宽。</li>
<li><strong>上下文切换是昂贵的</strong>：每次用户态和内核态之间的切换，都需要保存和恢复大量的寄存器状态、程序计数器等信息，开销很大。</li>
</ul>
<p>零拷贝技术就是为了解决这两个核心问题而生的。</p>
<hr>
<h3 id="二、-零拷贝的实现方式"><a href="#二、-零拷贝的实现方式" class="headerlink" title="二、 零拷贝的实现方式"></a><strong>二、 零拷贝的实现方式</strong></h3><p>零拷贝有多种实现技术，下面我们由浅入深地介绍几种主流的方式。</p>
<h4 id="1-mmap-write-方式"><a href="#1-mmap-write-方式" class="headerlink" title="1. mmap + write 方式"></a><strong>1. mmap + write 方式</strong></h4><p><code>mmap</code>（Memory Map）是一种内存映射技术，它可以将内核缓冲区的一部分直接映射到应用程序的地址空间。这样，应用程序就可以像访问普通内存一样访问这块内核缓冲区，而无需将数据从内核拷贝到用户空间。</p>
<p><strong>操作流程：</strong></p>
<ol>
<li>应用程序调用 <code>mmap()</code> 系统调用。<ul>
<li><strong>上下文切换到内核态</strong>。</li>
<li>DMA 控制器将磁盘数据拷贝到<strong>内核缓冲区（Page Cache）</strong>。</li>
<li><code>mmap()</code> 系统调用将这块内核缓冲区<strong>映射</strong>到用户空间的虚拟地址，此时内核空间和用户空间共享了这块内存。</li>
<li><code>mmap()</code> 返回，<strong>上下文切换回用户态</strong>。</li>
</ul>
</li>
<li>应用程序调用 <code>write()</code> 系统调用。<ul>
<li><strong>上下文再次切换到内核态</strong>。</li>
<li>CPU 将数据从<strong>内核缓冲区</strong>（现在也被用户空间共享）直接拷贝到 <strong>Socket 缓冲区</strong>。</li>
<li>DMA 控制器将数据从 Socket 缓冲区拷贝到网卡。</li>
<li><code>write()</code> 返回，<strong>上下文切换回用户态</strong>。</li>
</ul>
</li>
</ol>
<p><img src="/img_1/22.png" alt="mmap + write 方式"></p>
<p><strong>mmap + write 的改进：</strong></p>
<ul>
<li><strong>数据拷贝减少为 3 次</strong>：1次DMA拷贝 + 1次CPU拷贝 + 1次DMA拷贝。<ul>
<li>我们成功地<strong>消除了一次从内核到用户的CPU拷贝</strong>。</li>
</ul>
</li>
<li><strong>上下文切换仍为 4 次</strong>（<code>mmap</code>两次，<code>write</code>两次）。</li>
</ul>
<p><strong>优点</strong>：减少了一次CPU拷贝。<br><strong>缺点</strong>：<code>mmap</code> 映射的内存如果被其他进程意外修改，可能会导致数据污染。此外，对于小文件，<code>mmap</code> 的开销（建立映射、管理页表）可能比传统的 <code>read</code> 更大。</p>
<h4 id="2-sendfile-方式-Linux"><a href="#2-sendfile-方式-Linux" class="headerlink" title="2. sendfile 方式 (Linux)"></a><strong>2. sendfile 方式 (Linux)</strong></h4><p><code>sendfile</code> 是 Linux 2.1 内核引入的一个专门用于在两个文件描述符之间传输数据的系统调用，它极大地简化了数据传输过程，是零拷贝的经典实现。</p>
<p><code>ssize_t sendfile(int out_fd, int in_fd, off_t *offset, size_t count);</code></p>
<ul>
<li><code>out_fd</code>: 目标文件描述符（如 socket）。</li>
<li><code>in_fd</code>: 源文件描述符（如文件）。</li>
</ul>
<p><strong>操作流程（基础版）：</strong></p>
<ol>
<li>应用程序调用 <code>sendfile()</code> 系统调用。<ul>
<li><strong>上下文切换到内核态</strong>。</li>
<li>DMA 控制器将磁盘数据拷贝到<strong>内核缓冲区（Page Cache）</strong>。</li>
<li>CPU 将数据从<strong>内核缓冲区</strong>直接拷贝到 <strong>Socket 缓冲区</strong>。</li>
<li>DMA 控制器将数据从 Socket 缓冲区拷贝到网卡。</li>
<li><code>sendfile()</code> 返回，<strong>上下文切换回用户态</strong>。</li>
</ul>
</li>
</ol>
<p><img src="/img_1/23.png" alt="sendfile 方式"></p>
<p><strong>sendfile 的改进：</strong></p>
<ul>
<li><strong>数据拷贝减少为 3 次</strong>：1次DMA拷贝 + 1次CPU拷贝 + 1次DMA拷贝。</li>
<li><strong>上下文切换减少为 2 次</strong>：一次系统调用就完成了所有操作。</li>
</ul>
<p>相比 <code>mmap</code>，<code>sendfile</code> 进一步减少了上下文切换次数，性能更好。</p>
<h4 id="3-sendfile-DMA-Scatter-Gather-真正的零拷贝"><a href="#3-sendfile-DMA-Scatter-Gather-真正的零拷贝" class="headerlink" title="3. sendfile + DMA Scatter&#x2F;Gather (真正的零拷贝)"></a><strong>3. sendfile + DMA Scatter&#x2F;Gather (真正的零拷贝)</strong></h4><p>从 Linux 2.4 内核开始，<code>sendfile</code> 得到了进一步增强，如果网卡硬件支持 <strong>Scatter-Gather I&#x2F;O</strong>（分散-聚集 I&#x2F;O）功能，那么连内核内部的CPU拷贝都可以省掉。</p>
<p><strong>Scatter-Gather I&#x2F;O 是什么？</strong><br>它是一种 DMA 技术，允许 DMA 控制器从多个不连续的内存缓冲区中读取数据（Scatter），然后将它们组装成一个连续的数据流写入到目标设备（Gather）。</p>
<p><strong>操作流程（增强版）：</strong></p>
<ol>
<li>应用程序调用 <code>sendfile()</code> 系统调用。<ul>
<li><strong>上下文切换到内核态</strong>。</li>
<li>DMA 控制器将磁盘数据拷贝到<strong>内核缓冲区（Page Cache）</strong>。</li>
</ul>
</li>
<li><strong>关键步骤</strong>：CPU 不再拷贝数据到 Socket 缓冲区。取而代之的是，CPU 将一个<strong>描述符（Descriptor）</strong> 追加到 Socket 缓冲区。这个描述符包含了两个信息：<ul>
<li>数据在内核缓冲区中的<strong>内存地址</strong>。</li>
<li>数据的<strong>长度</strong>。</li>
</ul>
</li>
<li>DMA 控制器根据 Socket 缓冲区中的描述符，直接从<strong>内核缓冲区</strong>将数据拷贝到网卡。这个过程被称为 <strong>DMA Gather Copy</strong>。</li>
<li><code>sendfile()</code> 返回，<strong>上下文切换回用户态</strong>。</li>
</ol>
<p><img src="/img_1/24.png" alt="sendfile + DMA Scatter&#x2F;Gather"></p>
<p><strong>终极改进：</strong></p>
<ul>
<li><strong>数据拷贝减少为 2 次</strong>：全部是 DMA 拷贝，<strong>CPU 拷贝次数为 0</strong>！这才是“零拷贝”这个名字最贴切的诠释。</li>
<li><strong>上下文切换为 2 次</strong>。</li>
</ul>
<p>这是目前在Linux上实现文件到网络传输最高效的方式。</p>
<hr>
<h3 id="三、-零拷贝的应用场景"><a href="#三、-零拷贝的应用场景" class="headerlink" title="三、 零拷贝的应用场景"></a><strong>三、 零拷贝的应用场景</strong></h3><p>零拷贝技术被广泛应用于需要高性能数据传输的场景，特别是那些数据内容本身不需要被应用程序处理的场景。</p>
<ul>
<li><strong>Web 服务器</strong>：像 Nginx、Apache 等，在处理静态文件请求（如图片、HTML、CSS文件）时，会大量使用 <code>sendfile</code> 来提高性能。</li>
<li><strong>消息中间件</strong>：像 Kafka、RocketMQ 等，它们在从磁盘读取消息数据并发送给消费者时，也严重依赖零拷贝技术来达到极高的吞吐量。Kafka 的高性能传说很大程度上就归功于对 <code>sendfile</code> 的极致运用。</li>
<li><strong>文件服务器</strong>：如 FTP、Samba 服务器。</li>
<li><strong>数据库</strong>：某些数据库在进行数据备份或网络同步时也会使用。</li>
</ul>
<hr>
<h3 id="四、-总结：零拷贝的优势与局限"><a href="#四、-总结：零拷贝的优势与局限" class="headerlink" title="四、 总结：零拷贝的优势与局限"></a><strong>四、 总结：零拷贝的优势与局限</strong></h3><p><strong>优势：</strong></p>
<ol>
<li><strong>减少CPU开销</strong>：避免了用户空间和内核空间之间多余的CPU数据拷贝。</li>
<li><strong>减少上下文切换</strong>：使用 <code>sendfile</code> 等系统调用可以将多次I&#x2F;O操作合并为一次，减少了内核态和用户态之间的切换次数。</li>
<li><strong>提升性能</strong>：CPU被解放出来去处理其他任务，系统的整体吞吐量得到显著提升。</li>
<li><strong>避免内存带宽瓶颈</strong>：减少了对内存总线的占用。</li>
</ol>
<p><strong>局限性：</strong></p>
<ol>
<li><strong>数据无法修改</strong>：因为数据没有被拷贝到用户空间，所以应用程序在数据传输过程中无法对其进行修改（如加密、压缩）。如果需要修改数据，就必须走传统I&#x2F;O的路径。</li>
<li><strong>依赖操作系统和硬件支持</strong>：最高效的零拷贝（如 <code>sendfile</code> + DMA Gather）需要操作系统内核和网卡硬件的同时支持。</li>
<li><strong>适用场景有限</strong>：主要适用于数据“原封不动”的转发场景。</li>
</ol>
<hr>
<h3 id="零拷贝方案对比"><a href="#零拷贝方案对比" class="headerlink" title="零拷贝方案对比"></a><strong>零拷贝方案对比</strong></h3><table>
<thead>
<tr>
<th align="left">技术方案</th>
<th align="center">CPU 拷贝次数</th>
<th align="center">DMA 拷贝次数</th>
<th align="center">上下文切换次数</th>
<th align="left">核心思想</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>传统 I&#x2F;O</strong></td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">4</td>
<td align="left">简单直接，但效率低下</td>
</tr>
<tr>
<td align="left"><strong>mmap + write</strong></td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">4</td>
<td align="left">共享内核与用户空间内存，减少一次CPU拷贝</td>
</tr>
<tr>
<td align="left"><strong>sendfile</strong></td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="left">合并系统调用，减少上下文切换</td>
</tr>
<tr>
<td align="left"><strong>sendfile + SG-DMA</strong></td>
<td align="center"><strong>0</strong></td>
<td align="center">2</td>
<td align="center">2</td>
<td align="left">利用硬件特性，彻底消除CPU拷贝</td>
</tr>
</tbody></table>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>[1] <a target="_blank" rel="noopener" href="https://xiaolincoding.com/os/8_network_system/zero_copy.html">什么是零拷贝？</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://lx-cel.github.io">秋风、萧瑟</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://lx-cel.github.io/2025/10/20/%E9%9B%B6%E6%8B%B7%E8%B4%9D/">https://lx-cel.github.io/2025/10/20/零拷贝/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://lx-cel.github.io" target="_blank">星海流光</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a><a class="post-meta__tags" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></div><div class="post-share"><div class="social-share" data-image="/img/44.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/10/20/I-O%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/" title="I/O多路复用"><img class="cover" src="/img/45.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">I/O多路复用</div></div><div class="info-2"><div class="info-item-1">I&#x2F;O 多路复用（I&#x2F;O Multiplexing）是一种在计算机网络编程中至关重要的技术，也是构建高性能服务器的基石。  1. 背景：为什么需要 I&#x2F;O 多路复用？想象一下你要开发一个网络服务器，需要同时处理多个客户端的连接。我们来看看几种最原始的模型以及它们的缺陷。 模型一：阻塞 I&#x2F;O + 多进程&#x2F;多线程这是最直观的模型。主进程负责监听（listen）新的连接请求。每当有一个新的客户端连接进来（accept），服务器就创建一个新的进程或线程专门为这个客户端服务。  工作流程：  主线程&#x2F;进程 accept() 等待新连接，阻塞。 新连接到达，accept() 返回一个新的socket文件描述符（fd）。 创建一个子线程&#x2F;进程，将这个新的fd交给它处理。 子线程&#x2F;进程在这个fd上调用 read()&#x2F;recv()，等待客户端发送数据，阻塞。 数据到达，read() 返回，处理数据，然后可能调用...</div></div></div></a><a class="pagination-related" href="/2025/10/17/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8E%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/" title="正则表达式与模式匹配"><img class="cover" src="/img/43.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">正则表达式与模式匹配</div></div><div class="info-2"><div class="info-item-1">第一部分：正则表达式（Regular Expression）详解1. 什么是正则表达式？正则表达式是一种描述字符模式的对象。可以把它想象成一种极其强大的“查找和替换”工具，它不是用固定的字符（如 “abc”）去查找，而是用一种描述性的语言（如 “查找三个数字”）去匹配一系列符合某个句法规则的字符串。 它的核心用途包括：  数据验证：检查输入的数据是否符合某种格式（如邮箱、手机号、身份证号）。 文本搜索与定位：在大量文本中快速找到符合特定模式的内容。 文本提取：从一段文本中抽取出需要的信息（如网页爬虫中提取标题和链接）。 文本替换：将符合模式的文本替换成其他内容。  2. 核心组成元素（元字符 Metacharacters）正则表达式的威力来自于它的特殊字符——元字符。普通字符（如 a, b, 1, 2）在正则中就是匹配它们自身，而元字符则有特殊的含义。 2.1 基础字符与预定义字符集   元字符 描述 示例    . 匹配除换行符 \n 之外的任意单个字符 a.c 匹配 “abc”, “a_c”, “a2c”   \d 匹配任意一个数字（等价于...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/10/20/I-O%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/" title="I&#x2F;O多路复用"><img class="cover" src="/img/45.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-20</div><div class="info-item-2">I&#x2F;O多路复用</div></div><div class="info-2"><div class="info-item-1">I&#x2F;O 多路复用（I&#x2F;O Multiplexing）是一种在计算机网络编程中至关重要的技术，也是构建高性能服务器的基石。  1. 背景：为什么需要 I&#x2F;O 多路复用？想象一下你要开发一个网络服务器，需要同时处理多个客户端的连接。我们来看看几种最原始的模型以及它们的缺陷。 模型一：阻塞 I&#x2F;O + 多进程&#x2F;多线程这是最直观的模型。主进程负责监听（listen）新的连接请求。每当有一个新的客户端连接进来（accept），服务器就创建一个新的进程或线程专门为这个客户端服务。  工作流程：  主线程&#x2F;进程 accept() 等待新连接，阻塞。 新连接到达，accept() 返回一个新的socket文件描述符（fd）。 创建一个子线程&#x2F;进程，将这个新的fd交给它处理。 子线程&#x2F;进程在这个fd上调用 read()&#x2F;recv()，等待客户端发送数据，阻塞。 数据到达，read() 返回，处理数据，然后可能调用...</div></div></div></a><a class="pagination-related" href="/2025/10/20/Linux%E5%91%BD%E4%BB%A4/" title="Linux命令"><img class="cover" src="/img/46.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-20</div><div class="info-item-2">Linux命令</div></div><div class="info-2"><div class="info-item-1">第一部分：Linux 命令行的基石在开始学习具体命令之前，理解几个核心概念至关重要。 1. 什么是 Shell？你输入的命令并不是由 Linux 内核直接处理的。你是在和一个叫做 Shell 的程序交互。Shell 是一个命令解释器，它接收你输入的命令，解释它们，然后请求操作系统（Linux 内核）来执行。  常见的 Shell： bash (Bourne Again SHell)：绝大多数 Linux 发行版的默认 Shell。 zsh (Z Shell)：功能更强大，配置更灵活，是很多开发者的最爱。 fish (Friendly Interactive SHell)：开箱即用，有很好的自动补全和语法高亮功能。    本介绍将以最常见的 bash 为例。 2. 命令的基本结构一个典型的 Linux 命令遵循以下结构： 1command [options] [arguments]   command (命令)：你要执行的程序的名称，例如 ls, cp, mkdir。 options (选项&#x2F;标志)：用来修改命令的行为。通常以一个或两个破折号 (- 或 --)...</div></div></div></a><a class="pagination-related" href="/2024/12/25/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01%E2%80%94%E5%88%97%E8%A1%A8%E7%9A%84%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/" title="Python学习笔记1—列表的简单操作"><img class="cover" src="/img/03.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-25</div><div class="info-item-2">Python学习笔记1—列表的简单操作</div></div><div class="info-2"><div class="info-item-1">1. 列表的定义在Pyhton中，用[]来表示列表。并用逗号来分隔其中的元素，在下方是一个简单的列表示例，这个列表包含几种自行车： 12bicycles = [&#x27;trek&#x27;, &#x27;cannondale&#x27;, &#x27;redline&#x27;, &#x27;specialized&#x27;]print(bicycles) 下方为打印结果： 1[&#x27;trek&#x27;, &#x27;cannondale&#x27;, &#x27;redline&#x27;, &#x27;specialized&#x27;] 2. 访问列表元素在Python中，可以通过索引来访问列表元素，如： 12bicycles = [&#x27;trek&#x27;, &#x27;cannondale&#x27;, &#x27;redline&#x27;,...</div></div></div></a><a class="pagination-related" href="/2024/12/26/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02%E2%80%94%E5%88%97%E8%A1%A8%E7%9A%84%E8%BF%9B%E9%98%B6%E6%93%8D%E4%BD%9C/" title="Python学习笔记2—列表的进阶操作"><img class="cover" src="/img/06.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-26</div><div class="info-item-2">Python学习笔记2—列表的进阶操作</div></div><div class="info-2"><div class="info-item-1">1. 使用for循环进行列表遍历假设我们有一个魔术师名单，需要将其中每个魔术师的名字都打印出来，则可以用for 循环进行遍历并打印，如： 123magicians = [&#x27;alice&#x27;, &#x27;david&#x27;, &#x27;carolina&#x27;]for magician in magicians:    print(magician) 这段代码从列表magicians中取出一个名字，并将其存储在变量magician中，进而将其打印，其输出结果如下： 123alice david carolina 2. 创建数值列表2.1 使用函数range()使用函数range()可以生成一些数字，如： 12for value in range(1,5):     print(value) 则打印的结果为： 12341 2 3 4 需要注意的是，range(1,5)只是打印数字1-4，并且range(1,5)并不会生成一个包含数字1-4的列表。 2.2...</div></div></div></a><a class="pagination-related" href="/2024/12/26/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03%E2%80%94%E5%85%83%E7%BB%84/" title="Python学习笔记3—元组"><img class="cover" src="/img/07.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-26</div><div class="info-item-2">Python学习笔记3—元组</div></div><div class="info-2"><div class="info-item-1">1. 元组的创建在Python中元组的定义和用法与列表相似，列表用方括号[]表示，而元组用圆括号()表示，与列表不同的是元组中的元素不可修改，除此之外，Python的列表长度是可变的，而元组长度不可变，元组的定义如下所示： 123dimensions = (200, 50)print(dimensions[0])print(dimensions[1]) 在上面的代码中，先定义了元组dimensions，然后输出索引为0和1的两个元素，其输出结果为： 1220050 如果尝试修改该元组中某个元素的值，则会导致Python报错，如： 12dimensions = (200, 50) dimensions[0] = 250 此时会返回如下错误： 1234Traceback (most recent call last):  File &quot;&lt;pyshell#1&gt;&quot;, line 1, in &lt;module&gt;    dimensions[0] = 250TypeError: &#x27;tuple&#x27; object does not...</div></div></div></a><a class="pagination-related" href="/2024/12/26/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B05%E2%80%94%E5%87%BD%E6%95%B0/" title="Python学习笔记5—函数"><img class="cover" src="/img/09.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-26</div><div class="info-item-2">Python学习笔记5—函数</div></div><div class="info-2"><div class="info-item-1">1. 函数的定义在Python中，函数可按下面这种方式定义： 12345def greet_user(username):     &quot;&quot;&quot; 显示简单的问候语 &quot;&quot;&quot;     print(&quot;Hello, &quot; + username.title() + &quot;!&quot;)  greet_user(&#x27;jesse&#x27;) 上面这段代码演示了最简单的函数结构，第一行代码使用关键字def来定义一个函数，def后面的greet_user(username)为函数名，username叫做函数的形参，而’jesse’叫做实参。紧跟在def greet_user(username):后面的所有缩进行构成了函数体。””” 显示简单的问候语 “””叫做文档字符串，描述的函数是做什么的，文档字符串用三引号括起，Python使用它们来生成有关程序中函数的文档。要使用这个函数，可调用它，依次指定函数名以及要传入括号中的参数。上面这段代码的输出为： 1Hello, Jesse! 2....</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="giscus-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/Cecilia.jpeg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">秋风、萧瑟</div><div class="author-info-description">梦想是用技术创造一个美好的世界</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">49</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">本站于2024年12月25日正式上线,博客内容主要是记录个人学习和技术分享,也欢迎技术交流!!!</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%91%98%E8%A6%81%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AF%E9%9B%B6%E6%8B%B7%E8%B4%9D%EF%BC%9F"><span class="toc-text">摘要：什么是零拷贝？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81-%E7%90%86%E8%A7%A3%E8%83%8C%E6%99%AF%EF%BC%9A%E4%BC%A0%E7%BB%9FI-O%E7%9A%84%E7%97%9B%E7%82%B9"><span class="toc-text">一、 理解背景：传统I&#x2F;O的痛点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81-%E9%9B%B6%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-text">二、 零拷贝的实现方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-mmap-write-%E6%96%B9%E5%BC%8F"><span class="toc-text">1. mmap + write 方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-sendfile-%E6%96%B9%E5%BC%8F-Linux"><span class="toc-text">2. sendfile 方式 (Linux)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-sendfile-DMA-Scatter-Gather-%E7%9C%9F%E6%AD%A3%E7%9A%84%E9%9B%B6%E6%8B%B7%E8%B4%9D"><span class="toc-text">3. sendfile + DMA Scatter&#x2F;Gather (真正的零拷贝)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81-%E9%9B%B6%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">三、 零拷贝的应用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81-%E6%80%BB%E7%BB%93%EF%BC%9A%E9%9B%B6%E6%8B%B7%E8%B4%9D%E7%9A%84%E4%BC%98%E5%8A%BF%E4%B8%8E%E5%B1%80%E9%99%90"><span class="toc-text">四、 总结：零拷贝的优势与局限</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%B6%E6%8B%B7%E8%B4%9D%E6%96%B9%E6%A1%88%E5%AF%B9%E6%AF%94"><span class="toc-text">零拷贝方案对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-text">参考</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/10/22/CPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/" title="CPP学习笔记—策略模式"><img src="/img/51.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CPP学习笔记—策略模式"/></a><div class="content"><a class="title" href="/2025/10/22/CPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/" title="CPP学习笔记—策略模式">CPP学习笔记—策略模式</a><time datetime="2025-10-22T15:37:59.000Z" title="发表于 2025-10-22 23:37:59">2025-10-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/10/22/CPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94std-function%E7%9A%84%E7%94%A8%E6%B3%95/" title="CPP学习笔记—std::function的用法"><img src="/img/50.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CPP学习笔记—std::function的用法"/></a><div class="content"><a class="title" href="/2025/10/22/CPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94std-function%E7%9A%84%E7%94%A8%E6%B3%95/" title="CPP学习笔记—std::function的用法">CPP学习笔记—std::function的用法</a><time datetime="2025-10-22T15:33:26.000Z" title="发表于 2025-10-22 23:33:26">2025-10-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/10/22/CPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%92%8C%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89/" title="CPP学习笔记—右值引用和移动语义"><img src="/img/49.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CPP学习笔记—右值引用和移动语义"/></a><div class="content"><a class="title" href="/2025/10/22/CPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%92%8C%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89/" title="CPP学习笔记—右值引用和移动语义">CPP学习笔记—右值引用和移动语义</a><time datetime="2025-10-22T15:26:41.000Z" title="发表于 2025-10-22 23:26:41">2025-10-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/10/22/CPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E7%8E%B0%E4%BB%A3C-%E7%9A%84%E7%89%B9%E6%80%A7/" title="CPP学习笔记—现代C++的特性"><img src="/img/48.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CPP学习笔记—现代C++的特性"/></a><div class="content"><a class="title" href="/2025/10/22/CPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E7%8E%B0%E4%BB%A3C-%E7%9A%84%E7%89%B9%E6%80%A7/" title="CPP学习笔记—现代C++的特性">CPP学习笔记—现代C++的特性</a><time datetime="2025-10-22T14:43:46.000Z" title="发表于 2025-10-22 22:43:46">2025-10-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/10/22/CPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E6%A8%A1%E6%9D%BF/" title="CPP学习笔记—模板"><img src="/img/47.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CPP学习笔记—模板"/></a><div class="content"><a class="title" href="/2025/10/22/CPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E6%A8%A1%E6%9D%BF/" title="CPP学习笔记—模板">CPP学习笔记—模板</a><time datetime="2025-10-22T14:31:08.000Z" title="发表于 2025-10-22 22:31:08">2025-10-22</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 - 2025 By 秋风、萧瑟</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'none',
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }
      
      const script = document.createElement('script')
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.isShuoshuo
  const option = null

  const getGiscusTheme = theme => theme === 'dark' ? 'dark' : 'light'

  const createScriptElement = config => {
    const ele = document.createElement('script')
    Object.entries(config).forEach(([key, value]) => {
      ele.setAttribute(key, value)
    })
    return ele
  }

  const loadGiscus = (el = document, key) => {
    const mappingConfig = isShuoshuo
      ? { 'data-mapping': 'specific', 'data-term': key }
      : { 'data-mapping': (option && option['data-mapping']) || 'pathname' }

    const giscusConfig = {
      src: 'https://giscus.app/client.js',
      'data-repo': 'LX-Cel/lx-cel.github.io',
      'data-repo-id': 'R_kgDONd3anw',
      'data-category-id': 'DIC_kwDONd3an84ClwRS',
      'data-theme': getGiscusTheme(document.documentElement.getAttribute('data-theme')),
      'data-reactions-enabled': '1',
      crossorigin: 'anonymous',
      async: true,
      ...option,
      ...mappingConfig
    }

    const scriptElement = createScriptElement(giscusConfig)

    el.querySelector('#giscus-wrap').appendChild(scriptElement)

    if (isShuoshuo) {
      window.shuoshuoComment.destroyGiscus = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }
  }

  const changeGiscusTheme = theme => {
    const iframe = document.querySelector('#giscus-wrap iframe')
    if (iframe) {
      const message = {
        giscus: {
          setConfig: {
            theme: getGiscusTheme(theme)
          }
        }
      }
      iframe.contentWindow.postMessage(message, 'https://giscus.app')
    }
  }

  btf.addGlobalFn('themeChange', changeGiscusTheme, 'giscus')

  if (isShuoshuo) {
    'Giscus' === 'Giscus'
      ? window.shuoshuoComment = { loadComment: loadGiscus }
      : window.loadOtherComment = loadGiscus
    return
  }

  if ('Giscus' === 'Giscus' || !false) {
    if (false) btf.loadComment(document.getElementById('giscus-wrap'), loadGiscus)
    else loadGiscus()
  } else {
    window.loadOtherComment = loadGiscus
  }
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>