<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>基本排序算法 | 星海流光</title><meta name="author" content="秋风、萧瑟"><meta name="copyright" content="秋风、萧瑟"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="一、冒泡排序1. 什么是冒泡排序？冒泡排序（Bubble Sort）是一种简单直观的排序算法。它得名于其工作方式，即较小（或较大）的元素会像水中的气泡一样，通过不断交换，慢慢“浮”到数列的顶端。 a. 核心思想它重复地遍历待排序的数列，一次比较两个相邻的元素，如果它们的顺序（如从大到小或从小到大）错误就把它们交换过来。遍历数列的工作会重复地进行，直到没有再需要交换的元素为止，这意味着整个数列已经排">
<meta property="og:type" content="article">
<meta property="og:title" content="基本排序算法">
<meta property="og:url" content="https://lx-cel.github.io/2025/08/22/%E5%9F%BA%E6%9C%AC%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/index.html">
<meta property="og:site_name" content="星海流光">
<meta property="og:description" content="一、冒泡排序1. 什么是冒泡排序？冒泡排序（Bubble Sort）是一种简单直观的排序算法。它得名于其工作方式，即较小（或较大）的元素会像水中的气泡一样，通过不断交换，慢慢“浮”到数列的顶端。 a. 核心思想它重复地遍历待排序的数列，一次比较两个相邻的元素，如果它们的顺序（如从大到小或从小到大）错误就把它们交换过来。遍历数列的工作会重复地进行，直到没有再需要交换的元素为止，这意味着整个数列已经排">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://lx-cel.github.io/img/29.jpg">
<meta property="article:published_time" content="2025-08-22T06:52:19.000Z">
<meta property="article:modified_time" content="2025-08-21T16:00:00.000Z">
<meta property="article:author" content="秋风、萧瑟">
<meta property="article:tag" content="学习笔记">
<meta property="article:tag" content="数据结构与算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://lx-cel.github.io/img/29.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://lx-cel.github.io/2025/08/22/%E5%9F%BA%E6%9C%AC%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '基本排序算法',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><meta name="generator" content="Hexo 8.1.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/Cecilia.jpeg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">50</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/29.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">星海流光</span></a><a class="nav-page-title" href="/"><span class="site-name">基本排序算法</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">基本排序算法</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-08-22T06:52:19.000Z" title="发表于 2025-08-22 14:52:19">2025-08-22</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-08-21T16:00:00.000Z" title="更新于 2025-08-22 00:00:00">2025-08-22</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">14.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>50分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h2 id="一、冒泡排序"><a href="#一、冒泡排序" class="headerlink" title="一、冒泡排序"></a>一、冒泡排序</h2><h3 id="1-什么是冒泡排序？"><a href="#1-什么是冒泡排序？" class="headerlink" title="1. 什么是冒泡排序？"></a>1. 什么是冒泡排序？</h3><p>冒泡排序（Bubble Sort）是一种简单直观的排序算法。它得名于其工作方式，即较小（或较大）的元素会像水中的气泡一样，通过不断交换，慢慢“浮”到数列的顶端。</p>
<h4 id="a-核心思想"><a href="#a-核心思想" class="headerlink" title="a. 核心思想"></a>a. 核心思想</h4><p>它重复地遍历待排序的数列，一次比较两个相邻的元素，如果它们的顺序（如从大到小或从小到大）错误就把它们交换过来。遍历数列的工作会重复地进行，直到没有再需要交换的元素为止，这意味着整个数列已经排序完成。</p>
<h4 id="b-工作原理"><a href="#b-工作原理" class="headerlink" title="b. 工作原理"></a>b. 工作原理</h4><ol>
<li><strong>比较相邻元素</strong>：从列表的第一个元素开始，比较它和下一个元素。</li>
<li><strong>交换</strong>：如果第一个元素比第二个元素大（以升序为例），就交换它们的位置。</li>
<li><strong>向后移动</strong>：继续比较下一对相邻的元素（即新的第二个和第三个元素），重复步骤2。</li>
<li><strong>完成一轮</strong>：持续这个过程，直到列表的末尾。经过第一轮遍历后，最大的元素会被放置在列表的最后一个位置。</li>
<li><strong>重复</strong>：对除了最后一个元素之外的所有元素，重复以上步骤。每一轮遍历都会将当前未排序部分的最大元素放到其最终位置。</li>
<li><strong>终止</strong>：当某一轮遍历中没有发生任何交换时，说明列表已经完全排序，可以提前终止算法。</li>
</ol>
<h3 id="2-图解示例"><a href="#2-图解示例" class="headerlink" title="2. 图解示例"></a>2. 图解示例</h3><p>让我们用一个简单的例子 <code>[5, 1, 4, 2, 8]</code> 来演示冒泡排序的过程（升序排列）。</p>
<p><strong>第一轮 (Pass 1):</strong></p>
<ul>
<li><code>(5, 1)</code>: 5 &gt; 1，交换 -&gt; <code>[1, 5, 4, 2, 8]</code></li>
<li><code>(5, 4)</code>: 5 &gt; 4，交换 -&gt; <code>[1, 4, 5, 2, 8]</code></li>
<li><code>(5, 2)</code>: 5 &gt; 2，交换 -&gt; <code>[1, 4, 2, 5, 8]</code></li>
<li><code>(5, 8)</code>: 5 &lt; 8，不交换 -&gt; <code>[1, 4, 2, 5, 8]</code></li>
<li><strong>结果</strong>: 经过第一轮，最大的元素 <code>8</code> 已经“冒泡”到了正确的位置。</li>
</ul>
<p><strong>第二轮 (Pass 2):</strong> (现在只需要处理前4个元素)</p>
<ul>
<li><code>(1, 4)</code>: 1 &lt; 4，不交换 -&gt; <code>[1, 4, 2, 5, 8]</code></li>
<li><code>(4, 2)</code>: 4 &gt; 2，交换 -&gt; <code>[1, 2, 4, 5, 8]</code></li>
<li><code>(4, 5)</code>: 4 &lt; 5，不交换 -&gt; <code>[1, 2, 4, 5, 8]</code></li>
<li><strong>结果</strong>: 第二大的元素 <code>5</code> 已经就位。</li>
</ul>
<p><strong>第三轮 (Pass 3):</strong> (现在只需要处理前3个元素)</p>
<ul>
<li><code>(1, 2)</code>: 1 &lt; 2，不交换 -&gt; <code>[1, 2, 4, 5, 8]</code></li>
<li><code>(2, 4)</code>: 2 &lt; 4，不交换 -&gt; <code>[1, 2, 4, 5, 8]</code></li>
<li><strong>结果</strong>: 此时，我们发现这一轮没有发生任何交换。这意味着列表已经排好序了，可以提前结束。</li>
</ul>
<p>最终排序结果: <code>[1, 2, 4, 5, 8]</code></p>
<h3 id="3-Python-代码实现"><a href="#3-Python-代码实现" class="headerlink" title="3. Python 代码实现"></a>3. Python 代码实现</h3><p>下面提供了两种 Python 实现：一个基础版本和一个优化版本。</p>
<h4 id="a-基础版冒泡排序"><a href="#a-基础版冒泡排序" class="headerlink" title="a. 基础版冒泡排序"></a>a. 基础版冒泡排序</h4><p>这个版本直接翻译了冒泡排序的基本思想，即使列表已经排好序，它也会完成所有的循环。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bubble_sort_basic</span>(<span class="params">arr</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    基础版冒泡排序</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    n = <span class="built_in">len</span>(arr)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 外层循环决定了需要进行多少轮“冒泡”</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="comment"># 内层循环负责每一轮的比较和交换</span></span><br><span class="line">        <span class="comment"># -i 是因为每轮过后，末尾的 i 个元素已经是有序的了，无需再比较</span></span><br><span class="line">        <span class="comment"># -1 是因为我们要比较 arr[j] 和 arr[j+1]，防止索引越界</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, n - i - <span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 如果前一个元素大于后一个元素（升序排列），则交换</span></span><br><span class="line">            <span class="keyword">if</span> arr[j] &gt; arr[j + <span class="number">1</span>]:</span><br><span class="line">                arr[j], arr[j + <span class="number">1</span>] = arr[j + <span class="number">1</span>], arr[j] <span class="comment"># Pythonic 的交换方式</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 示例 ---</span></span><br><span class="line">my_list = [<span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">8</span>]</span><br><span class="line">bubble_sort_basic(my_list)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;基础版排序后的列表:&quot;</span>, my_list)  <span class="comment"># 输出: [1, 2, 4, 5, 8]</span></span><br><span class="line"></span><br><span class="line">another_list = [<span class="number">64</span>, <span class="number">34</span>, <span class="number">25</span>, <span class="number">12</span>, <span class="number">22</span>, <span class="number">11</span>, <span class="number">90</span>]</span><br><span class="line">bubble_sort_basic(another_list)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;基础版排序后的列表:&quot;</span>, another_list) <span class="comment"># 输出: [11, 12, 22, 25, 34, 64, 90]</span></span><br></pre></td></tr></table></figure>

<h4 id="b-优化版冒泡排序"><a href="#b-优化版冒泡排序" class="headerlink" title="b. 优化版冒泡排序"></a>b. 优化版冒泡排序</h4><p>如果在某一轮遍历中，一次交换都没有发生，这说明整个列表已经是有序的了。我们可以利用这一点来提前结束排序，从而提高效率。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bubble_sort_optimized</span>(<span class="params">arr</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    优化版冒泡排序</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    n = <span class="built_in">len</span>(arr)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 外层循环</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="comment"># 设置一个标志位，用于检查本轮是否发生了交换</span></span><br><span class="line">        swapped = <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 内层循环</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, n - i - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> arr[j] &gt; arr[j + <span class="number">1</span>]:</span><br><span class="line">                arr[j], arr[j + <span class="number">1</span>] = arr[j + <span class="number">1</span>], arr[j]</span><br><span class="line">                <span class="comment"># 只要发生了一次交换，就将标志位设为 True</span></span><br><span class="line">                swapped = <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 如果在一整轮的比较中都没有发生交换，说明列表已经有序</span></span><br><span class="line">        <span class="comment"># 此时可以提前退出循环</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> swapped:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 示例 ---</span></span><br><span class="line">my_list_opt = [<span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">8</span>]</span><br><span class="line">bubble_sort_optimized(my_list_opt)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;优化版排序后的列表:&quot;</span>, my_list_opt)  <span class="comment"># 输出: [1, 2, 4, 5, 8]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对于一个几乎有序的列表，优化效果会很明显</span></span><br><span class="line">nearly_sorted_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">bubble_sort_optimized(nearly_sorted_list)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;优化版排序后的列表:&quot;</span>, nearly_sorted_list) <span class="comment"># 输出: [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure>

<h3 id="4-算法分析"><a href="#4-算法分析" class="headerlink" title="4. 算法分析"></a>4. 算法分析</h3><ul>
<li><p><strong>时间复杂度</strong>:</p>
<ul>
<li><strong>最坏情况</strong>: <code>O(n²)</code>。当待排序列表是完全逆序时，需要进行 n*(n-1)&#x2F;2 次比较和交换。</li>
<li><strong>平均情况</strong>: <code>O(n²)</code>。</li>
<li><strong>最好情况</strong>: <code>O(n)</code>。当列表已经是有序的时，对于优化版的冒泡排序，只需要进行一轮遍历（n-1次比较）而没有任何交换，即可确定列表已有序并终止。</li>
</ul>
</li>
<li><p><strong>空间复杂度</strong>: <code>O(1)</code>。冒泡排序是<strong>原地排序</strong>算法，因为它只需要一个额外的临时变量来进行元素交换，所需空间是常数级别的。</p>
</li>
<li><p><strong>稳定性</strong>: 冒泡排序是<strong>稳定</strong>的。因为只有当 <code>arr[j] &gt; arr[j+1]</code> 时才会交换，相等的值不会改变它们的相对顺序。</p>
</li>
</ul>
<h3 id="5-小结"><a href="#5-小结" class="headerlink" title="5. 小结"></a>5. 小结</h3><p><strong>优点</strong>:</p>
<ul>
<li><strong>实现简单</strong>：代码逻辑非常清晰，容易理解和实现。</li>
<li><strong>稳定性</strong>：是一种稳定的排序算法。</li>
<li><strong>空间效率高</strong>：是原地排序，不需要额外的存储空间。</li>
</ul>
<p><strong>缺点</strong>:</p>
<ul>
<li><strong>时间效率低</strong>：<code>O(n²)</code> 的时间复杂度使其在处理大规模数据时非常慢。</li>
</ul>
<p>因此，冒泡排序在实际应用中很少被使用，它更多地是作为一种教学工具，帮助初学者理解排序算法的基本思想。</p>
<hr>
<h2 id="二、选择排序"><a href="#二、选择排序" class="headerlink" title="二、选择排序"></a>二、选择排序</h2><h3 id="1-什么是选择排序？"><a href="#1-什么是选择排序？" class="headerlink" title="1. 什么是选择排序？"></a>1. 什么是选择排序？</h3><p>选择排序（Selection Sort）是另一种简单直观的排序算法。它的工作原理非常直接：首先在未排序的序列中找到最小（或最大）的元素，然后将它存放到排序序列的起始位置。接着，再从剩余未排序的元素中继续寻找最小（或最大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p>
<h4 id="a-核心思想-1"><a href="#a-核心思想-1" class="headerlink" title="a. 核心思想"></a>a. 核心思想</h4><p>算法将列表分为两个部分：</p>
<ol>
<li><strong>已排序部分</strong>：位于列表的前端。</li>
<li><strong>未排序部分</strong>：位于列表的后端。</li>
</ol>
<p>在每一轮迭代中，算法会从“未排序部分”中挑选出最小的元素，并将其与“未排序部分”的第一个元素交换位置。这样，已排序部分的长度就增加了一，而未排序部分的长度减少了一。</p>
<h4 id="b-工作原理-1"><a href="#b-工作原理-1" class="headerlink" title="b. 工作原理"></a>b. 工作原理</h4><ol>
<li><strong>找到最小值</strong>：从列表的第一个元素开始，遍历整个列表，找到最小元素的索引。</li>
<li><strong>交换</strong>：将找到的最小元素与列表的第一个元素进行交换。此时，第一个元素就是整个列表最小的，它现在属于“已排序部分”。</li>
<li><strong>缩小范围</strong>：从列表的第二个元素开始，重复以上过程（在剩余的“未排序部分”中找到最小值，并与该部分的第一个元素交换）。</li>
<li><strong>重复</strong>：持续这个过程，每次都将未排序部分的查找范围缩小一个元素。</li>
<li><strong>终止</strong>：当“未排序部分”只剩下一个元素时，整个列表就已经排序完成了。</li>
</ol>
<h3 id="2-图解示例-1"><a href="#2-图解示例-1" class="headerlink" title="2. 图解示例"></a>2. 图解示例</h3><p>我们还是用 <code>[5, 1, 4, 2, 8]</code> 这个例子来演示选择排序的过程（升序排列）。</p>
<p><strong>初始状态:</strong> <code>[5, 1, 4, 2, 8]</code> (整个列表都是未排序部分)</p>
<p><strong>第一轮 (Pass 1):</strong></p>
<ul>
<li><strong>查找范围</strong>: <code>[5, 1, 4, 2, 8]</code></li>
<li>在范围中找到的最小元素是 <code>1</code>。</li>
<li>将 <code>1</code> 与范围的第一个元素 <code>5</code> 交换。</li>
<li><strong>结果</strong>: <code>[1, 5, 4, 2, 8]</code></li>
<li><strong>已排序部分</strong>: <code>[1]</code></li>
</ul>
<p><strong>第二轮 (Pass 2):</strong></p>
<ul>
<li><strong>查找范围</strong>: <code>[5, 4, 2, 8]</code> (从第二个元素开始)</li>
<li>在范围中找到的最小元素是 <code>2</code>。</li>
<li>将 <code>2</code> 与范围的第一个元素 <code>5</code> 交换。</li>
<li><strong>结果</strong>: <code>[1, 2, 4, 5, 8]</code></li>
<li><strong>已排序部分</strong>: <code>[1, 2]</code></li>
</ul>
<p><strong>第三轮 (Pass 3):</strong></p>
<ul>
<li><strong>查找范围</strong>: <code>[4, 5, 8]</code> (从第三个元素开始)</li>
<li>在范围中找到的最小元素是 <code>4</code>。</li>
<li>它本身就是范围的第一个元素，所以和自己交换（无变化）。</li>
<li><strong>结果</strong>: <code>[1, 2, 4, 5, 8]</code></li>
<li><strong>已排序部分</strong>: <code>[1, 2, 4]</code></li>
</ul>
<p><strong>第四轮 (Pass 4):</strong></p>
<ul>
<li><strong>查找范围</strong>: <code>[5, 8]</code> (从第四个元素开始)</li>
<li>在范围中找到的最小元素是 <code>5</code>。</li>
<li>它本身就是范围的第一个元素，和自己交换（无变化）。</li>
<li><strong>结果</strong>: <code>[1, 2, 4, 5, 8]</code></li>
<li><strong>已排序部分</strong>: <code>[1, 2, 4, 5]</code></li>
</ul>
<p>此时，未排序部分只剩下 <code>[8]</code>，算法结束。</p>
<p>最终排序结果: <code>[1, 2, 4, 5, 8]</code></p>
<h3 id="3-Python-代码实现-1"><a href="#3-Python-代码实现-1" class="headerlink" title="3. Python 代码实现"></a>3. Python 代码实现</h3><p>下面是选择排序的 Python 代码实现。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">selection_sort</span>(<span class="params">arr</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    选择排序函数</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    n = <span class="built_in">len</span>(arr)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 遍历整个列表，i 是已排序部分的边界</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="comment"># 假设当前位置的元素是未排序部分中的最小元素</span></span><br><span class="line">        min_index = i</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 遍历 i 之后的所有元素，以找到真正的最小元素</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">if</span> arr[j] &lt; arr[min_index]:</span><br><span class="line">                min_index = j  <span class="comment"># 更新最小元素的索引</span></span><br><span class="line">                </span><br><span class="line">        <span class="comment"># 将找到的最小元素与当前位置 i 的元素进行交换</span></span><br><span class="line">        <span class="comment"># 如果 min_index 没有改变，就意味着当前元素已经是最小的，无需交换</span></span><br><span class="line">        <span class="keyword">if</span> min_index != i:</span><br><span class="line">            arr[i], arr[min_index] = arr[min_index], arr[i]</span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 示例 ---</span></span><br><span class="line">my_list = [<span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">8</span>]</span><br><span class="line">selection_sort(my_list)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;排序后的列表:&quot;</span>, my_list)  <span class="comment"># 输出: [1, 2, 4, 5, 8]</span></span><br><span class="line"></span><br><span class="line">another_list = [<span class="number">64</span>, <span class="number">34</span>, <span class="number">25</span>, <span class="number">12</span>, <span class="number">22</span>, <span class="number">11</span>, <span class="number">90</span>]</span><br><span class="line">selection_sort(another_list)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;排序后的列表:&quot;</span>, another_list) <span class="comment"># 输出: [11, 12, 22, 25, 34, 64, 90]</span></span><br></pre></td></tr></table></figure>

<h3 id="4-算法分析-1"><a href="#4-算法分析-1" class="headerlink" title="4. 算法分析"></a>4. 算法分析</h3><ul>
<li><p><strong>时间复杂度</strong>:</p>
<ul>
<li><strong>最坏情况</strong>: <code>O(n²)</code>。</li>
<li><strong>平均情况</strong>: <code>O(n²)</code>。</li>
<li><strong>最好情况</strong>: <code>O(n²)</code>。</li>
<li><strong>解释</strong>：无论输入数据是什么样的（即使是已经排好序的），选择排序的比较次数都是固定的。它有两层嵌套循环，外层循环 <code>n-1</code> 次，内层循环的比较次数是一个等差数列 <code>(n-1) + (n-2) + ... + 1</code>，总比较次数为 <code>n*(n-1)/2</code>。因此，其时间复杂度总是 <code>O(n²)</code>。</li>
</ul>
</li>
<li><p><strong>空间复杂度</strong>: <code>O(1)</code>。选择排序也是<strong>原地排序</strong>算法，只需要一个额外的变量 <code>min_index</code> 来存储索引，空间是常数级别的。</p>
</li>
<li><p><strong>稳定性</strong>: 选择排序是<strong>不稳定</strong>的。</p>
<ul>
<li><strong>解释</strong>：稳定性指相等的元素在排序后其相对位置保持不变。在选择排序中，交换操作可能会打乱相等元素的原始顺序。</li>
<li>例如，对于列表 <code>[5a, 8, 5b, 2]</code>（<code>5a</code> 和 <code>5b</code> 值相等，但我们用 a 和 b 区分它们），第一轮会找到 <code>2</code>，然后将 <code>5a</code> 和 <code>2</code> 交换，列表变为 <code>[2, 8, 5b, 5a]</code>。此时，<code>5b</code> 跑到了 <code>5a</code> 的前面，它们的相对顺序改变了。</li>
</ul>
</li>
</ul>
<h3 id="5-小结-1"><a href="#5-小结-1" class="headerlink" title="5. 小结"></a>5. 小结</h3><p><strong>优点</strong>:</p>
<ul>
<li><strong>实现简单</strong>：和冒泡排序一样，逻辑简单，易于理解。</li>
<li><strong>移动次数少</strong>：对于每个元素，最多只会进行一次交换。如果数据的交换成本（移动成本）远高于比较成本，选择排序会比冒泡排序更有优势。</li>
</ul>
<p><strong>缺点</strong>:</p>
<ul>
<li><strong>时间效率低</strong>：<code>O(n²)</code> 的时间复杂度使其不适合处理大规模数据。</li>
<li><strong>性能固定</strong>：无法像优化后的冒泡排序那样，在数据基本有序时提前结束，它总是会执行完所有的比较。</li>
</ul>
<p>总的来说，选择排序也是一种主要用于教学目的的算法，在实际工程中很少使用。</p>
<hr>
<h2 id="三、插入排序"><a href="#三、插入排序" class="headerlink" title="三、插入排序"></a>三、插入排序</h2><h3 id="1-什么是插入排序？"><a href="#1-什么是插入排序？" class="headerlink" title="1. 什么是插入排序？"></a>1. 什么是插入排序？</h3><p>插入排序（Insertion Sort）是一种简单直观的排序算法，其工作方式非常像我们平时整理扑克牌。我们每次从牌堆里抽一张牌，然后将它插入到手中已有牌的正确位置，以保证手中的牌一直是有序的。</p>
<h4 id="a-核心思想-2"><a href="#a-核心思想-2" class="headerlink" title="a. 核心思想"></a>a. 核心思想</h4><p>算法将列表分成“已排序”和“未排序”两个部分。初始时，已排序部分只包含第一个元素。然后，算法每次从未排序部分取出一个元素，在已排序部分中从后向前扫描，找到相应的位置并插入。</p>
<h4 id="b-工作原理-2"><a href="#b-工作原理-2" class="headerlink" title="b. 工作原理"></a>b. 工作原理</h4><ol>
<li><strong>从第二个元素开始</strong>：将列表的第一个元素视为一个已排序的子序列。</li>
<li><strong>选择并比较</strong>：取出未排序部分的第一个元素（我们称之为“待插入元素”或 <code>key</code>）。</li>
<li><strong>向后移动</strong>：将这个 <code>key</code> 与已排序子序列中的元素从后向前逐一比较。如果已排序的元素大于 <code>key</code>，则将该元素向右移动一个位置。</li>
<li><strong>插入</strong>：重复步骤3，直到找到一个小于或等于 <code>key</code> 的元素，或者已到达子序列的开头。然后将 <code>key</code> 插入到这个位置。</li>
<li><strong>重复</strong>：对未排序部分的所有元素重复步骤2-4，直到整个列表都变为已排序状态。</li>
</ol>
<h3 id="2-图解示例-2"><a href="#2-图解示例-2" class="headerlink" title="2. 图解示例"></a>2. 图解示例</h3><p>我们用 <code>[5, 2, 4, 6, 1, 3]</code> 这个例子来演示插入排序的过程（升序排列）。我们将用 <code>|</code> 符号来分隔已排序和未排序部分。</p>
<p><strong>初始状态:</strong> <code>[5 | 2, 4, 6, 1, 3]</code> (已排序部分是 <code>[5]</code>)</p>
<p><strong>第一轮 (处理 <code>2</code>):</strong></p>
<ul>
<li><code>key = 2</code>。</li>
<li>比较 <code>2</code> 和 <code>5</code>。<code>5 &gt; 2</code>，所以将 <code>5</code> 向右移动 -&gt; <code>[ _, 5, 4, 6, 1, 3]</code></li>
<li>已到达列表开头，将 <code>2</code> 插入空位。</li>
<li><strong>结果</strong>: <code>[2, 5 | 4, 6, 1, 3]</code></li>
</ul>
<p><strong>第二轮 (处理 <code>4</code>):</strong></p>
<ul>
<li><code>key = 4</code>。</li>
<li>比较 <code>4</code> 和 <code>5</code>。<code>5 &gt; 4</code>，将 <code>5</code> 向右移动 -&gt; <code>[2, _, 5, 6, 1, 3]</code></li>
<li>比较 <code>4</code> 和 <code>2</code>。<code>2 &lt; 4</code>，停止移动。将 <code>4</code> 插入空位。</li>
<li><strong>结果</strong>: <code>[2, 4, 5 | 6, 1, 3]</code></li>
</ul>
<p><strong>第三轮 (处理 <code>6</code>):</strong></p>
<ul>
<li><code>key = 6</code>。</li>
<li>比较 <code>6</code> 和 <code>5</code>。<code>5 &lt; 6</code>，停止移动。<code>6</code> 保持原位。</li>
<li><strong>结果</strong>: <code>[2, 4, 5, 6 | 1, 3]</code></li>
</ul>
<p><strong>第四轮 (处理 <code>1</code>):</strong></p>
<ul>
<li><code>key = 1</code>。</li>
<li>比较 <code>1</code> 和 <code>6</code> (<code>6 &gt; 1</code>) -&gt; 右移 <code>6</code></li>
<li>比较 <code>1</code> 和 <code>5</code> (<code>5 &gt; 1</code>) -&gt; 右移 <code>5</code></li>
<li>比较 <code>1</code> 和 <code>4</code> (<code>4 &gt; 1</code>) -&gt; 右移 <code>4</code></li>
<li>比较 <code>1</code> 和 <code>2</code> (<code>2 &gt; 1</code>) -&gt; 右移 <code>2</code></li>
<li>已到达列表开头，将 <code>1</code> 插入。</li>
<li><strong>结果</strong>: <code>[1, 2, 4, 5, 6 | 3]</code></li>
</ul>
<p><strong>第五轮 (处理 <code>3</code>):</strong></p>
<ul>
<li><code>key = 3</code>。</li>
<li>比较 <code>3</code> 和 <code>6</code> (<code>6 &gt; 3</code>) -&gt; 右移 <code>6</code></li>
<li>比较 <code>3</code> 和 <code>5</code> (<code>5 &gt; 3</code>) -&gt; 右移 <code>5</code></li>
<li>比较 <code>3</code> 和 <code>4</code> (<code>4 &gt; 3</code>) -&gt; 右移 <code>4</code></li>
<li>比较 <code>3</code> 和 <code>2</code> (<code>2 &lt; 3</code>)，停止移动。将 <code>3</code> 插入。</li>
<li><strong>结果</strong>: <code>[1, 2, 3, 4, 5, 6]</code></li>
</ul>
<p>算法结束，列表已完全排序。</p>
<h3 id="3-Python-代码实现-2"><a href="#3-Python-代码实现-2" class="headerlink" title="3. Python 代码实现"></a>3. Python 代码实现</h3><p>下面是插入排序的 Python 代码实现。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">insertion_sort</span>(<span class="params">arr</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    插入排序函数</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 从第二个元素开始遍历 (索引为 1)</span></span><br><span class="line">    <span class="comment"># 因为第一个元素自己就是一个已排序的子序列</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(arr)):</span><br><span class="line">        <span class="comment"># key 是当前需要被插入的元素</span></span><br><span class="line">        key = arr[i]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># j 是已排序部分的最后一个元素的索引</span></span><br><span class="line">        j = i - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 将 key 与已排序部分的元素从后向前比较</span></span><br><span class="line">        <span class="comment"># 如果已排序的元素大于 key，则将其向后移动</span></span><br><span class="line">        <span class="keyword">while</span> j &gt;= <span class="number">0</span> <span class="keyword">and</span> key &lt; arr[j]:</span><br><span class="line">            arr[j + <span class="number">1</span>] = arr[j] <span class="comment"># 元素后移</span></span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        <span class="comment"># 当循环结束时，j+1 就是 key 应该插入的位置</span></span><br><span class="line">        arr[j + <span class="number">1</span>] = key</span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 示例 ---</span></span><br><span class="line">my_list = [<span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">3</span>]</span><br><span class="line">insertion_sort(my_list)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;排序后的列表:&quot;</span>, my_list)  <span class="comment"># 输出: [1, 2, 3, 4, 5, 6]</span></span><br><span class="line"></span><br><span class="line">another_list = [<span class="number">64</span>, <span class="number">34</span>, <span class="number">25</span>, <span class="number">12</span>, <span class="number">22</span>, <span class="number">11</span>, <span class="number">90</span>]</span><br><span class="line">insertion_sort(another_list)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;排序后的列表:&quot;</span>, another_list) <span class="comment"># 输出: [11, 12, 22, 25, 34, 64, 90]</span></span><br></pre></td></tr></table></figure>

<h3 id="4-算法分析-2"><a href="#4-算法分析-2" class="headerlink" title="4. 算法分析"></a>4. 算法分析</h3><ul>
<li><p><strong>时间复杂度</strong>:</p>
<ul>
<li><strong>最坏情况</strong>: <code>O(n²)</code>。当待排序列表是完全逆序时，每个元素都需要与前面所有已排序的元素进行比较和移动。</li>
<li><strong>平均情况</strong>: <code>O(n²)</code>。</li>
<li><strong>最好情况</strong>: <code>O(n)</code>。当列表已经是有序的时，每次插入操作只需要进行一次比较，内层循环不会执行。这使得插入排序在处理“几乎有序”的数据时非常高效。</li>
</ul>
</li>
<li><p><strong>空间复杂度</strong>: <code>O(1)</code>。插入排序是<strong>原地排序</strong>算法，只需要一个额外的变量 <code>key</code> 来存储待插入元素，空间是常数级别的。</p>
</li>
<li><p><strong>稳定性</strong>: 插入排序是<strong>稳定</strong>的。</p>
<ul>
<li><strong>解释</strong>：当待插入元素 <code>key</code> 遇到与它相等的元素时，循环条件 <code>key &lt; arr[j]</code> 为假，循环会停止，<code>key</code> 会被插入到这个相等元素的后面。因此，相等元素的原始相对顺序得以保留。</li>
</ul>
</li>
</ul>
<h3 id="5-小结-2"><a href="#5-小结-2" class="headerlink" title="5. 小结"></a>5. 小结</h3><p><strong>优点</strong>:</p>
<ul>
<li><strong>实现简单</strong>：代码简洁，易于理解。</li>
<li><strong>高效处理小规模或基本有序的数据</strong>：对于小列表，它的性能很好。对于几乎排好序的列表，它的时间复杂度接近线性 <code>O(n)</code>，这是它优于冒泡排序和选择排序的一个重要特点。</li>
<li><strong>稳定性</strong>：是一种稳定的排序算法。</li>
<li><strong>空间效率高</strong>：是原地排序，占用极少的额外空间。</li>
<li><strong>在线算法 (Online Algorithm)</strong>：可以边接收数据边排序，因为它在决定一个元素的位置时，不需要知道后面元素的信息。</li>
</ul>
<p><strong>缺点</strong>:</p>
<ul>
<li><strong>时间效率低</strong>：对于大规模且无序的数据，<code>O(n²)</code> 的时间复杂度使其效率低下，不如快速排序、归并排序等 <code>O(n log n)</code> 算法。</li>
</ul>
<p>总的来说，插入排序是小型数据集和几乎有序数据集的绝佳选择。在一些复杂排序算法中（如 Timsort，Python 的 <code>list.sort()</code> 和 <code>sorted()</code> 使用的算法），当数据块小到一定程度时，也会切换到插入排序来进行处理。</p>
<hr>
<h2 id="四、快速排序"><a href="#四、快速排序" class="headerlink" title="四、快速排序"></a>四、快速排序</h2><p>快速排序（Quicksort）是计算机科学中最著名和使用最广泛的排序算法之一。它由托尼·霍尔在1959年发明。</p>
<h3 id="1-什么是快速排序？"><a href="#1-什么是快速排序？" class="headerlink" title="1. 什么是快速排序？"></a>1. 什么是快速排序？</h3><p>快速排序是一种高效的、基于<strong>分治法（Divide and Conquer）</strong> 的排序算法。与归并排序类似，它也将问题分解为更小的子问题来解决，但其分治的方式非常独特。</p>
<h4 id="a-核心思想-分治法"><a href="#a-核心思想-分治法" class="headerlink" title="a. 核心思想 (分治法)"></a>a. 核心思想 (分治法)</h4><p>快速排序将一个大数组的排序问题分解为对两个小数组的排序问题。其步骤如下：</p>
<ol>
<li><p><strong>分解 (Divide)</strong>：</p>
<ul>
<li>从数组中选择一个元素，我们称之为 <strong>“基准”（Pivot）</strong>。</li>
<li>重新排列数组，将所有小于基准的元素移动到基准的左边，所有大于基准的元素移动到基准的右边。相等的元素可以放在任何一边。</li>
<li>完成这个过程后，基准元素就处于其最终的排序位置。这个过程被称为 <strong>“分区”（Partitioning）</strong>。</li>
</ul>
</li>
<li><p><strong>征服 (Conquer)</strong>：</p>
<ul>
<li>递归地对基准左边的子数组和右边的子数组进行快速排序。</li>
</ul>
</li>
<li><p><strong>合并 (Combine)</strong>：</p>
<ul>
<li>因为子数组是原地排序的，所以当递归结束时，整个数组就已经排好序了。这个步骤是隐式的，不需要任何操作。</li>
</ul>
</li>
</ol>
<h4 id="b-分区（Partition）操作是关键"><a href="#b-分区（Partition）操作是关键" class="headerlink" title="b. 分区（Partition）操作是关键"></a>b. 分区（Partition）操作是关键</h4><p>分区的实现方式有很多种，最著名的是 <strong>Lomuto 分区方案</strong>。其工作原理如下：</p>
<ol>
<li>通常选择数组的最后一个元素作为基准。</li>
<li>维护一个指针 <code>i</code>，它指向“小于基准”区域的最后一个元素的下一个位置（可以看作是这个区域的右边界）。初始时，<code>i</code> 在数组的起始位置之前。</li>
<li>用另一个指针 <code>j</code> 遍历数组（从头到倒数第二个元素）。</li>
<li>如果 <code>arr[j]</code> 小于或等于基准，就将 <code>i</code> 向右移动一位，然后交换 <code>arr[i]</code> 和 <code>arr[j]</code>。这相当于将小于基准的元素 <code>arr[j]</code> 放入“小于基准”的区域。</li>
<li>遍历结束后，将基准元素（原本在数组末尾）与 <code>arr[i+1]</code> 交换。这样，基准就恰好位于所有比它小的元素和所有比它大的元素之间。</li>
<li>返回基准的新索引。</li>
</ol>
<h3 id="2-图解示例-3"><a href="#2-图解示例-3" class="headerlink" title="2. 图解示例"></a>2. 图解示例</h3><p>我们用 <code>[7, 2, 1, 6, 8, 5, 3, 4]</code> 这个例子来演示快速排序的过程。</p>
<p><strong>初始调用:</strong> <code>quick_sort([7, 2, 1, 6, 8, 5, 3, 4])</code></p>
<p><strong>第一轮 (Partition):</strong></p>
<ul>
<li>选择基准（Pivot），我们选最后一个元素 <code>4</code>。</li>
<li>分区过程会将 <code>&lt;4</code> 的元素放到左边，<code>&gt;4</code> 的元素放到右边。</li>
<li>分区后的数组可能样子是：<code>[3, 2, 1, 4, 8, 5, 7, 6]</code> (注意：分区结果不唯一，取决于具体实现)</li>
<li>现在 <code>4</code> 已经找到了它的最终位置（索引3）。</li>
</ul>
<p><strong>第二轮 (递归调用):</strong></p>
<ul>
<li><p>现在问题变成了两个独立的子问题：</p>
<ol>
<li>对 <code>4</code> 左边的子数组 <code>[3, 2, 1]</code> 进行快速排序。</li>
<li>对 <code>4</code> 右边的子数组 <code>[8, 5, 7, 6]</code> 进行快速排序。</li>
</ol>
</li>
<li><p><strong>处理左子数组 <code>[3, 2, 1]</code></strong>:</p>
<ul>
<li>选择基准 <code>1</code>。</li>
<li>分区后：<code>[1, 2, 3]</code> (<code>1</code> 位于正确位置)。</li>
<li>递归处理 <code>1</code> 左边（空）和右边 <code>[2, 3]</code> 的子数组。</li>
<li>处理 <code>[2, 3]</code>，基准为 <code>3</code>，分区后不变，<code>2</code> 在左，排序完成。</li>
</ul>
</li>
<li><p><strong>处理右子数组 <code>[8, 5, 7, 6]</code></strong>:</p>
<ul>
<li>选择基准 <code>6</code>。</li>
<li>分区后：<code>[5, 6, 7, 8]</code> (<code>6</code> 位于正确位置)。</li>
<li>递归处理 <code>6</code> 左边 <code>[5]</code> 和右边 <code>[7, 8]</code> 的子数组。</li>
<li><code>[5]</code> 已排序。处理 <code>[7, 8]</code>，基准为 <code>8</code>，分区后不变，<code>7</code> 在左，排序完成。</li>
</ul>
</li>
</ul>
<p><strong>最终结果:</strong><br>当所有递归调用都返回后，原始数组就变成了 <code>[1, 2, 3, 4, 5, 6, 7, 8]</code>。</p>
<h3 id="3-Python-代码实现-3"><a href="#3-Python-代码实现-3" class="headerlink" title="3. Python 代码实现"></a>3. Python 代码实现</h3><p>下面是使用 Lomuto 分区方案的快速排序 Python 实现。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">partition</span>(<span class="params">arr, low, high</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    分区函数 (Lomuto partition scheme)</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        arr: 待分区的列表</span></span><br><span class="line"><span class="string">        low: 起始索引</span></span><br><span class="line"><span class="string">        high: 结束索引 (也是基准元素的索引)</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        基准元素分区后的最终索引</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 选择最后一个元素作为基准</span></span><br><span class="line">    pivot = arr[high]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># i 是指向小于基准的区域的最后一个元素的下一个位置</span></span><br><span class="line">    i = low - <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 遍历从 low 到 high-1 的元素</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(low, high):</span><br><span class="line">        <span class="comment"># 如果当前元素小于或等于基准</span></span><br><span class="line">        <span class="keyword">if</span> arr[j] &lt;= pivot:</span><br><span class="line">            <span class="comment"># 将 i 向右移动</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 将小于基准的元素 arr[j] 交换到 i 指向的位置</span></span><br><span class="line">            arr[i], arr[j] = arr[j], arr[i]</span><br><span class="line">            </span><br><span class="line">    <span class="comment"># 将基准元素放到正确的位置 (i+1)</span></span><br><span class="line">    arr[i + <span class="number">1</span>], arr[high] = arr[high], arr[i + <span class="number">1</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 返回基准的索引</span></span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_quick_sort_recursive</span>(<span class="params">arr, low, high</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    快速排序的递归辅助函数</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> low &lt; high:</span><br><span class="line">        <span class="comment"># pi 是分区后基准的索引</span></span><br><span class="line">        pi = partition(arr, low, high)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 递归地对基准左边的子数组进行排序</span></span><br><span class="line">        _quick_sort_recursive(arr, low, pi - <span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 递归地对基准右边的子数组进行排序</span></span><br><span class="line">        _quick_sort_recursive(arr, pi + <span class="number">1</span>, high)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">quick_sort</span>(<span class="params">arr</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    快速排序主函数</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    _quick_sort_recursive(arr, <span class="number">0</span>, <span class="built_in">len</span>(arr) - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 示例 ---</span></span><br><span class="line">my_list = [<span class="number">7</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">quick_sort(my_list)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;排序后的列表:&quot;</span>, my_list)  <span class="comment"># 输出: [1, 2, 3, 4, 5, 6, 7, 8]</span></span><br><span class="line"></span><br><span class="line">another_list = [<span class="number">64</span>, <span class="number">34</span>, <span class="number">25</span>, <span class="number">12</span>, <span class="number">22</span>, <span class="number">11</span>, <span class="number">90</span>]</span><br><span class="line">quick_sort(another_list)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;排序后的列表:&quot;</span>, another_list) <span class="comment"># 输出: [11, 12, 22, 25, 34, 64, 90]</span></span><br></pre></td></tr></table></figure>

<h3 id="4-算法分析-3"><a href="#4-算法分析-3" class="headerlink" title="4. 算法分析"></a>4. 算法分析</h3><ul>
<li><p><strong>时间复杂度</strong>:</p>
<ul>
<li><strong>最坏情况</strong>: <code>O(n²)</code>。当每次选择的基准都是当前数组中的最小或最大元素时发生（例如，对一个已经排好序的数组进行排序）。这会导致分区极不平衡，递归树退化成一个线性链表。</li>
<li><strong>平均情况</strong>: <code>O(n log n)</code>。这是快速排序最常见的情况。每次分区都将数组分成大致相等的两部分，递归树的深度为 <code>log n</code>，每层分区操作的总时间是 <code>O(n)</code>。</li>
<li><strong>最好情况</strong>: <code>O(n log n)</code>。每次分区都恰好将数组分成两半。</li>
</ul>
</li>
<li><p><strong>空间复杂度</strong>: <code>O(log n)</code> (平均情况) 到 <code>O(n)</code> (最坏情况)。这个空间是递归调用栈所占用的。平均情况下递归深度为 <code>log n</code>，最坏情况下为 <code>n</code>。</p>
</li>
<li><p><strong>稳定性</strong>: 快速排序是<strong>不稳定</strong>的。在分区过程中，元素交换可能会改变相等元素的原始相对顺序。</p>
</li>
</ul>
<h3 id="5-优化"><a href="#5-优化" class="headerlink" title="5. 优化"></a>5. 优化</h3><p>为了避免最坏情况的发生，可以优化<strong>基准的选择</strong>：</p>
<ol>
<li><strong>随机基准</strong>：随机选择一个元素作为基准。这使得最坏情况在实践中几乎不可能发生。</li>
<li><strong>三数取中 (Median-of-Three)</strong>：取数组的第一个、中间一个和最后一个元素的中位数作为基准。这能有效避免在有序或逆序数组上性能下降的问题。</li>
</ol>
<h3 id="6-小结"><a href="#6-小结" class="headerlink" title="6. 小结"></a>6. 小结</h3><p><strong>优点</strong>:</p>
<ul>
<li><strong>极高的平均效率</strong>：<code>O(n log n)</code> 的平均时间复杂度，并且其常数因子很小，使其在实践中通常比其他 <code>O(n log n)</code> 算法（如归并排序、堆排序）更快。</li>
<li><strong>原地排序</strong>：通常是原地排序，只需要 <code>O(log n)</code> 的栈空间。</li>
</ul>
<p><strong>缺点</strong>:</p>
<ul>
<li><strong>最坏情况性能差</strong>：<code>O(n²)</code> 的时间复杂度在某些情况下可能发生。</li>
<li><strong>不稳定</strong>：不保证相等元素的相对顺序。</li>
<li><strong>对小数据量效率不高</strong>：对于非常小的数组，其递归开销可能比插入排序等简单算法更大。因此，一些优化的快速排序实现会在子数组小到一定程度时，切换到插入排序。</li>
</ul>
<hr>
<h2 id="五、归并排序"><a href="#五、归并排序" class="headerlink" title="五、归并排序"></a>五、归并排序</h2><h3 id="1-什么是归并排序？"><a href="#1-什么是归并排序？" class="headerlink" title="1. 什么是归并排序？"></a>1. 什么是归并排序？</h3><p>归并排序（Merge Sort）是另一种基于<strong>分治法（Divide and Conquer）<strong>思想的高效排序算法。它的名字来源于其核心操作——</strong>“归并”（Merge）</strong>，即将两个已经排好序的序列合并成一个有序序列。</p>
<h4 id="a-核心思想-分治法-1"><a href="#a-核心思想-分治法-1" class="headerlink" title="a. 核心思想 (分治法)"></a>a. 核心思想 (分治法)</h4><p>归并排序将排序问题分解为三个步骤：</p>
<ol>
<li><strong>分解 (Divide)</strong>：将待排序的列表不断地对半分割，直到每个子列表只包含一个元素。一个只包含一个元素的列表自然就是有序的。</li>
<li><strong>征服 (Conquer)</strong>：这一步是隐式的。因为分解到最后，每个子列表都只有一个元素，所以它们已经是“已排序”的状态。</li>
<li><strong>合并 (Combine)</strong>：从最小的子列表开始，将相邻的两个已排序的子列表 <strong>归并</strong> 成一个更大的、有序的列表。这个过程不断重复，直到所有子列表被合并成一个完整的、有序的列表。</li>
</ol>
<h4 id="b-工作原理-3"><a href="#b-工作原理-3" class="headerlink" title="b. 工作原理"></a>b. 工作原理</h4><p>归并排序的关键在于**“合并”**这一步。假设我们有两个已经排好序的列表 <code>A</code> 和 <code>B</code>，如何将它们合并成一个有序的大列表 <code>C</code> 呢？</p>
<ol>
<li>创建两个指针，分别指向 <code>A</code> 和 <code>B</code> 的起始位置。</li>
<li>比较两个指针指向的元素。</li>
<li>将较小的那个元素复制到 <code>C</code> 中，并将该指针向后移动一位。</li>
<li>重复步骤2和3，直到其中一个列表的所有元素都被复制完毕。</li>
<li>将另一个列表中剩余的所有元素直接复制到 <code>C</code> 的末尾。</li>
</ol>
<h3 id="2-图解示例-4"><a href="#2-图解示例-4" class="headerlink" title="2. 图解示例"></a>2. 图解示例</h3><p>我们用 <code>[8, 3, 1, 7, 0, 10, 2]</code> 这个例子来演示归并排序的过程。</p>
<p><strong>1. 分解 (Splitting Phase):</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">                [8, 3, 1, 7, 0, 10, 2]</span><br><span class="line">               /                       \</span><br><span class="line">        [8, 3, 1, 7]                  [0, 10, 2]</span><br><span class="line">       /           \                 /          \</span><br><span class="line">   [8, 3]        [1, 7]            [0, 10]      [2]</span><br><span class="line">  /      \      /      \          /       \</span><br><span class="line">[8]      [3]  [1]      [7]      [0]       [10]</span><br></pre></td></tr></table></figure>
<p>分解过程一直持续到每个子列表只有一个元素。</p>
<p><strong>2. 合并 (Merging Phase):</strong></p>
<p>现在，我们从底层开始，将这些单元素的列表两两合并。</p>
<ul>
<li><code>[8]</code> 和 <code>[3]</code> 合并成 <code>[3, 8]</code></li>
<li><code>[1]</code> 和 <code>[7]</code> 合并成 <code>[1, 7]</code></li>
<li><code>[0]</code> 和 <code>[10]</code> 合并成 <code>[0, 10]</code></li>
<li><code>[2]</code> 保持不变（因为它没有相邻的伙伴）</li>
</ul>
<p>此时，列表结构变为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[3, 8]        [1, 7]            [0, 10]      [2]</span><br></pre></td></tr></table></figure>

<ul>
<li><code>[3, 8]</code> 和 <code>[1, 7]</code> 合并成 <code>[1, 3, 7, 8]</code></li>
<li><code>[0, 10]</code> 和 <code>[2]</code> 合并成 <code>[0, 2, 10]</code></li>
</ul>
<p>此时，列表结构变为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1, 3, 7, 8]                  [0, 2, 10]</span><br></pre></td></tr></table></figure>

<ul>
<li>最后，<code>[1, 3, 7, 8]</code> 和 <code>[0, 2, 10]</code> 合并成最终结果 <code>[0, 1, 2, 3, 7, 8, 10]</code></li>
</ul>
<p>最终排序结果: <code>[0, 1, 2, 3, 7, 8, 10]</code></p>
<h3 id="3-Python-代码实现-4"><a href="#3-Python-代码实现-4" class="headerlink" title="3. Python 代码实现"></a>3. Python 代码实现</h3><p>下面是归并排序的典型 Python 递归实现。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">merge_sort</span>(<span class="params">arr</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    归并排序函数</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 递归的终止条件：如果列表只有一个元素或为空，则它已经是有序的</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(arr) &gt; <span class="number">1</span>:</span><br><span class="line">        <span class="comment"># 1. 分解 (Divide)</span></span><br><span class="line">        mid = <span class="built_in">len</span>(arr) // <span class="number">2</span>  <span class="comment"># 找到列表的中间位置</span></span><br><span class="line">        left_half = arr[:mid]  <span class="comment"># 分割成左半部分</span></span><br><span class="line">        right_half = arr[mid:] <span class="comment"># 分割成右半部分</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 递归地对左右两半进行排序</span></span><br><span class="line">        merge_sort(left_half)</span><br><span class="line">        merge_sort(right_half)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 2. 合并 (Combine/Merge)</span></span><br><span class="line">        i = <span class="number">0</span>  <span class="comment"># 左半部分的索引</span></span><br><span class="line">        j = <span class="number">0</span>  <span class="comment"># 右半部分的索引</span></span><br><span class="line">        k = <span class="number">0</span>  <span class="comment"># 合并后主列表的索引</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 当左右两半都还有元素时，进行比较</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(left_half) <span class="keyword">and</span> j &lt; <span class="built_in">len</span>(right_half):</span><br><span class="line">            <span class="keyword">if</span> left_half[i] &lt;= right_half[j]:</span><br><span class="line">                arr[k] = left_half[i]</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                arr[k] = right_half[j]</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            k += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 检查是否有剩余的元素</span></span><br><span class="line">        <span class="comment"># 如果左半部分还有剩余，直接复制过来</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(left_half):</span><br><span class="line">            arr[k] = left_half[i]</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            k += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 如果右半部分还有剩余，直接复制过来</span></span><br><span class="line">        <span class="keyword">while</span> j &lt; <span class="built_in">len</span>(right_half):</span><br><span class="line">            arr[k] = right_half[j]</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">            k += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 示例 ---</span></span><br><span class="line">my_list = [<span class="number">8</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="number">2</span>]</span><br><span class="line">merge_sort(my_list)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;排序后的列表:&quot;</span>, my_list)  <span class="comment"># 输出: [0, 1, 2, 3, 7, 8, 10]</span></span><br><span class="line"></span><br><span class="line">another_list = [<span class="number">64</span>, <span class="number">34</span>, <span class="number">25</span>, <span class="number">12</span>, <span class="number">22</span>, <span class="number">11</span>, <span class="number">90</span>]</span><br><span class="line">merge_sort(another_list)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;排序后的列表:&quot;</span>, another_list) <span class="comment"># 输出: [11, 12, 22, 25, 34, 64, 90]</span></span><br></pre></td></tr></table></figure>

<h3 id="4-算法分析-4"><a href="#4-算法分析-4" class="headerlink" title="4. 算法分析"></a>4. 算法分析</h3><ul>
<li><p><strong>时间复杂度</strong>: <code>O(n log n)</code>。</p>
<ul>
<li><strong>解释</strong>：分解过程将列表分成两半，这个过程的递归树深度是 <code>log n</code>。在每一层递归中，合并操作都需要遍历该层的所有元素，总共是 <code>n</code> 个元素。因此，总的时间复杂度是 <code>n * log n</code>。</li>
<li>这个时间复杂度非常<strong>稳定</strong>，无论是<strong>最好、最坏还是平均情况</strong>，都是 <code>O(n log n)</code>。这是归并排序的一个巨大优势。</li>
</ul>
</li>
<li><p><strong>空间复杂度</strong>: <code>O(n)</code>。</p>
<ul>
<li><strong>解释</strong>：归并排序<strong>不是原地排序</strong>。在合并阶段，需要创建临时的 <code>left_half</code> 和 <code>right_half</code> 列表来存储数据。在递归的每一层，这些临时列表加起来的总空间是 <code>O(n)</code>。</li>
</ul>
</li>
<li><p><strong>稳定性</strong>: 归并排序是<strong>稳定</strong>的。</p>
<ul>
<li><strong>解释</strong>：在合并操作中，当遇到相等的元素时（<code>left_half[i] &lt;= right_half[j]</code>），我们总是先取左半部分的元素。这保证了相等元素的原始相对顺序不会改变。</li>
</ul>
</li>
</ul>
<h3 id="5-小结-3"><a href="#5-小结-3" class="headerlink" title="5. 小结"></a>5. 小结</h3><p><strong>优点</strong>:</p>
<ul>
<li><strong>性能稳定可靠</strong>：时间复杂度始终是 <code>O(n log n)</code>，不受输入数据的影响。</li>
<li><strong>稳定性</strong>：是一种稳定的排序算法，适用于需要保持相等元素相对顺序的场景。</li>
<li><strong>适用性广</strong>：特别适合对链表进行排序，因为链表插入操作 <code>O(1)</code>，可以避免数组复制带来的开销。也适用于外部排序（数据量大到无法一次性载入内存）。</li>
</ul>
<p><strong>缺点</strong>:</p>
<ul>
<li><strong>空间复杂度较高</strong>：需要 <code>O(n)</code> 的额外空间，这在内存受限的情况下可能是一个问题。相比之下，快速排序的平均空间复杂度是 <code>O(log n)</code>。</li>
</ul>
<p>总的来说，归并排序是一种非常强大和可靠的排序算法，当需要一个性能稳定或排序结果稳定的算法时，它是一个绝佳的选择。</p>
<hr>
<h2 id="六、堆排序"><a href="#六、堆排序" class="headerlink" title="六、堆排序"></a>六、堆排序</h2><h3 id="1-什么是堆排序？"><a href="#1-什么是堆排序？" class="headerlink" title="1. 什么是堆排序？"></a>1. 什么是堆排序？</h3><p>堆排序是一种基于<strong>比较</strong>的排序算法，它利用了一种叫做 <strong>“堆”（Heap）</strong> 的数据结构。你可以把它看作是选择排序的一种改进版本。在选择排序中，我们每次都需要线性扫描 <code>O(n)</code> 来找到未排序部分的最大（或最小）元素。而堆排序通过将数据组织成一个堆，可以在 <code>O(log n)</code> 的时间内找到最大（或最小）元素，从而提高了效率。</p>
<h4 id="a-核心前提：什么是堆（Heap）？"><a href="#a-核心前提：什么是堆（Heap）？" class="headerlink" title="a. 核心前提：什么是堆（Heap）？"></a>a. 核心前提：什么是堆（Heap）？</h4><p>在介绍堆排序之前，必须先理解“堆”。堆是一个近似<strong>完全二叉树</strong>的结构，并同时满足<strong>堆的性质</strong>：</p>
<ol>
<li><p><strong>结构性</strong>：它是一棵完全二叉树。这意味着树的每一层都是完全填满的，除了最后一层，最后一层的节点都尽量靠左排列。这使得我们可以用一个 <strong>数组（列表）</strong> 来高效地表示它，而无需使用指针。</p>
<ul>
<li>对于数组中索引为 <code>i</code> 的节点：<ul>
<li>其父节点索引：<code>(i - 1) // 2</code></li>
<li>其左子节点索引：<code>2 * i + 1</code></li>
<li>其右子节点索引：<code>2 * i + 2</code></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>堆序性 (Heap Property)</strong>：</p>
<ul>
<li><strong>最大堆 (Max-Heap)</strong>：父节点的值总是<strong>大于或等于</strong>其任何一个子节点的值。因此，堆的根节点（数组的第一个元素）是整个堆中的最大值。</li>
<li><strong>最小堆 (Min-Heap)</strong>：父节点的值总是<strong>小于或等于</strong>其任何一个子节点的值。因此，堆的根节点是整个堆中的最小值。</li>
</ul>
</li>
</ol>
<p><strong>为了实现升序排序，我们通常使用最大堆。</strong></p>
<h4 id="b-堆排序的工作原理"><a href="#b-堆排序的工作原理" class="headerlink" title="b. 堆排序的工作原理"></a>b. 堆排序的工作原理</h4><p>堆排序可以分为两个主要阶段：</p>
<p><strong>阶段一：建堆 (Build Heap)</strong></p>
<ol>
<li>将待排序的无序列表看作一个完全二叉树。</li>
<li>从最后一个非叶子节点开始，向前逐个处理到根节点。</li>
<li>对每个节点执行一个叫做 <strong>“堆化”（Heapify）</strong> 或“下沉”（Sift-down）的操作，确保以该节点为根的子树满足最大堆的性质。</li>
<li>当处理完所有非叶子节点后，整个列表就变成了一个最大堆。</li>
</ol>
<p><strong>阶段二：排序 (Sorting)</strong></p>
<ol>
<li>此时，列表的第一个元素（根节点）是当前所有元素中的最大值。</li>
<li>将这个最大值与列表的最后一个元素交换。这样，最大的元素就被放到了它最终应该在的正确位置。</li>
<li>将列表的已排序部分（即最后一个元素）从堆中移除（逻辑上通过缩小堆的大小来实现）。</li>
<li>此时，新的根节点可能违反了最大堆的性质。对新的根节点执行一次“堆化”操作，使其恢复最大堆的性质。</li>
<li>重复步骤2-4，每次都将堆顶的最大元素交换到末尾，然后缩小堆的范围并调整堆，直到堆的大小为1。</li>
</ol>
<h3 id="2-图解示例-5"><a href="#2-图解示例-5" class="headerlink" title="2. 图解示例"></a>2. 图解示例</h3><p>我们用 <code>[4, 10, 3, 5, 1, 2]</code> 来演示堆排序的过程。</p>
<p><strong>阶段一：构建最大堆</strong></p>
<ol>
<li>初始数组（看作树）：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">      4</span><br><span class="line">   /     \</span><br><span class="line">  10      3</span><br><span class="line"> / \     /</span><br><span class="line">5   1   2</span><br></pre></td></tr></table></figure></li>
<li>从最后一个非叶子节点 <code>3</code> (索引2) 开始堆化，无变化。</li>
<li>处理下一个非叶子节点 <code>10</code> (索引1)。它的子节点是 <code>5</code> 和 <code>1</code>。<code>10</code> 是最大的，无变化。</li>
<li>处理根节点 <code>4</code> (索引0)。它的子节点是 <code>10</code> 和 <code>3</code>。<code>10 &gt; 4</code>，交换 <code>4</code> 和 <code>10</code>。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">      10</span><br><span class="line">   /     \</span><br><span class="line">  4       3</span><br><span class="line"> / \     /</span><br><span class="line">5   1   2</span><br></pre></td></tr></table></figure>
交换后，<code>4</code> 到了新位置（原 <code>10</code> 的位置），它的子节点是 <code>5</code> 和 <code>1</code>。<code>5 &gt; 4</code>，再次交换。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">      10</span><br><span class="line">   /     \</span><br><span class="line">  5       3</span><br><span class="line"> / \     /</span><br><span class="line">4   1   2</span><br></pre></td></tr></table></figure></li>
<li>建堆完成，数组变为 <code>[10, 5, 3, 4, 1, 2]</code>。</li>
</ol>
<p><strong>阶段二：排序</strong></p>
<ol>
<li><p><strong>第一次</strong>：堆是 <code>[10, 5, 3, 4, 1, 2]</code>。</p>
<ul>
<li>交换 <code>10</code> 和 <code>2</code> -&gt; <code>[2, 5, 3, 4, 1, 10]</code>。</li>
<li>堆范围缩小为前5个元素 <code>[2, 5, 3, 4, 1]</code>，对根节点 <code>2</code> 进行堆化 -&gt; <code>[5, 4, 3, 2, 1]</code>。</li>
<li>此时数组为 <code>[5, 4, 3, 2, 1, 10]</code>。</li>
</ul>
</li>
<li><p><strong>第二次</strong>：堆是 <code>[5, 4, 3, 2, 1]</code>。</p>
<ul>
<li>交换 <code>5</code> 和 <code>1</code> -&gt; <code>[1, 4, 3, 2, 5]</code>。</li>
<li>堆范围缩小为前4个元素 <code>[1, 4, 3, 2]</code>，对根节点 <code>1</code> 进行堆化 -&gt; <code>[4, 2, 3, 1]</code>。</li>
<li>此时数组为 <code>[4, 2, 3, 1, 5, 10]</code>。</li>
</ul>
</li>
<li><p>……以此类推，直到堆中只剩一个元素。</p>
</li>
</ol>
<p>最终排序结果: <code>[1, 2, 3, 4, 5, 10]</code></p>
<h3 id="3-Python-代码实现-5"><a href="#3-Python-代码实现-5" class="headerlink" title="3. Python 代码实现"></a>3. Python 代码实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">heapify</span>(<span class="params">arr, n, i</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    将以 i 为根的子树调整为最大堆</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        arr: 待调整的列表</span></span><br><span class="line"><span class="string">        n: 堆的大小</span></span><br><span class="line"><span class="string">        i: 子树的根节点索引</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    largest = i      <span class="comment"># 初始化最大值为根节点</span></span><br><span class="line">    left = <span class="number">2</span> * i + <span class="number">1</span>   <span class="comment"># 左子节点</span></span><br><span class="line">    right = <span class="number">2</span> * i + <span class="number">2</span>  <span class="comment"># 右子节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 检查左子节点是否存在且大于根节点</span></span><br><span class="line">    <span class="keyword">if</span> left &lt; n <span class="keyword">and</span> arr[left] &gt; arr[largest]:</span><br><span class="line">        largest = left</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 检查右子节点是否存在且大于当前最大值</span></span><br><span class="line">    <span class="keyword">if</span> right &lt; n <span class="keyword">and</span> arr[right] &gt; arr[largest]:</span><br><span class="line">        largest = right</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果最大值不是根节点，则交换它们，并继续向下堆化</span></span><br><span class="line">    <span class="keyword">if</span> largest != i:</span><br><span class="line">        arr[i], arr[largest] = arr[largest], arr[i]</span><br><span class="line">        <span class="comment"># 递归地堆化受影响的子树</span></span><br><span class="line">        heapify(arr, n, largest)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">heap_sort</span>(<span class="params">arr</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    堆排序函数</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    n = <span class="built_in">len</span>(arr)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 1. 构建最大堆</span></span><br><span class="line">    <span class="comment"># 从最后一个非叶子节点开始，向前遍历</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n // <span class="number">2</span> - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        heapify(arr, n, i)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. 一个个从堆顶取出元素，进行排序</span></span><br><span class="line">    <span class="comment"># 将当前最大元素（根）与末尾元素交换，然后重新调整堆</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">        arr[i], arr[<span class="number">0</span>] = arr[<span class="number">0</span>], arr[i]  <span class="comment"># 交换</span></span><br><span class="line">        heapify(arr, i, <span class="number">0</span>) <span class="comment"># 对缩小后的堆进行堆化</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 示例 ---</span></span><br><span class="line">my_list = [<span class="number">4</span>, <span class="number">10</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">heap_sort(my_list)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;排序后的列表:&quot;</span>, my_list)  <span class="comment"># 输出: [1, 2, 3, 4, 5, 10]</span></span><br><span class="line"></span><br><span class="line">another_list = [<span class="number">64</span>, <span class="number">34</span>, <span class="number">25</span>, <span class="number">12</span>, <span class="number">22</span>, <span class="number">11</span>, <span class="number">90</span>]</span><br><span class="line">heap_sort(another_list)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;排序后的列表:&quot;</span>, another_list) <span class="comment"># 输出: [11, 12, 22, 25, 34, 64, 90]</span></span><br></pre></td></tr></table></figure>

<h3 id="4-算法分析-5"><a href="#4-算法分析-5" class="headerlink" title="4. 算法分析"></a>4. 算法分析</h3><ul>
<li><p><strong>时间复杂度</strong>: <code>O(n log n)</code>。</p>
<ul>
<li><strong>建堆阶段</strong>: 虽然看起来是 <code>n/2</code> 次调用 <code>heapify</code> (复杂度 <code>log n</code>)，但精确分析表明建堆的时间复杂度是线性的 <code>O(n)</code>。</li>
<li><strong>排序阶段</strong>: 进行了 <code>n-1</code> 次交换和 <code>heapify</code> 操作。每次 <code>heapify</code> 的时间复杂度是 <code>O(log n)</code>。所以这部分是 <code>O(n log n)</code>。</li>
<li><strong>总计</strong>: <code>O(n) + O(n log n) = O(n log n)</code>。这个时间复杂度在<strong>最好、最坏和平均情况</strong>下都是一样的。</li>
</ul>
</li>
<li><p><strong>空间复杂度</strong>: <code>O(1)</code>。</p>
<ul>
<li>堆排序是<strong>原地排序</strong>算法，因为它是在原始数组上直接进行操作的，只需要常数级别的额外空间（用于递归调用栈，但可以被迭代写法替代）。</li>
</ul>
</li>
<li><p><strong>稳定性</strong>: 堆排序是<strong>不稳定</strong>的。</p>
<ul>
<li><strong>解释</strong>：在将堆顶元素与堆尾元素交换时，可能会打乱相等元素的原始相对顺序。例如 <code>[3a, 2, 3b]</code>，建堆后可能是 <code>[3b, 2, 3a]</code>，第一次交换会将 <code>3b</code> 与 <code>3a</code> 交换，<code>3a</code> 就跑到了 <code>3b</code> 的后面。</li>
</ul>
</li>
</ul>
<h3 id="5-小结-4"><a href="#5-小结-4" class="headerlink" title="5. 小结"></a>5. 小结</h3><p><strong>优点</strong>:</p>
<ul>
<li><strong>性能优秀且稳定</strong>：<code>O(n log n)</code> 的时间复杂度在各种情况下都得到保证，没有像快速排序那样的 <code>O(n²)</code> 最坏情况。</li>
<li><strong>空间效率高</strong>：<code>O(1)</code> 的空间复杂度，是原地排序算法。</li>
</ul>
<p><strong>缺点</strong>:</p>
<ul>
<li><strong>不稳定</strong>：不适用于需要保持相等元素相对顺序的场景。</li>
<li><strong>常数因子较大</strong>：在实践中，对于同样的数据，平均性能通常不如经过优化的快速排序，因为其数据访问模式对 CPU 缓存不友好。</li>
</ul>
<p>堆排序在需要 <code>O(n log n)</code> 最坏情况时间保证和 <code>O(1)</code> 空间复杂度的场景下非常有用，例如在一些嵌入式系统或对内存要求严格的环境中。它也是实现**优先队列（Priority Queue）**的常用数据结构。</p>
<hr>
<h2 id="七、希尔排序"><a href="#七、希尔排序" class="headerlink" title="七、希尔排序"></a>七、希尔排序</h2><h3 id="1-什么是希尔排序？"><a href="#1-什么是希尔排序？" class="headerlink" title="1. 什么是希尔排序？"></a>1. 什么是希尔排序？</h3><p>希尔排序，也称<strong>递减增量排序算法</strong>（Diminishing Increment Sort），是插入排序的一种更高效的改进版本。它由 Donald Shell 于1959年提出。</p>
<p>插入排序在处理“几乎有序”的数组时效率非常高，但当数组元素需要移动很长的距离时（例如，最小的元素在数组末尾），它的效率就很低，因为每个元素只能向前移动一个位置。</p>
<p>希尔排序的核心思想就是<strong>克服了插入排序的这个缺点</strong>。它通过允许交换相隔一定距离的元素，来快速地将元素移动到更接近其最终位置的地方，从而使得整个数组变得“部分有序”。然后，它逐步缩减这个距离，最后进行一次标准的插入排序，此时由于数组已经基本有序，排序速度会非常快。</p>
<h4 id="a-核心思想-3"><a href="#a-核心思想-3" class="headerlink" title="a. 核心思想"></a>a. 核心思想</h4><ol>
<li><strong>选择一个增量序列（Gap Sequence）</strong>：选择一个整数序列 <code>t1, t2, ..., tk</code>，其中 <code>t1 &gt; t2 &gt; ... &gt; tk = 1</code>。这个序列被称为增量或间隙（Gap）。</li>
<li><strong>分组排序</strong>：对于每一个增量 <code>t_i</code>，将整个数组分为 <code>t_i</code> 个子数组。每个子数组由所有相隔 <code>t_i</code> 的元素组成。</li>
<li><strong>对子数组进行插入排序</strong>：对这 <code>t_i</code> 个子数组分别进行插入排序。由于是同时对多个交错的子数组进行排序，这个过程实际上是在整个数组上进行一次“宏观”的插入排序。</li>
<li><strong>递减增量</strong>：重复步骤2和3，使用下一个更小的增量 <code>t_{i+1}</code>。</li>
<li><strong>最终排序</strong>：当增量 <code>t_k = 1</code> 时，整个数组被看作一个子数组，执行一次标准的插入排序。但此时，数组已经基本有序，所以这次插入排序的效率非常高。</li>
</ol>
<h4 id="b-增量序列的选择"><a href="#b-增量序列的选择" class="headerlink" title="b. 增量序列的选择"></a>b. 增量序列的选择</h4><p>增量序列的选择对希尔排序的性能至关重要。</p>
<ul>
<li><strong>Shell 原始序列</strong>: <code>N/2, N/4, ..., 1</code> (其中 N 是数组大小)。简单但不是最优。</li>
<li><strong>Knuth 序列</strong>: <code>1, 4, 13, 40, ...</code> (通过 <code>h = 3*h + 1</code> 生成)。性能更好，被广泛使用。</li>
<li><strong>Sedgewick 序列</strong>: <code>1, 5, 19, 41, ...</code> (更复杂的公式)。在实践中表现更好。</li>
</ul>
<p>对于教学和基础实现，我们通常使用最简单的 Shell 原始序列。</p>
<h3 id="2-图解示例-6"><a href="#2-图解示例-6" class="headerlink" title="2. 图解示例"></a>2. 图解示例</h3><p>我们用 <code>[8, 3, 1, 7, 0, 10, 2]</code> 这个例子来演示希尔排序的过程。数组长度 <code>n = 7</code>。<br>我们将使用 Shell 原始增量序列。</p>
<p><strong>第一轮：Gap &#x3D; <code>7 // 2 = 3</code></strong></p>
<ul>
<li>我们将数组分为3个子数组：<ul>
<li>子数组1: <code>arr[0]</code>, <code>arr[3]</code>, <code>arr[6]</code> -&gt; <code>[8, 7, 2]</code></li>
<li>子数组2: <code>arr[1]</code>, <code>arr[4]</code> -&gt; <code>[3, 0]</code></li>
<li>子数组3: <code>arr[2]</code>, <code>arr[5]</code> -&gt; <code>[1, 10]</code></li>
</ul>
</li>
<li>对每个子数组进行插入排序：<ul>
<li><code>[8, 7, 2]</code> -&gt; <code>[2, 7, 8]</code></li>
<li><code>[3, 0]</code> -&gt; <code>[0, 3]</code></li>
<li><code>[1, 10]</code> -&gt; <code>[1, 10]</code></li>
</ul>
</li>
<li>将排序后的元素放回原数组的交错位置。<ul>
<li><strong>结果数组</strong>: <code>[2, 0, 1, 7, 3, 10, 8]</code></li>
<li>注意：数组现在比原来更有序了。像 <code>0</code>, <code>1</code>, <code>2</code> 这样的小元素被快速移动到了数组的前端。</li>
</ul>
</li>
</ul>
<p><strong>第二轮：Gap &#x3D; <code>3 // 2 = 1</code></strong></p>
<ul>
<li>现在增量为1，这相当于对整个数组进行一次标准的插入排序。</li>
<li>待排序数组是 <code>[2, 0, 1, 7, 3, 10, 8]</code>。</li>
<li>因为这个数组已经“几乎有序”，插入排序会非常快。<ul>
<li><code>0</code> 会向前移动两位。</li>
<li><code>1</code> 会向前移动一位。</li>
<li><code>3</code> 会向前移动一位。</li>
<li><code>8</code> 会向前移动一位。</li>
</ul>
</li>
<li><strong>最终排序结果</strong>: <code>[0, 1, 2, 3, 7, 8, 10]</code></li>
</ul>
<h3 id="3-Python-代码实现-6"><a href="#3-Python-代码实现-6" class="headerlink" title="3. Python 代码实现"></a>3. Python 代码实现</h3><p>下面是使用 Shell 原始增量序列的 Python 代码实现。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">shell_sort</span>(<span class="params">arr</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    希尔排序函数</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    n = <span class="built_in">len</span>(arr)</span><br><span class="line">    <span class="comment"># 初始增量 gap，并不断缩小</span></span><br><span class="line">    gap = n // <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> gap &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="comment"># 下面的循环是分组后的插入排序</span></span><br><span class="line">        <span class="comment"># i 从 gap 开始，确保每个元素都能作为待插入元素</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(gap, n):</span><br><span class="line">            <span class="comment"># temp 是当前待插入的元素</span></span><br><span class="line">            temp = arr[i]</span><br><span class="line">            <span class="comment"># j 是当前元素所在分组的前一个元素的索引</span></span><br><span class="line">            j = i</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 在当前分组内进行插入排序的比较和移动</span></span><br><span class="line">            <span class="comment"># j &gt;= gap 保证了 j-gap 不会越界</span></span><br><span class="line">            <span class="comment"># arr[j - gap] &gt; temp 是插入排序的核心比较</span></span><br><span class="line">            <span class="keyword">while</span> j &gt;= gap <span class="keyword">and</span> arr[j - gap] &gt; temp:</span><br><span class="line">                arr[j] = arr[j - gap]</span><br><span class="line">                j -= gap</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 将待插入元素放入正确的位置</span></span><br><span class="line">            arr[j] = temp</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 缩小增量</span></span><br><span class="line">        gap //= <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 示例 ---</span></span><br><span class="line">my_list = [<span class="number">8</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="number">2</span>]</span><br><span class="line">shell_sort(my_list)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;排序后的列表:&quot;</span>, my_list)  <span class="comment"># 输出: [0, 1, 2, 3, 7, 8, 10]</span></span><br><span class="line"></span><br><span class="line">another_list = [<span class="number">64</span>, <span class="number">34</span>, <span class="number">25</span>, <span class="number">12</span>, <span class="number">22</span>, <span class="number">11</span>, <span class="number">90</span>]</span><br><span class="line">shell_sort(another_list)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;排序后的列表:&quot;</span>, another_list) <span class="comment"># 输出: [11, 12, 22, 25, 34, 64, 90]</span></span><br></pre></td></tr></table></figure>

<h3 id="4-算法分析-6"><a href="#4-算法分析-6" class="headerlink" title="4. 算法分析"></a>4. 算法分析</h3><ul>
<li><p><strong>时间复杂度</strong>:</p>
<ul>
<li>希尔排序的时间复杂度分析非常复杂，它<strong>完全取决于所选的增量序列</strong>。</li>
<li><strong>最坏情况</strong>: 使用 Shell 原始序列 <code>N/2, N/4, ...</code> 时，最坏时间复杂度为 <code>O(n²)</code>。</li>
<li><strong>平均&#x2F;最好情况</strong>: 使用更优的增量序列（如 Knuth 序列），其时间复杂度可以达到 <code>O(n^(3/2))</code> 甚至 <code>O(n log² n)</code>。它优于简单的 <code>O(n²)</code> 排序算法，但劣于 <code>O(n log n)</code> 的高级排序算法。</li>
</ul>
</li>
<li><p><strong>空间复杂度</strong>: <code>O(1)</code>。</p>
<ul>
<li>希尔排序是<strong>原地排序</strong>算法，只需要一个额外的变量 <code>temp</code> 来存储元素，空间是常数级别的。</li>
</ul>
</li>
<li><p><strong>稳定性</strong>: 希尔排序是<strong>不稳定</strong>的。</p>
<ul>
<li><strong>解释</strong>：在分组排序中，相隔较远的两个相等元素可能会在它们各自的子数组中被交换，从而导致它们的相对顺序发生改变。例如，在 <code>[5a, 1, 5b]</code> 中，如果 <code>gap=2</code>，<code>5a</code> 和 <code>5b</code> 在同一个子数组，它们的顺序可能不会变。但如果 <code>gap=1</code> 之前有其他 <code>gap</code> 使得 <code>5b</code> 被交换到了 <code>5a</code> 前面，稳定性就被破坏了。</li>
</ul>
</li>
</ul>
<h3 id="5-小结-5"><a href="#5-小结-5" class="headerlink" title="5. 小结"></a>5. 小结</h3><p><strong>优点</strong>:</p>
<ul>
<li><strong>性能优于简单排序</strong>：比冒泡排序、选择排序和插入排序等 <code>O(n²)</code> 算法要快得多。</li>
<li><strong>实现相对简单</strong>：相比快速排序、归并排序等，代码实现逻辑更简单一些。</li>
<li><strong>空间效率高</strong>：是原地排序，只需要 <code>O(1)</code> 的额外空间。</li>
</ul>
<p><strong>缺点</strong>:</p>
<ul>
<li><strong>性能不稳定</strong>：时间复杂度依赖于增量序列，难以精确分析。</li>
<li><strong>算法不稳定</strong>：不保证相等元素的相对顺序。</li>
<li><strong>性能瓶颈</strong>：对于大规模数据，其性能不如快速排序、归并排序和堆排序等 <code>O(n log n)</code> 算法。</li>
</ul>
<p>总的来说，希尔排序是一种在简单排序和高级排序之间的“中间地带”算法，适用于中等规模的数据集，并且在对内存要求严格的场景下有一定优势。</p>
<hr>
<h2 id="八、计数排序"><a href="#八、计数排序" class="headerlink" title="八、计数排序"></a>八、计数排序</h2><h3 id="1-什么是计数排序？"><a href="#1-什么是计数排序？" class="headerlink" title="1. 什么是计数排序？"></a>1. 什么是计数排序？</h3><p>计数排序是一种<strong>非比较型</strong>的整数排序算法，它的核心思想与我们之前讨论的比较排序算法（如快速排序、归并排序）完全不同。它不是通过比较元素大小来排序，而是通过<strong>统计每个整数出现的次数</strong>来确定元素的位置。</p>
<p>这个算法的效率非常高，可以达到线性时间复杂度 <code>O(n)</code>，但它有一个重要的<strong>限制</strong>：它只适用于<strong>整数</strong>，并且这些整数需要在一个<strong>相对较小的范围</strong>内。</p>
<h4 id="a-核心思想-4"><a href="#a-核心思想-4" class="headerlink" title="a. 核心思想"></a>a. 核心思想</h4><ol>
<li><strong>计数 (Counting)</strong>：找出待排序数组中最大和最小的元素，然后创建一个“计数数组”（或称为“桶”），其大小足以覆盖从最小到最大的整个整数范围。遍历待排序数组，将每个元素出现的次数记录在计数数组的相应位置上。</li>
<li><strong>累加 (Cumulative Sum)</strong>：修改计数数组，使其每个位置上的值是“小于或等于”该索引的元素总数。这样，计数数组就存储了每个元素在排序后应该出现的<strong>最终位置</strong>信息。</li>
<li><strong>排序 (Placing)</strong>：创建一个新的输出数组。<strong>反向遍历</strong>原始的待排序数组，根据计数数组中的位置信息，将每个元素直接放入输出数组的正确位置，同时更新计数数组中的计数值。</li>
</ol>
<hr>
<h3 id="2-图解示例-7"><a href="#2-图解示例-7" class="headerlink" title="2. 图解示例"></a>2. 图解示例</h3><p>我们用一个简单的例子 <code>[4, 2, 2, 8, 3, 3, 1]</code> 来演示计数排序的过程。</p>
<p><strong>1. 找出范围并创建计数数组</strong></p>
<ul>
<li>数组中的最大值是 <code>8</code>。</li>
<li>创建一个大小为 <code>8 + 1 = 9</code> 的计数数组 <code>count_arr</code>，索引从 0 到 8，初始值全为 0。<br><code>count_arr = [0, 0, 0, 0, 0, 0, 0, 0, 0]</code></li>
</ul>
<p><strong>2. 统计元素出现次数</strong></p>
<ul>
<li>遍历原始数组 <code>[4, 2, 2, 8, 3, 3, 1]</code>：<ul>
<li>遇到 <code>4</code>，<code>count_arr[4]</code> 加 1。</li>
<li>遇到 <code>2</code>，<code>count_arr[2]</code> 加 1。</li>
<li>…</li>
</ul>
</li>
<li>最终得到的计数数组为：<br><code>count_arr = [0, 1, 2, 2, 1, 0, 0, 0, 1]</code><br>(含义：数字1出现1次，2出现2次，3出现2次，4出现1次，8出现1次)</li>
</ul>
<p><strong>3. 计算累加和</strong></p>
<ul>
<li>修改 <code>count_arr</code>，让每个位置存储小于等于当前索引的元素总数。<ul>
<li><code>count_arr[1] += count_arr[0]</code> -&gt; <code>1 + 0 = 1</code></li>
<li><code>count_arr[2] += count_arr[1]</code> -&gt; <code>2 + 1 = 3</code></li>
<li><code>count_arr[3] += count_arr[2]</code> -&gt; <code>2 + 3 = 5</code></li>
<li><code>count_arr[4] += count_arr[3]</code> -&gt; <code>1 + 5 = 6</code></li>
<li>…</li>
</ul>
</li>
<li>最终得到的累加数组为：<br><code>count_arr = [0, 1, 3, 5, 6, 6, 6, 6, 7]</code><br>(含义：小于等于1的数有1个，小于等于2的数有3个，小于等于3的数有5个… 这个值减1就是该数字在排序后数组中的最后一次出现的位置索引)</li>
</ul>
<p><strong>4. 放置到输出数组 (反向遍历)</strong></p>
<ul>
<li><p>创建一个与原始数组等长的输出数组 <code>output_arr</code>。</p>
</li>
<li><p><strong>从后向前</strong>遍历原始数组 <code>[4, 2, 2, 8, 3, 3, 1]</code>：</p>
<ul>
<li><strong>元素 <code>1</code></strong>: <code>count_arr[1]</code> 是 <code>1</code>。将 <code>1</code> 放到 <code>output_arr</code> 的 <code>1-1=0</code> 索引处。然后 <code>count_arr[1]</code> 减 1。<br><code>output = [1, _, _, _, _, _, _]</code>, <code>count_arr[1]=0</code></li>
<li><strong>元素 <code>3</code> (第二个)</strong>: <code>count_arr[3]</code> 是 <code>5</code>。将 <code>3</code> 放到 <code>output_arr</code> 的 <code>5-1=4</code> 索引处。<code>count_arr[3]</code> 减 1。<br><code>output = [1, _, _, _, 3, _, _]</code>, <code>count_arr[3]=4</code></li>
<li><strong>元素 <code>3</code> (第一个)</strong>: <code>count_arr[3]</code> 是 <code>4</code>。将 <code>3</code> 放到 <code>output_arr</code> 的 <code>4-1=3</code> 索引处。<code>count_arr[3]</code> 减 1。<br><code>output = [1, _, _, 3, 3, _, _]</code>, <code>count_arr[3]=3</code></li>
<li><strong>元素 <code>8</code></strong>: <code>count_arr[8]</code> 是 <code>7</code>。将 <code>8</code> 放到 <code>output_arr</code> 的 <code>7-1=6</code> 索引处。<code>count_arr[8]</code> 减 1。<br><code>output = [1, _, _, 3, 3, _, 8]</code>, <code>count_arr[8]=6</code></li>
<li>… 以此类推 …</li>
</ul>
</li>
<li><p><strong>最终排序结果</strong>: <code>[1, 2, 2, 3, 3, 4, 8]</code></p>
</li>
</ul>
<p><strong>为什么要反向遍历？</strong><br>反向遍历是为了保证排序的<strong>稳定性</strong>。当遇到重复元素时（如两个3），原始数组中排在后面的<code>3</code>会先被放入输出数组的靠后位置，这样它们的相对顺序就保持不变了。</p>
<hr>
<h3 id="3-Python-代码实现-7"><a href="#3-Python-代码实现-7" class="headerlink" title="3. Python 代码实现"></a>3. Python 代码实现</h3><p>下面提供了两个版本的实现：一个基础版（只处理非负整数）和一个更通用的优化版（处理任意整数范围）。</p>
<h4 id="a-基础版-处理非负整数"><a href="#a-基础版-处理非负整数" class="headerlink" title="a. 基础版 (处理非负整数)"></a>a. 基础版 (处理非负整数)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">counting_sort_basic</span>(<span class="params">arr</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    计数排序基础版（只适用于非负整数）</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 1. 处理边界情况</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(arr) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. 找到最大值以确定计数数组的大小</span></span><br><span class="line">    max_val = <span class="built_in">max</span>(arr)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 3. 创建并填充计数数组</span></span><br><span class="line">    count_arr = [<span class="number">0</span>] * (max_val + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> arr:</span><br><span class="line">        count_arr[num] += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 4. 计算累加和</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(count_arr)):</span><br><span class="line">        count_arr[i] += count_arr[i-<span class="number">1</span>]</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 5. 创建输出数组并从后向前遍历原数组以放置元素</span></span><br><span class="line">    output_arr = [<span class="number">0</span>] * <span class="built_in">len</span>(arr)</span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> <span class="built_in">reversed</span>(arr):</span><br><span class="line">        <span class="comment"># 找到 num 在排序后应该在的位置</span></span><br><span class="line">        position = count_arr[num] - <span class="number">1</span></span><br><span class="line">        output_arr[position] = num</span><br><span class="line">        <span class="comment"># 处理重复数字，将下一个同样值的数字放在前一个位置</span></span><br><span class="line">        count_arr[num] -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> output_arr</span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 示例 ---</span></span><br><span class="line">my_list = [<span class="number">4</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>]</span><br><span class="line">sorted_list = counting_sort_basic(my_list)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;基础版排序后的列表:&quot;</span>, sorted_list) <span class="comment"># 输出: [1, 2, 2, 3, 3, 4, 8]</span></span><br></pre></td></tr></table></figure>

<h4 id="b-优化版-处理任意整数范围，包括负数"><a href="#b-优化版-处理任意整数范围，包括负数" class="headerlink" title="b. 优化版 (处理任意整数范围，包括负数)"></a>b. 优化版 (处理任意整数范围，包括负数)</h4><p>这个版本通过引入偏移量（<code>offset</code>）来处理负数或不从0开始的整数范围，从而节省空间。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">counting_sort_optimized</span>(<span class="params">arr</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    计数排序优化版（适用于任意整数范围）</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(arr) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 1. 找到最大值和最小值以确定范围</span></span><br><span class="line">    max_val = <span class="built_in">max</span>(arr)</span><br><span class="line">    min_val = <span class="built_in">min</span>(arr)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 2. 创建计数数组，大小为 (max - min + 1)</span></span><br><span class="line">    <span class="comment">#    offset 用于将原始数值映射到计数数组的索引 (0, 1, 2...)</span></span><br><span class="line">    offset = min_val</span><br><span class="line">    count_arr_size = max_val - min_val + <span class="number">1</span></span><br><span class="line">    count_arr = [<span class="number">0</span>] * count_arr_size</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 3. 填充计数数组</span></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> arr:</span><br><span class="line">        count_arr[num - offset] += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 4. 计算累加和</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, count_arr_size):</span><br><span class="line">        count_arr[i] += count_arr[i-<span class="number">1</span>]</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 5. 创建输出数组并放置元素</span></span><br><span class="line">    output_arr = [<span class="number">0</span>] * <span class="built_in">len</span>(arr)</span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> <span class="built_in">reversed</span>(arr):</span><br><span class="line">        position = count_arr[num - offset] - <span class="number">1</span></span><br><span class="line">        output_arr[position] = num</span><br><span class="line">        count_arr[num - offset] -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> output_arr</span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 示例 ---</span></span><br><span class="line">my_list_neg = [-<span class="number">5</span>, <span class="number">5</span>, -<span class="number">9</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">sorted_list_neg = counting_sort_optimized(my_list_neg)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;优化版排序后的列表:&quot;</span>, sorted_list_neg) <span class="comment"># 输出: [-9, -5, 0, 1, 1, 5, 10]</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-算法分析-7"><a href="#4-算法分析-7" class="headerlink" title="4. 算法分析"></a>4. 算法分析</h3><ul>
<li><p><strong>时间复杂度</strong>: <code>O(n + k)</code></p>
<ul>
<li><code>n</code> 是待排序数组的元素个数。</li>
<li><code>k</code> 是整数的范围（即 <code>max_val - min_val + 1</code>）。</li>
<li>整个过程包括几次对大小为 <code>n</code> 或 <code>k</code> 的数组的线性扫描，所以是 <code>O(n + k)</code>。</li>
<li>当 <code>k</code> 的大小与 <code>n</code> 相当或更小时（<code>k = O(n)</code>），时间复杂度可以看作是<strong>线性时间 <code>O(n)</code></strong>，这比任何基于比较的排序算法 <code>O(n log n)</code> 都要快。</li>
</ul>
</li>
<li><p><strong>空间复杂度</strong>: <code>O(n + k)</code></p>
<ul>
<li>需要一个大小为 <code>k</code> 的 <code>count_arr</code> 和一个大小为 <code>n</code> 的 <code>output_arr</code>。</li>
</ul>
</li>
<li><p><strong>稳定性</strong>: 计数排序是<strong>稳定</strong>的，前提是正确实现（即在构建输出数组时反向遍历原始数组）。</p>
</li>
</ul>
<h3 id="5-小结-6"><a href="#5-小结-6" class="headerlink" title="5. 小结"></a>5. 小结</h3><p><strong>优点</strong>:</p>
<ul>
<li><strong>速度极快</strong>：在特定条件下，它是最快的排序算法之一。</li>
<li><strong>稳定性</strong>：是一种稳定的排序算法。</li>
</ul>
<p><strong>缺点</strong>:</p>
<ul>
<li><strong>适用范围窄</strong>：只能用于整数排序。</li>
<li><strong>空间浪费</strong>：当整数范围 <code>k</code> 远大于元素数量 <code>n</code> 时（例如，排序 <code>[1, 10, 1000000]</code>），会造成巨大的空间浪费，此时性能会急剧下降。</li>
</ul>
<p>因此，计数排序是一种非常特殊的、在特定场景下极为高效的算法，常被用作更复杂算法（如基数排序）的子过程。</p>
<hr>
<h2 id="九、总结"><a href="#九、总结" class="headerlink" title="九、总结"></a>九、总结</h2><h3 id="1-主流排序算法综合对比表"><a href="#1-主流排序算法综合对比表" class="headerlink" title="1. 主流排序算法综合对比表"></a>1. 主流排序算法综合对比表</h3><table>
<thead>
<tr>
<th align="left">特性 &#x2F; 算法</th>
<th align="left">冒泡排序 (Bubble)</th>
<th align="left">选择排序 (Selection)</th>
<th align="left">插入排序 (Insertion)</th>
<th align="left">希尔排序 (Shell)</th>
<th align="left">归并排序 (Merge)</th>
<th align="left">快速排序 (Quick)</th>
<th align="left">堆排序 (Heap)</th>
<th align="left">计数排序 (Counting)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>时间复杂度 (平均)</strong></td>
<td align="left"><strong>O(n²)</strong></td>
<td align="left"><strong>O(n²)</strong></td>
<td align="left"><strong>O(n²)</strong></td>
<td align="left">O(n log n) ~ O(n²) ¹</td>
<td align="left"><strong>O(n log n)</strong></td>
<td align="left"><strong>O(n log n)</strong></td>
<td align="left"><strong>O(n log n)</strong></td>
<td align="left"><strong>O(n + k)</strong> ²</td>
</tr>
<tr>
<td align="left"><strong>时间复杂度 (最坏)</strong></td>
<td align="left">O(n²)</td>
<td align="left">O(n²)</td>
<td align="left">O(n²)</td>
<td align="left">O(n²) (取决于增量)</td>
<td align="left">O(n log n)</td>
<td align="left">O(n²) (需优化避免)</td>
<td align="left">O(n log n)</td>
<td align="left">O(n + k)</td>
</tr>
<tr>
<td align="left"><strong>时间复杂度 (最好)</strong></td>
<td align="left">O(n) (优化后)</td>
<td align="left">O(n²)</td>
<td align="left">O(n)</td>
<td align="left">O(n log n)</td>
<td align="left">O(n log n)</td>
<td align="left">O(n log n)</td>
<td align="left">O(n log n)</td>
<td align="left">O(n + k)</td>
</tr>
<tr>
<td align="left"><strong>空间复杂度</strong></td>
<td align="left"><strong>O(1)</strong></td>
<td align="left"><strong>O(1)</strong></td>
<td align="left"><strong>O(1)</strong></td>
<td align="left"><strong>O(1)</strong></td>
<td align="left"><strong>O(n)</strong></td>
<td align="left"><strong>O(log n)</strong> (平均)</td>
<td align="left"><strong>O(1)</strong></td>
<td align="left"><strong>O(n + k)</strong></td>
</tr>
<tr>
<td align="left"><strong>稳定性</strong></td>
<td align="left"><strong>稳定</strong></td>
<td align="left"><strong>不稳定</strong></td>
<td align="left"><strong>稳定</strong></td>
<td align="left"><strong>不稳定</strong></td>
<td align="left"><strong>稳定</strong></td>
<td align="left"><strong>不稳定</strong></td>
<td align="left"><strong>不稳定</strong></td>
<td align="left"><strong>稳定</strong></td>
</tr>
<tr>
<td align="left"><strong>排序方式</strong></td>
<td align="left">In-place (原地)</td>
<td align="left">In-place (原地)</td>
<td align="left">In-place (原地)</td>
<td align="left">In-place (原地)</td>
<td align="left">Out-of-place (非原地)</td>
<td align="left">In-place (原地)</td>
<td align="left">In-place (原地)</td>
<td align="left">Out-of-place (非原地)</td>
</tr>
<tr>
<td align="left"><strong>算法类型</strong></td>
<td align="left">比较排序</td>
<td align="left">比较排序</td>
<td align="left">比较排序</td>
<td align="left">比较排序</td>
<td align="left">比较排序 (分治)</td>
<td align="left">比较排序 (分治)</td>
<td align="left">比较排序 (选择)</td>
<td align="left"><strong>非比较排序</strong></td>
</tr>
<tr>
<td align="left"><strong>核心思想</strong></td>
<td align="left">相邻元素比较交换，最大值“冒泡”到末尾</td>
<td align="left">每次从未排序部分找最小元素放到已排序末尾</td>
<td align="left">将元素插入到已排序序列的正确位置</td>
<td align="left">分组的插入排序，逐步缩小增量</td>
<td align="left">分解成小数组，排序后合并</td>
<td align="left">选定基准，分区后递归排序</td>
<td align="left">构建最大堆，将堆顶与末尾交换并调整</td>
<td align="left">统计每个元素出现的次数来确定位置</td>
</tr>
<tr>
<td align="left"><strong>主要优点</strong></td>
<td align="left">实现简单，易于理解</td>
<td align="left">实现简单，交换次数少</td>
<td align="left">对小规模或几乎有序的数据效率高</td>
<td align="left">比 O(n²) 算法快，且为原地排序</td>
<td align="left">性能极为稳定，适用于链表和外部排序</td>
<td align="left"><strong>平均速度最快</strong>，常数因子小，原地排序</td>
<td align="left">保证 O(n log n) 最坏性能且为原地排序</td>
<td align="left"><strong>速度极快</strong>，可达线性时间</td>
</tr>
<tr>
<td align="left"><strong>主要缺点</strong></td>
<td align="left"><strong>效率极低</strong>，实际中不使用</td>
<td align="left"><strong>效率极低</strong>，无法利用数据初始顺序</td>
<td align="left">对大规模乱序数据效率低</td>
<td align="left">性能依赖增量序列，不稳定</td>
<td align="left">需要 O(n) 额外空间</td>
<td align="left">最坏情况性能差 (O(n²))，不稳定</td>
<td align="left">实际平均性能常数因子大于快速排序，不稳定</td>
<td align="left"><strong>适用范围窄</strong> (整数且范围k不能太大)，空间开销大</td>
</tr>
<tr>
<td align="left"><strong>适用场景</strong></td>
<td align="left">教学演示</td>
<td align="left">教学演示，或当数据交换成本极高时</td>
<td align="left">数据量小，或数据基本有序</td>
<td align="left">中等规模数据集，对内存要求严格</td>
<td align="left">内存充裕，需要稳定排序或处理外部数据</td>
<td align="left"><strong>通用场景</strong>，大多数情况下的首选</td>
<td align="left">需要可靠性能保证和低空间占用的场景</td>
<td align="left">整数排序，且数据范围 k 不比 n 大很多</td>
</tr>
</tbody></table>
<h3 id="2-表格注解与总结"><a href="#2-表格注解与总结" class="headerlink" title="2. 表格注解与总结"></a>2. 表格注解与总结</h3><p>¹ <strong>希尔排序的复杂度</strong>: 它的时间复杂度与所选的“增量序列”密切相关，分析非常复杂。虽然其最坏情况是 O(n²)，但在良好增量序列下，其性能远超一般 O(n²) 算法，接近 O(n log n)。</p>
<p>² <strong>k 的含义</strong>: 在计数排序中，<code>k</code> 代表待排序数据中最大值与最小值之差，即 <code>max(arr) - min(arr)</code>。</p>
<h3 id="3-如何选择排序算法？"><a href="#3-如何选择排序算法？" class="headerlink" title="3. 如何选择排序算法？"></a>3. 如何选择排序算法？</h3><ul>
<li><strong>追求极致性能，且不要求稳定性</strong>：<strong>快速排序</strong>通常是首选。现代编程语言的内置排序函数（如 Python 的 <code>sort()</code>）通常是基于快速排序的变体（如 IntroSort）或结合了多种排序思想的混合算法（如 Timsort）。</li>
<li><strong>需要稳定的排序结果</strong>：<strong>归并排序</strong>是最佳选择。例如，当你需要按多个字段排序时（先按年龄排，年龄相同时保持原始顺序），稳定性至关重要。</li>
<li><strong>关心最坏情况的性能和内存占用</strong>：<strong>堆排序</strong>能提供 O(n log n) 的最坏情况时间保证和 O(1) 的空间复杂度，非常可靠。</li>
<li><strong>数据规模非常小，或基本有序</strong>：<strong>插入排序</strong>的简单性和高效性使其成为理想选择。这也是 Timsort 等高级算法在处理小数据块时会切换到插入排序的原因。</li>
<li><strong>排序的是整数且范围不大</strong>：<strong>计数排序</strong>可以提供无与伦比的线性时间性能。它是基数排序等更复杂算法的基础。</li>
<li><strong>教学或理解算法思想</strong>：<strong>冒泡排序</strong>和<strong>选择排序</strong>虽然效率低下，但它们的逻辑简单直观，是学习排序算法的绝佳起点。</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://lx-cel.github.io">秋风、萧瑟</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://lx-cel.github.io/2025/08/22/%E5%9F%BA%E6%9C%AC%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/">https://lx-cel.github.io/2025/08/22/基本排序算法/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://lx-cel.github.io" target="_blank">星海流光</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a></div><div class="post-share"><div class="social-share" data-image="/img/29.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/08/27/CPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E5%9B%9B%E7%A7%8D%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/" title="CPP学习笔记—四种强制类型转换"><img class="cover" src="/img/30.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">CPP学习笔记—四种强制类型转换</div></div><div class="info-2"><div class="info-item-1">C++中的四种强制类型转换：static_cast、dynamic_cast、const_cast 和 reinterpret_cast。 为什么需要新的类型转换？在C++之前，C语言使用一种通用的强制类型转换语法，例如 (new_type)expression 或 new_type(expression)。这种C风格的转换方式存在几个问题：  过于粗暴：它可以在任何类型之间进行转换，无论是相关的还是不相关的，这使得它非常不安全。 意图不明：从语法上无法清晰地看出程序员想要做什么样的转换（例如，是移除const、进行继承体系中的转换，还是进行底层的位模式重新解释）。 难以搜索：在代码库中搜索 ( 符号来定位所有的类型转换是非常困难的，不利于代码审查和维护。  为了解决这些问题，C++引入了四个功能更明确、更安全的命名转换操作符。它们让代码的意图更加清晰，并允许编译器进行更严格的检查。  1. static_caststatic_cast...</div></div></div></a><a class="pagination-related" href="/2025/08/21/%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E5%AF%B9%E6%AF%94%E2%80%94UART-SPI-IIC/" title="通信方式对比—UART/SPI/IIC"><img class="cover" src="/img/28.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">通信方式对比—UART/SPI/IIC</div></div><div class="info-2"><div class="info-item-1">一、UARTUART（Universal Asynchronous Receiver&#x2F;Transmitter，通用异步收发器）是一种非常基础且广泛使用的串行通信协议。它不是像SPI或I²C那样的“总线”，而通常是一种点对点的通信方式。几乎所有的微控制器和计算机都包含UART硬件，它也是我们最常接触到的调试接口（例如通过USB转串口模块在电脑上查看单片机的打印信息）。  1. UART的核心概念 通用（Universal）: 意味着它的通信参数（如速度、数据位、校验位等）是可配置的，可以与各种不同的设备进行通信。 异步（Asynchronous）: 这是UART最核心的特点。与SPI和I²C不同，UART通信的双方没有共享的时钟线。发送方和接收方必须事先约定好相同的通信速率（波特率），接收方依靠数据信号本身的变化（起始位）来开始同步并按约定的速率接收数据。 收发器（Receiver&#x2F;Transmitter）: UART硬件模块通常包含一个独立的接收器和一个独立的发送器，因此可以同时进行数据的接收和发送，实现 全双工（Full-Duplex） 通信。   2....</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/07/28/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/" title="二分查找"><img class="cover" src="/img/23.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-28</div><div class="info-item-2">二分查找</div></div><div class="info-2"><div class="info-item-1">二分法是一种较为简单通用的搜索算法，但是在实际动手写时，却经常因为细节问题导致无法一次性写对，这里整理出了现代二分法的最佳实践写法，即红蓝染色&#x2F;边界搜索算法，理解该方法后对于各种二分变种问题都能一次写对。  1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&quot;&quot;&quot;题目描述：给定数组nums = [1, 3, 6, 6, 6, 12, 16, 19, 20]target = 6若数组中包含target，则返回数组下标，否则返回-1&quot;&quot;&quot;# 采用红蓝染色/边界查找法，现代二分法的最佳实践def binary_search_lower_bound(nums, target):    &quot;&quot;&quot;lower_bound问题的二分搜索写法&quot;&quot;&quot;    left, right = -1, len(nums)   ...</div></div></div></a><a class="pagination-related" href="/2025/01/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%952%E2%80%94%E6%95%B0%E7%BB%84/" title="数据结构与算法2—数组"><img class="cover" src="/img/13.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-07</div><div class="info-item-2">数据结构与算法2—数组</div></div><div class="info-2"><div class="info-item-1">数组是一种常见的线性数据结构，其将相同类型的元素存储在连续的内存空间中，我们将元素在数组中的位置称为该元素的索引。 1. 数组的常用操作1.1 初始化数组初始化数组时，我们可以根据需求选用数组的两种初始化方式：无初始值、给定初始值。在未指定初始值的情况下，大多数编程语言会将数组元素初始化为0，但是经过实测，C++和C在数组为初始化时，大多数情况下不会将数组初始化为0，特别是使用new或malloc创建动态数组时数组元素都是随机值，因此在C++和C中建议创建完数组后就立刻将其初始化： 123456789101112/* 初始化数组arr */// 将数组存储在栈上int size = 5;int arr[5] = &#123;0&#125;;printf(&quot;数组 arr = &quot;);printArray(arr, 5);/* 初始化数组nums */// 将数组存储在栈上int nums[5] = &#123;1, 2, 3, 4, 5&#125;;printf(&quot;数组 nums = &quot;);printArray(nums,...</div></div></div></a><a class="pagination-related" href="/2025/05/29/%E5%9B%9E%E6%BA%AF/" title="回溯"><img class="cover" src="/img/17.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-05-29</div><div class="info-item-2">回溯</div></div><div class="info-2"><div class="info-item-1">回溯算法（backtracking algorithm）是一种通过穷举来解决问题的办法，其本质是一种暴力搜索算法。它的核心思想是从一个初始状态出发，暴力搜索所有可能遇到的解决方案，当遇到正确的解则将其记录，直到找到解或尝试了所有可能的选择都无法找到解为止。 框架1234567891011121314151617def backtrack(state: State, choices: list[choice], res: list[state]):    &quot;&quot;&quot;回溯算法框架&quot;&quot;&quot;    # 判断是否为解    if is_solution(state):        # 记录解        record_solution(state, res)        # 不再继续搜索        return    # 遍历所有选择    for choice in choices:        # 剪枝：判断选择是否合法        if is_valid(state, choice):            #...</div></div></div></a><a class="pagination-related" href="/2025/01/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%954%E2%80%94%E5%88%97%E8%A1%A8/" title="数据结构与算法4—列表"><img class="cover" src="/img/15.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-08</div><div class="info-item-2">数据结构与算法4—列表</div></div><div class="info-2"><div class="info-item-1">列表（list）是一个抽象的数据结构概念，表示元素的有序集合，支持元素访问、修改、添加、删除和遍历等操作，无需使用者考虑容量限制的问题。列表可以基于链表或数组实现。  链表天然可以看作一个列表，其支持元素增删改查操作，并且可以灵活动态扩容。 数组也支持元素增删改查，但由于其长度不可变，因此只能看作一个具有长度限制的列表。  由于数组不具备扩展长度的能力，因此可以使用动态数组来实现列表。它继承了数组的各项优点，并且可以在程序运行过程中进行动态扩容。 许多编程语言中的标准库提供的列表是基于动态数组实现的，例如Python中的list、Java中的ArrayList、C++中的vector和C#中的List等。通常，将列表和动态数组视为等同的概念。 1. 列表常用操作1.1 初始化列表列表的初始化可以采用“无初始值”和“有初始值”这两种初始化方法： 12345/* 初始化列表 */// 无初始值vector&lt;int&gt; nums1;// 有初始值vector&lt;int&gt; nums = &#123; 1, 3, 2, 5, 4 &#125;; 1.2...</div></div></div></a><a class="pagination-related" href="/2025/09/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/" title="数据结构与算法—树状数组"><img class="cover" src="/img/35.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-06</div><div class="info-item-2">数据结构与算法—树状数组</div></div><div class="info-2"><div class="info-item-1">1. 树状数组是什么？为什么需要它？想象一个场景：你有一个数组 a，需要频繁地做两件事：  修改数组中某个元素的值。 查询数组中任意一个区间的和（例如，从索引 l 到 r 的所有元素之和）。  我们可以用一些朴素的方法来解决：  普通数组： 修改元素：O(1)，非常快。 查询区间和：O(n)，需要遍历区间，如果查询次数很多，会非常慢。   前缀和数组： 我们预处理一个 preSum 数组，preSum[i] = a[1] + ... + a[i]。 查询区间和 [l, r]：O(1)，只需计算 preSum[r] - preSum[l-1]，非常快。 修改元素 a[i]：O(n)，因为 a[i] 的改变会影响到 preSum[i] 及之后的所有元素，你需要更新 preSum[i], preSum[i+1], ..., preSum[n]，非常慢。    可以看到，这两种方法在“修改”和“查询”上都有一个操作是 O(n) 的，无法同时做到高效。 树状数组 (Fenwick Tree) 就是为了解决这个问题而生的。它是一种巧妙的数据结构，可以在 O(log n) 的时间复杂度内完成...</div></div></div></a><a class="pagination-related" href="/2025/01/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%951%E2%80%94%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%A4%8D%E6%9D%82%E5%BA%A6/" title="数据结构与算法1—基本概念与复杂度"><img class="cover" src="/img/12.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-06</div><div class="info-item-2">数据结构与算法1—基本概念与复杂度</div></div><div class="info-2"><div class="info-item-1">1. 算法的定义算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。 2. 算法的特性算法具有五个基本特性：输入、输出、有穷性、确定性和可行性。 2.1 输入输出算法通常具有零个或多个输入，但至少有一个或多个输出。输出的形式可以是打印输出，也可以是返回一个或多个值。 2.2 有穷性有穷性指算法在执行有限的步骤之后，自动结束而不会出现无限循环，并且每一个步骤在可接受的时间内完成。 2.3 确定性确定性指算法的每一步骤都具有确定的含义，不会出现二义性。 2.4 可行性可行性指算法的每一步都必须是可行的，也就是说每一步都能够执行有限次数完成。可行性意味着算法可以转化为程序上机运行，并得到正确的结果。 3. 算法设计的要求算法设计的要求包括正确性、可读性、健壮性、高效率和低内存需求。 3.1...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="giscus-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/Cecilia.jpeg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">秋风、萧瑟</div><div class="author-info-description">梦想是用技术创造一个美好的世界</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">50</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">本站于2024年12月25日正式上线,博客内容主要是记录个人学习和技术分享,也欢迎技术交流!!!</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-text">一、冒泡排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%EF%BC%9F"><span class="toc-text">1. 什么是冒泡排序？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#a-%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3"><span class="toc-text">a. 核心思想</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#b-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">b. 工作原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%9B%BE%E8%A7%A3%E7%A4%BA%E4%BE%8B"><span class="toc-text">2. 图解示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Python-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text">3. Python 代码实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#a-%E5%9F%BA%E7%A1%80%E7%89%88%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-text">a. 基础版冒泡排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#b-%E4%BC%98%E5%8C%96%E7%89%88%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-text">b. 优化版冒泡排序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90"><span class="toc-text">4. 算法分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%B0%8F%E7%BB%93"><span class="toc-text">5. 小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-text">二、选择排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%EF%BC%9F"><span class="toc-text">1. 什么是选择排序？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#a-%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3-1"><span class="toc-text">a. 核心思想</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#b-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-1"><span class="toc-text">b. 工作原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%9B%BE%E8%A7%A3%E7%A4%BA%E4%BE%8B-1"><span class="toc-text">2. 图解示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Python-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-1"><span class="toc-text">3. Python 代码实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90-1"><span class="toc-text">4. 算法分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%B0%8F%E7%BB%93-1"><span class="toc-text">5. 小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-text">三、插入排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%EF%BC%9F"><span class="toc-text">1. 什么是插入排序？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#a-%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3-2"><span class="toc-text">a. 核心思想</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#b-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-2"><span class="toc-text">b. 工作原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%9B%BE%E8%A7%A3%E7%A4%BA%E4%BE%8B-2"><span class="toc-text">2. 图解示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Python-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-2"><span class="toc-text">3. Python 代码实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90-2"><span class="toc-text">4. 算法分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%B0%8F%E7%BB%93-2"><span class="toc-text">5. 小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-text">四、快速排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%EF%BC%9F"><span class="toc-text">1. 什么是快速排序？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#a-%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3-%E5%88%86%E6%B2%BB%E6%B3%95"><span class="toc-text">a. 核心思想 (分治法)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#b-%E5%88%86%E5%8C%BA%EF%BC%88Partition%EF%BC%89%E6%93%8D%E4%BD%9C%E6%98%AF%E5%85%B3%E9%94%AE"><span class="toc-text">b. 分区（Partition）操作是关键</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%9B%BE%E8%A7%A3%E7%A4%BA%E4%BE%8B-3"><span class="toc-text">2. 图解示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Python-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-3"><span class="toc-text">3. Python 代码实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90-3"><span class="toc-text">4. 算法分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E4%BC%98%E5%8C%96"><span class="toc-text">5. 优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%B0%8F%E7%BB%93"><span class="toc-text">6. 小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-text">五、归并排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%EF%BC%9F"><span class="toc-text">1. 什么是归并排序？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#a-%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3-%E5%88%86%E6%B2%BB%E6%B3%95-1"><span class="toc-text">a. 核心思想 (分治法)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#b-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-3"><span class="toc-text">b. 工作原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%9B%BE%E8%A7%A3%E7%A4%BA%E4%BE%8B-4"><span class="toc-text">2. 图解示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Python-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-4"><span class="toc-text">3. Python 代码实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90-4"><span class="toc-text">4. 算法分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%B0%8F%E7%BB%93-3"><span class="toc-text">5. 小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="toc-text">六、堆排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E5%A0%86%E6%8E%92%E5%BA%8F%EF%BC%9F"><span class="toc-text">1. 什么是堆排序？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#a-%E6%A0%B8%E5%BF%83%E5%89%8D%E6%8F%90%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AF%E5%A0%86%EF%BC%88Heap%EF%BC%89%EF%BC%9F"><span class="toc-text">a. 核心前提：什么是堆（Heap）？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#b-%E5%A0%86%E6%8E%92%E5%BA%8F%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">b. 堆排序的工作原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%9B%BE%E8%A7%A3%E7%A4%BA%E4%BE%8B-5"><span class="toc-text">2. 图解示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Python-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-5"><span class="toc-text">3. Python 代码实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90-5"><span class="toc-text">4. 算法分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%B0%8F%E7%BB%93-4"><span class="toc-text">5. 小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F"><span class="toc-text">七、希尔排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%EF%BC%9F"><span class="toc-text">1. 什么是希尔排序？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#a-%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3-3"><span class="toc-text">a. 核心思想</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#b-%E5%A2%9E%E9%87%8F%E5%BA%8F%E5%88%97%E7%9A%84%E9%80%89%E6%8B%A9"><span class="toc-text">b. 增量序列的选择</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%9B%BE%E8%A7%A3%E7%A4%BA%E4%BE%8B-6"><span class="toc-text">2. 图解示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Python-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-6"><span class="toc-text">3. Python 代码实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90-6"><span class="toc-text">4. 算法分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%B0%8F%E7%BB%93-5"><span class="toc-text">5. 小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="toc-text">八、计数排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%EF%BC%9F"><span class="toc-text">1. 什么是计数排序？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#a-%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3-4"><span class="toc-text">a. 核心思想</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%9B%BE%E8%A7%A3%E7%A4%BA%E4%BE%8B-7"><span class="toc-text">2. 图解示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Python-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-7"><span class="toc-text">3. Python 代码实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#a-%E5%9F%BA%E7%A1%80%E7%89%88-%E5%A4%84%E7%90%86%E9%9D%9E%E8%B4%9F%E6%95%B4%E6%95%B0"><span class="toc-text">a. 基础版 (处理非负整数)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#b-%E4%BC%98%E5%8C%96%E7%89%88-%E5%A4%84%E7%90%86%E4%BB%BB%E6%84%8F%E6%95%B4%E6%95%B0%E8%8C%83%E5%9B%B4%EF%BC%8C%E5%8C%85%E6%8B%AC%E8%B4%9F%E6%95%B0"><span class="toc-text">b. 优化版 (处理任意整数范围，包括负数)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90-7"><span class="toc-text">4. 算法分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%B0%8F%E7%BB%93-6"><span class="toc-text">5. 小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%9D%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">九、总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%B8%BB%E6%B5%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%BB%BC%E5%90%88%E5%AF%B9%E6%AF%94%E8%A1%A8"><span class="toc-text">1. 主流排序算法综合对比表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%A1%A8%E6%A0%BC%E6%B3%A8%E8%A7%A3%E4%B8%8E%E6%80%BB%E7%BB%93"><span class="toc-text">2. 表格注解与总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%9F"><span class="toc-text">3. 如何选择排序算法？</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/10/24/CPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E7%BB%93%E6%9E%84%E5%8C%96%E7%BB%91%E5%AE%9A/" title="CPP学习笔记—结构化绑定"><img src="/img/52.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CPP学习笔记—结构化绑定"/></a><div class="content"><a class="title" href="/2025/10/24/CPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E7%BB%93%E6%9E%84%E5%8C%96%E7%BB%91%E5%AE%9A/" title="CPP学习笔记—结构化绑定">CPP学习笔记—结构化绑定</a><time datetime="2025-10-24T07:52:23.000Z" title="发表于 2025-10-24 15:52:23">2025-10-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/10/22/CPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/" title="CPP学习笔记—策略模式"><img src="/img/51.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CPP学习笔记—策略模式"/></a><div class="content"><a class="title" href="/2025/10/22/CPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/" title="CPP学习笔记—策略模式">CPP学习笔记—策略模式</a><time datetime="2025-10-22T15:37:59.000Z" title="发表于 2025-10-22 23:37:59">2025-10-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/10/22/CPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94std-function%E7%9A%84%E7%94%A8%E6%B3%95/" title="CPP学习笔记—std::function的用法"><img src="/img/50.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CPP学习笔记—std::function的用法"/></a><div class="content"><a class="title" href="/2025/10/22/CPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94std-function%E7%9A%84%E7%94%A8%E6%B3%95/" title="CPP学习笔记—std::function的用法">CPP学习笔记—std::function的用法</a><time datetime="2025-10-22T15:33:26.000Z" title="发表于 2025-10-22 23:33:26">2025-10-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/10/22/CPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%92%8C%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89/" title="CPP学习笔记—右值引用和移动语义"><img src="/img/49.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CPP学习笔记—右值引用和移动语义"/></a><div class="content"><a class="title" href="/2025/10/22/CPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%92%8C%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89/" title="CPP学习笔记—右值引用和移动语义">CPP学习笔记—右值引用和移动语义</a><time datetime="2025-10-22T15:26:41.000Z" title="发表于 2025-10-22 23:26:41">2025-10-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/10/22/CPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E7%8E%B0%E4%BB%A3C-%E7%9A%84%E7%89%B9%E6%80%A7/" title="CPP学习笔记—现代C++的特性"><img src="/img/48.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CPP学习笔记—现代C++的特性"/></a><div class="content"><a class="title" href="/2025/10/22/CPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E7%8E%B0%E4%BB%A3C-%E7%9A%84%E7%89%B9%E6%80%A7/" title="CPP学习笔记—现代C++的特性">CPP学习笔记—现代C++的特性</a><time datetime="2025-10-22T14:43:46.000Z" title="发表于 2025-10-22 22:43:46">2025-10-22</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 - 2025 By 秋风、萧瑟</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'none',
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }
      
      const script = document.createElement('script')
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.isShuoshuo
  const option = null

  const getGiscusTheme = theme => theme === 'dark' ? 'dark' : 'light'

  const createScriptElement = config => {
    const ele = document.createElement('script')
    Object.entries(config).forEach(([key, value]) => {
      ele.setAttribute(key, value)
    })
    return ele
  }

  const loadGiscus = (el = document, key) => {
    const mappingConfig = isShuoshuo
      ? { 'data-mapping': 'specific', 'data-term': key }
      : { 'data-mapping': (option && option['data-mapping']) || 'pathname' }

    const giscusConfig = {
      src: 'https://giscus.app/client.js',
      'data-repo': 'LX-Cel/lx-cel.github.io',
      'data-repo-id': 'R_kgDONd3anw',
      'data-category-id': 'DIC_kwDONd3an84ClwRS',
      'data-theme': getGiscusTheme(document.documentElement.getAttribute('data-theme')),
      'data-reactions-enabled': '1',
      crossorigin: 'anonymous',
      async: true,
      ...option,
      ...mappingConfig
    }

    const scriptElement = createScriptElement(giscusConfig)

    el.querySelector('#giscus-wrap').appendChild(scriptElement)

    if (isShuoshuo) {
      window.shuoshuoComment.destroyGiscus = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }
  }

  const changeGiscusTheme = theme => {
    const iframe = document.querySelector('#giscus-wrap iframe')
    if (iframe) {
      const message = {
        giscus: {
          setConfig: {
            theme: getGiscusTheme(theme)
          }
        }
      }
      iframe.contentWindow.postMessage(message, 'https://giscus.app')
    }
  }

  btf.addGlobalFn('themeChange', changeGiscusTheme, 'giscus')

  if (isShuoshuo) {
    'Giscus' === 'Giscus'
      ? window.shuoshuoComment = { loadComment: loadGiscus }
      : window.loadOtherComment = loadGiscus
    return
  }

  if ('Giscus' === 'Giscus' || !false) {
    if (false) btf.loadComment(document.getElementById('giscus-wrap'), loadGiscus)
    else loadGiscus()
  } else {
    window.loadOtherComment = loadGiscus
  }
})()</script></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>