<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CPP学习笔记—结构化绑定</title>
      <link href="/2025/10/24/CPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E7%BB%93%E6%9E%84%E5%8C%96%E7%BB%91%E5%AE%9A/"/>
      <url>/2025/10/24/CPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E7%BB%93%E6%9E%84%E5%8C%96%E7%BB%91%E5%AE%9A/</url>
      
        <content type="html"><![CDATA[<h3 id="1-什么是结构化绑定？"><a href="#1-什么是结构化绑定？" class="headerlink" title="1. 什么是结构化绑定？"></a>1. 什么是结构化绑定？</h3><p><strong>一句话概括：</strong> 结构化绑定是一种允许你用一个声明语句，将一个对象（如 <code>struct</code>、<code>class</code>、<code>std::tuple</code>、<code>std::pair</code> 或 C 风格数组）的多个成员或元素，一次性解构并绑定到多个独立变量上的语法。</p><p>它的核心目的是<strong>提升代码的可读性和简洁性</strong>，消除访问复合对象成员时的冗余代码。</p><p><strong>核心语法：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> [ a, b, c, ... ] = some_object;</span><br><span class="line"><span class="comment">// or with qualifiers:</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span>&amp; [ a, b, c, ... ] = some_object;</span><br></pre></td></tr></table></figure><ul><li><code>auto</code>: 关键字，表示类型推导，必须使用 <code>auto</code>（或 <code>auto&amp;</code>, <code>auto&amp;&amp;</code>, <code>const auto&amp;</code> 等）。</li><li><code>[...]</code>: 方括号内是用逗号分隔的新变量名列表。</li><li><code>= some_object</code>: 等号右边是需要被解构的对象。</li></ul><hr><h3 id="2-为什么需要结构化绑定？-The-“Why”"><a href="#2-为什么需要结构化绑定？-The-“Why”" class="headerlink" title="2. 为什么需要结构化绑定？(The “Why”)"></a>2. 为什么需要结构化绑定？(The “Why”)</h3><p>在 C++17 之前，当我们处理返回多个值的函数（通常通过 <code>std::pair</code> 或 <code>std::tuple</code>）或遍历一个 <code>std::map</code> 时，代码会显得有些笨拙。</p><p><strong>示例：遍历 <code>std::map</code></strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// C++11/14 的方式</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pre_cpp17_map_iteration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::map&lt;<span class="type">int</span>, std::string&gt; my_map = &#123;&#123;<span class="number">1</span>, <span class="string">&quot;apple&quot;</span>&#125;, &#123;<span class="number">2</span>, <span class="string">&quot;banana&quot;</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pair : my_map) &#123;</span><br><span class="line">        <span class="comment">// 需要通过 .first 和 .second 访问</span></span><br><span class="line">        <span class="type">int</span> key = pair.first;</span><br><span class="line">        std::string value = pair.second;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Key: &quot;</span> &lt;&lt; key &lt;&lt; <span class="string">&quot;, Value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码虽然能工作，但 <code>pair.first</code> 和 <code>pair.second</code> 的写法不够直观，可读性稍差。</p><p><strong>示例：函数返回多个值</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// C++11/14 的方式</span></span><br><span class="line"><span class="function">std::tuple&lt;std::string, <span class="type">int</span>, <span class="type">double</span>&gt; <span class="title">get_person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;John Doe&quot;</span>, <span class="number">30</span>, <span class="number">185.5</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pre_cpp17_tuple_access</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> person = <span class="built_in">get_person</span>();</span><br><span class="line">    <span class="comment">// 使用 std::get&lt;index&gt; 访问，非常繁琐且容易出错</span></span><br><span class="line">    std::string name = std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(person);</span><br><span class="line">    <span class="type">int</span> age = std::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(person);</span><br><span class="line">    <span class="type">double</span> height = std::<span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(person);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 或者使用 std::tie 一次性解包，但需要预先声明变量</span></span><br><span class="line">    std::string name2;</span><br><span class="line">    <span class="type">int</span> age2;</span><br><span class="line">    <span class="type">double</span> height2;</span><br><span class="line">    std::<span class="built_in">tie</span>(name2, age2, height2) = <span class="built_in">get_person</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>std::get&lt;index&gt;</code> 的方式是“魔数编程”，可读性很差。<code>std::tie</code> 稍好，但需要预先声明变量，代码显得冗长。</p><p>结构化绑定就是为了彻底解决这些痛点而生的。</p><hr><h3 id="3-如何使用结构化绑定？-The-“How”"><a href="#3-如何使用结构化绑定？-The-“How”" class="headerlink" title="3. 如何使用结构化绑定？(The “How”)"></a>3. 如何使用结构化绑定？(The “How”)</h3><p>结构化绑定可以应用于三种主要类型的对象：</p><h4 id="3-1-绑定到-C-风格数组"><a href="#3-1-绑定到-C-风格数组" class="headerlink" title="3.1. 绑定到 C 风格数组"></a>3.1. 绑定到 C 风格数组</h4><p>你可以将一个 C 风格数组的元素绑定到多个变量上。<strong>变量数量必须与数组大小完全匹配。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">3</span>] = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> [x, y, z] = arr; <span class="comment">// x = 10, y = 20, z = 30</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// int arr2[4] = &#123;1, 2, 3, 4&#125;;</span></span><br><span class="line"><span class="comment">// auto [a, b, c] = arr2; // 编译错误！变量数量与数组大小不匹配</span></span><br></pre></td></tr></table></figure><h4 id="3-2-绑定到-Tuple-like-类型"><a href="#3-2-绑定到-Tuple-like-类型" class="headerlink" title="3.2. 绑定到 Tuple-like 类型"></a>3.2. 绑定到 Tuple-like 类型</h4><p>这是最常见的应用场景。任何支持 <code>std::tuple_size</code> 和 <code>std::get&lt;N&gt;()</code> 的类型都可以被结构化绑定。这包括：</p><ul><li><code>std::tuple</code></li><li><code>std::pair</code></li><li><code>std::array</code></li></ul><p><strong>示例：<code>std::pair</code> (常用于 <code>std::map</code> 迭代)</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::map&lt;<span class="type">int</span>, std::string&gt; my_map = &#123;&#123;<span class="number">1</span>, <span class="string">&quot;apple&quot;</span>&#125;, &#123;<span class="number">2</span>, <span class="string">&quot;banana&quot;</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用结构化绑定，代码变得极其清晰</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [key, value] : my_map) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Key: &quot;</span> &lt;&lt; key &lt;&lt; <span class="string">&quot;, Value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对比之前的版本，<code>[key, value]</code> 显著提高了代码的可读性。</p><p><strong>示例：<code>std::tuple</code> (常用于函数多返回值)</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::tuple&lt;std::string, <span class="type">int</span>, <span class="type">double</span>&gt; <span class="title">get_person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;Jane Doe&quot;</span>, <span class="number">28</span>, <span class="number">170.2</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cpp17_tuple_access</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 一行代码完成解构，直观且优雅</span></span><br><span class="line">    <span class="keyword">auto</span> [name, age, height] = <span class="built_in">get_person</span>();</span><br><span class="line">    std::cout &lt;&lt; name &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; age &lt;&lt; <span class="string">&quot; years old and &quot;</span> &lt;&lt; height &lt;&lt; <span class="string">&quot; cm tall.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-绑定到-struct-或-class"><a href="#3-3-绑定到-struct-或-class" class="headerlink" title="3.3. 绑定到 struct 或 class"></a>3.3. 绑定到 <code>struct</code> 或 <code>class</code></h4><p>你可以将一个 <code>struct</code> 或 <code>class</code> 的<strong>所有非静态公开成员</strong>，按照它们<strong>在类中声明的顺序</strong>，绑定到多个变量上。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="comment">// private: int secret; // 私有成员不能被绑定</span></span><br><span class="line">    <span class="comment">// static int count; // 静态成员不能被绑定</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Person p = &#123;<span class="string">&quot;Alice&quot;</span>, <span class="number">25</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> [person_name, person_age] = p; <span class="comment">// person_name = &quot;Alice&quot;, person_age = 25</span></span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; person_name &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; person_age &lt;&lt; <span class="string">&quot; years old.&quot;</span> &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p><strong>重要限制：</strong></p><ul><li>只能绑定到非静态数据成员。</li><li>只能绑定到可访问的成员（通常是 <code>public</code>）。</li><li>绑定顺序严格遵循成员在类&#x2F;结构体中的声明顺序。</li><li>无法绑定到基类的成员。</li></ul><hr><h3 id="4-深入细节：const-的影响"><a href="#4-深入细节：const-的影响" class="headerlink" title="4. 深入细节：const, &amp;, &amp;&amp; 的影响"></a>4. 深入细节：<code>const</code>, <code>&amp;</code>, <code>&amp;&amp;</code> 的影响</h3><p><code>auto</code> 关键字可以与 <code>const</code>, <code>&amp;</code>, <code>&amp;&amp;</code> 组合，这会深刻影响绑定的行为，主要涉及<strong>拷贝开销</strong>和<strong>可修改性</strong>。</p><p>假设我们有一个函数 <code>auto get_data() -&gt; std::pair&lt;HeavyObject, HeavyObject&gt;;</code></p><ol><li><p><strong><code>auto [a, b] = get_data();</code> (值拷贝)</strong></p><ul><li><code>get_data()</code> 返回的临时 <code>pair</code> 对象中的成员会被<strong>拷贝</strong>到 <code>a</code> 和 <code>b</code> 中。</li><li>如果 <code>HeavyObject</code> 拷贝成本很高，这会产生性能问题。</li><li>修改 <code>a</code> 或 <code>b</code> <strong>不会</strong>影响原始数据（在此例中是临时对象，无影响，但如果是左值对象则有区别）。</li></ul></li><li><p><strong><code>auto&amp; [a, b] = some_lvalue_object;</code> (左值引用)</strong></p><ul><li><code>a</code> 和 <code>b</code> 成为 <code>some_lvalue_object</code> 内部成员的<strong>引用</strong>。</li><li><strong>没有拷贝发生</strong>，性能好。</li><li>通过 <code>a</code> 或 <code>b</code> <strong>可以修改</strong> <code>some_lvalue_object</code> 的内部状态。</li><li><strong>不能</strong>绑定到一个临时对象（右值）。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Person p = &#123;<span class="string">&quot;Bob&quot;</span>, <span class="number">40</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span>&amp; [name_ref, age_ref] = p;</span><br><span class="line">name_ref = <span class="string">&quot;Robert&quot;</span>; <span class="comment">// p.name 现在变成了 &quot;Robert&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><strong><code>const auto&amp; [a, b] = ...;</code> (常量左值引用)</strong></p><ul><li><code>a</code> 和 <code>b</code> 成为原始对象内部成员的<strong>常量引用</strong>。</li><li><strong>没有拷贝发生</strong>，性能好。</li><li><strong>不能</strong>通过 <code>a</code> 或 <code>b</code> 修改原始对象。</li><li>这是<strong>最常用、最安全</strong>的方式，特别是用于循环和只读访问，因为它既避免了拷贝，又防止了意外修改，并且可以绑定到左值和右值。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历 map 时最推荐的写法</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [key, value] : my_map) &#123;</span><br><span class="line">    <span class="comment">// ... 只读访问 key 和 value ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>auto&amp;&amp; [a, b] = ...;</code> (转发引用&#x2F;通用引用)</strong></p><ul><li>这是一个更高级的用法，遵循模板中的转发引用规则。</li><li>如果等号右边是<strong>左值</strong>，<code>a</code> 和 <code>b</code> 成为<strong>左值引用 (<code>&amp;</code>)</strong>。</li><li>如果等号右边是<strong>右值</strong>，<code>a</code> 和 <code>b</code> 成为<strong>右值引用 (<code>&amp;&amp;</code>)</strong>。</li><li>在泛型编程或需要完美转发的场景下很有用。对于 <code>for</code> 循环，它也能正确处理不同类型的容器。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp;&amp; [key, val] : some_range) &#123;</span><br><span class="line">   <span class="comment">// 能够完美地处理范围表达式返回的代理对象或临时对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="5-结构化绑定的底层机制（进阶）"><a href="#5-结构化绑定的底层机制（进阶）" class="headerlink" title="5. 结构化绑定的底层机制（进阶）"></a>5. 结构化绑定的底层机制（进阶）</h3><p>理解这一点有助于避免一些常见的误解。<code>auto [a, b] = obj;</code> 这行代码<strong>并不会真的创建</strong>名为 <code>a</code> 和 <code>b</code> 的独立变量。</p><p>实际上，编译器会执行类似下面的“伪代码”转换：</p><ol><li>生成一个隐藏的匿名变量 <code>E</code> 来持有 <code>obj</code> 的拷贝或引用。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> E = obj; <span class="comment">// 或者 auto&amp; E = obj; 等，取决于 auto 的修饰符</span></span><br></pre></td></tr></table></figure></li><li>然后，你声明的 <code>a</code> 和 <code>b</code> 成为对 <code>E</code> 内部成员或元素的<strong>别名 (alias)</strong>。<ul><li>如果 <code>E</code> 是数组，<code>a</code> 是 <code>E[0]</code> 的别名，<code>b</code> 是 <code>E[1]</code> 的别名。</li><li>如果 <code>E</code> 是 <code>struct</code>，<code>a</code> 是 <code>E.member1</code> 的别名，<code>b</code> 是 <code>E.member2</code> 的别名。</li><li>如果 <code>E</code> 是 <code>tuple-like</code>，<code>a</code> 是 <code>std::get&lt;0&gt;(E)</code> 的别名，<code>b</code> 是 <code>std::get&lt;1&gt;(E)</code> 的别名。</li></ul></li></ol><p><strong>这为什么重要？</strong></p><ul><li><strong><code>decltype</code> 的行为</strong>：<code>decltype(a)</code> 推导出的类型是底层成员的类型（通常是引用类型），而不是一个独立的变量类型。</li><li><strong>没有独立的变量</strong>：你不能获取 <code>a</code> 的地址（<code>&amp;a</code>），因为 <code>a</code> 只是一个名字，不是一个独立的对象。你获取的是它所引用的那个底层成员的地址。</li></ul><hr><h3 id="6-局限性和注意事项"><a href="#6-局限性和注意事项" class="headerlink" title="6. 局限性和注意事项"></a>6. 局限性和注意事项</h3><ol><li><strong>必须在声明时初始化</strong>：结构化绑定必须在声明时立即用一个对象来初始化。</li><li><strong>变量数量必须精确匹配</strong>：声明的变量数量必须与对象的元素&#x2F;成员数量完全一致，不能多也不能少。</li><li><strong>不能用于全局或类成员</strong>：结构化绑定声明只能用于局部变量（函数作用域内、<code>if/switch/for</code> 的初始化语句中）。</li><li><strong>无法显式指定类型</strong>：必须使用 <code>auto</code> 进行类型推导，不能写成 <code>int [x, y] = ...;</code>。</li><li><strong><code>struct</code> 绑定的脆弱性</strong>：对于 <code>struct</code>，绑定顺序依赖于成员声明顺序。如果未来有人修改了 <code>struct</code> 的成员顺序，所有使用结构化绑定的地方都会悄无声息地出错，这是一个潜在的维护风险。因此，对于不稳定的 <code>struct</code>，优先使用返回 <code>std::tuple</code> 的方式可能更安全。</li></ol><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>结构化绑定是 C++17 中一项极其实用和受欢迎的特性。它通过提供一种简洁、直观的方式来解构复合对象，极大地提升了代码的可读性和表达力。</p><p><strong>核心优势：</strong></p><ul><li><strong>可读性强</strong>：用有意义的变量名代替 <code>pair.first</code>, <code>std::get&lt;0&gt;</code>。</li><li><strong>代码简洁</strong>：一行代码完成声明和解构，减少样板代码。</li><li><strong>不易出错</strong>：避免了 <code>std::get</code> 中因写错索引而导致的逻辑错误。</li></ul><p>掌握结构化绑定，特别是正确使用 <code>const auto&amp;</code>，是编写现代、高效、易读的 C++ 代码的关键技能之一。</p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CPP学习笔记—策略模式</title>
      <link href="/2025/10/22/CPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
      <url>/2025/10/22/CPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="1-什么是策略模式？"><a href="#1-什么是策略模式？" class="headerlink" title="1. 什么是策略模式？"></a>1. 什么是策略模式？</h3><p>策略模式是一种行为设计模式，它<strong>定义了一系列算法，将每一个算法封装起来，并使它们可以相互替换</strong>。此模式让算法的变化独立于使用算法的客户。</p><p>简单来说，策略模式的核心思想是：</p><ul><li><strong>分离</strong>: 将算法的 <strong>定义（是什么）</strong> 与算法的 <strong>使用（何时用）</strong> 分离开来。</li><li><strong>封装</strong>: 将不同的算法（即“策略”）封装在各自独立的类中。</li><li><strong>委托</strong>: “上下文”（Context）对象不亲自执行算法，而是将任务委托给它所持有的策略对象。</li></ul><p>GoF（《设计模式》）中的经典定义是：“Define a family of algorithms, encapsulate each one, and make them interchangeable. Strategy lets the algorithm vary independently from clients that use it.”</p><hr><h3 id="2-为什么需要策略模式？（问题场景）"><a href="#2-为什么需要策略模式？（问题场景）" class="headerlink" title="2. 为什么需要策略模式？（问题场景）"></a>2. 为什么需要策略模式？（问题场景）</h3><p>假设我们正在编写一个数据处理程序，其中一个功能是对一组数据进行排序。一开始，我们可能只实现了一种排序算法，比如冒泡排序。</p><p><strong>一个反例：使用 <code>if-else</code> 或 <code>switch</code></strong></p><p>随着需求增加，我们需要支持更多的排序算法，如快速排序、归并排序等。一种常见的“坏”设计是这样的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span> <span class="comment">// for std::swap</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 排序算法类型</span></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">SortType</span> &#123;</span><br><span class="line">    BubbleSort,</span><br><span class="line">    QuickSort,</span><br><span class="line">    MergeSort</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个巨大的排序类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sorter</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; data, SortType type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (type == SortType::BubbleSort) &#123;</span><br><span class="line">            <span class="comment">// 冒泡排序逻辑...</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Sorting using Bubble Sort&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="comment">// ... (实现)</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == SortType::QuickSort) &#123;</span><br><span class="line">            <span class="comment">// 快速排序逻辑...</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Sorting using Quick Sort&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="comment">// ... (实现)</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == SortType::MergeSort) &#123;</span><br><span class="line">            <span class="comment">// 归并排序逻辑...</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Sorting using Merge Sort&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="comment">// ... (实现)</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Unknown sort type&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>这种设计的弊端非常明显：</strong></p><ol><li><strong>违反开放&#x2F;封闭原则 (Open&#x2F;Closed Principle)</strong>：每当需要添加一种新的排序算法时，我们都必须修改 <code>Sorter</code> 类的 <code>sort</code> 方法，增加一个新的 <code>else if</code> 分支。这使得类变得不稳定且难以维护。</li><li><strong>职责不单一</strong>: <code>Sorter</code> 类承担了太多的责任。它不仅要负责“进行排序”这个行为，还要知道<strong>所有</strong>具体的排序算法是如何实现的。</li><li><strong>代码臃肿</strong>: 随着算法增多，<code>sort</code> 方法会变得越来越长，难以阅读和理解。</li><li><strong>复用性差</strong>: 如果其他地方也需要用到某个排序算法，你可能需要复制代码，或者让那个地方也依赖这个巨大的 <code>Sorter</code> 类。</li></ol><p>策略模式正是为了解决这类问题而生的。</p><hr><h3 id="3-策略模式的结构"><a href="#3-策略模式的结构" class="headerlink" title="3. 策略模式的结构"></a>3. 策略模式的结构</h3><p>策略模式主要由以下三个角色组成：</p><ol><li><p><strong>Strategy (策略接口&#x2F;抽象基类)</strong></p><ul><li>它定义了一个所有支持的算法的公共接口。</li><li>在 C++ 中，通常是一个包含纯虚函数的抽象基类。</li><li>Context 使用这个接口来调用由 ConcreteStrategy 定义的算法。</li></ul></li><li><p><strong>ConcreteStrategy (具体策略类)</strong></p><ul><li>它实现了 Strategy 接口，封装了具体的算法或行为。</li><li>每个具体策略类都代表一种算法。</li></ul></li><li><p><strong>Context (上下文)</strong></p><ul><li>它包含一个指向 Strategy 对象的引用（通常是成员变量）。</li><li>它不直接实现算法，而是将请求委托给其持有的 Strategy 对象。</li><li>它通常提供一个方法来让客户端可以设置或更换具体的策略。</li></ul></li></ol><h4 id="UML-类图"><a href="#UML-类图" class="headerlink" title="UML 类图"></a>UML 类图</h4><p>下面是策略模式的经典 UML 类图：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">+----------------+      &lt;&gt;       +------------------+</span><br><span class="line">|    Context     |---------------+  IStrategy       |</span><br><span class="line">+----------------+               +------------------+</span><br><span class="line">| - strategy     |               | + execute() = 0  |</span><br><span class="line">+----------------+               +------------------+</span><br><span class="line">| + setStrategy()|                        ^</span><br><span class="line">| + doSomething()|                        |</span><br><span class="line">+----------------+                        |</span><br><span class="line">                                          |</span><br><span class="line">        +---------------------------------+---------------------------------+</span><br><span class="line">        |                                 |                                 |</span><br><span class="line">+--------------------+           +--------------------+           +--------------------+</span><br><span class="line">| ConcreteStrategyA  |           | ConcreteStrategyB  |           | ConcreteStrategyC  |</span><br><span class="line">+--------------------+           +--------------------+           +--------------------+</span><br><span class="line">| + execute()        |           | + execute()        |           | + execute()        |</span><br><span class="line">+--------------------+           +--------------------+           +--------------------+</span><br></pre></td></tr></table></figure><hr><h3 id="4-C-代码实现（经典方式：基于继承和多态）"><a href="#4-C-代码实现（经典方式：基于继承和多态）" class="headerlink" title="4. C++ 代码实现（经典方式：基于继承和多态）"></a>4. C++ 代码实现（经典方式：基于继承和多态）</h3><p>我们用前面提到的排序器例子来重构代码，使其符合策略模式。</p><h4 id="场景设定：一个排序器，可以动态切换排序算法。"><a href="#场景设定：一个排序器，可以动态切换排序算法。" class="headerlink" title="场景设定：一个排序器，可以动态切换排序算法。"></a>场景设定：一个排序器，可以动态切换排序算法。</h4><h5 id="第一步：定义策略接口-Strategy"><a href="#第一步：定义策略接口-Strategy" class="headerlink" title="第一步：定义策略接口 (Strategy)"></a>第一步：定义策略接口 (Strategy)</h5><p>我们创建一个抽象基类 <code>SortStrategy</code>，它定义了所有排序算法都必须实现的 <code>sort</code> 方法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once <span class="comment">// 防止头文件重复包含</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 策略接口 (Strategy)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SortStrategy</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 纯虚函数，定义了策略的接口</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">sort</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; vec)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 虚析构函数，确保派生类对象能被正确销毁</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">SortStrategy</span>() = <span class="keyword">default</span>; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>: 基类中的析构函数必须是虚函数 (<code>virtual</code>)，否则通过基类指针删除派生类对象时，会导致派生类的析构函数无法被调用，造成资源泄漏。</p><h5 id="第二步：实现具体策略-Concrete-Strategies"><a href="#第二步：实现具体策略-Concrete-Strategies" class="headerlink" title="第二步：实现具体策略 (Concrete Strategies)"></a>第二步：实现具体策略 (Concrete Strategies)</h5><p>现在我们为每种排序算法创建一个具体的策略类，它们都继承自 <code>SortStrategy</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;SortStrategy.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span> <span class="comment">// for std::swap, std::sort</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体策略 A: 冒泡排序</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BubbleSortStrategy</span> : <span class="keyword">public</span> SortStrategy &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; vec)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Sorting using Bubble Sort...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="type">int</span> n = vec.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n - i - <span class="number">1</span>; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (vec[j] &gt; vec[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    std::<span class="built_in">swap</span>(vec[j], vec[j + <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体策略 B: 快速排序 (为了简单，这里直接使用 std::sort)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">QuickSortStrategy</span> : <span class="keyword">public</span> SortStrategy &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; vec)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Sorting using Quick Sort (std::sort)...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::<span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体策略 C: 归并排序 (这里仅作演示，不完整实现)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MergeSortStrategy</span> : <span class="keyword">public</span> SortStrategy &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; vec)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Sorting using Merge Sort...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// 实际的归并排序逻辑会比较复杂，这里仅作示意</span></span><br><span class="line">        <span class="comment">// 为了演示，我们也可以用 std::stable_sort</span></span><br><span class="line">        std::<span class="built_in">stable_sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="第三步：创建上下文-Context"><a href="#第三步：创建上下文-Context" class="headerlink" title="第三步：创建上下文 (Context)"></a>第三步：创建上下文 (Context)</h5><p><code>Context</code> 类 (<code>Sorter</code>) 持有一个 <code>SortStrategy</code> 的指针，并将排序任务委托给它。我们使用 <code>std::unique_ptr</code> 来管理策略对象的生命周期，这是一种更安全的现代 C++ 做法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;SortStrategy.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span> <span class="comment">// for std::unique_ptr</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span> <span class="comment">// for std::move</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 上下文 (Context)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sorter</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unique_ptr&lt;SortStrategy&gt; strategy_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数，注入一个初始策略</span></span><br><span class="line">    <span class="built_in">Sorter</span>(std::unique_ptr&lt;SortStrategy&gt; strategy) : <span class="built_in">strategy_</span>(std::<span class="built_in">move</span>(strategy)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 允许在运行时更换策略</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setStrategy</span><span class="params">(std::unique_ptr&lt;SortStrategy&gt; strategy)</span> </span>&#123;</span><br><span class="line">        strategy_ = std::<span class="built_in">move</span>(strategy);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行排序，将任务委托给当前的策略对象</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">performSort</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (strategy_) &#123;</span><br><span class="line">            strategy_-&gt;<span class="built_in">sort</span>(vec);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;No sort strategy set!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="第四步：客户端代码调用"><a href="#第四步：客户端代码调用" class="headerlink" title="第四步：客户端代码调用"></a>第四步：客户端代码调用</h5><p>客户端代码负责创建具体的策略对象和上下文对象，并将它们组合起来。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ConcreteStrategies.h&quot;</span> <span class="comment">// 假设具体策略类都在这个头文件里</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Sorter.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printVector</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> val : vec) &#123;</span><br><span class="line">        std::cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; data = &#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始使用冒泡排序策略</span></span><br><span class="line">    <span class="keyword">auto</span> sorter = std::<span class="built_in">make_unique</span>&lt;Sorter&gt;(std::<span class="built_in">make_unique</span>&lt;BubbleSortStrategy&gt;());</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Initial data: &quot;</span>;</span><br><span class="line">    <span class="built_in">printVector</span>(data);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n--- Using Bubble Sort ---&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    sorter-&gt;<span class="built_in">performSort</span>(data);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sorted data: &quot;</span>;</span><br><span class="line">    <span class="built_in">printVector</span>(data);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n-----------------------------\n&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在运行时更换为快速排序策略</span></span><br><span class="line">    data = &#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">4</span>&#125;; <span class="comment">// 重置数据</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;--- Changing to Quick Sort ---&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    sorter-&gt;<span class="built_in">setStrategy</span>(std::<span class="built_in">make_unique</span>&lt;QuickSortStrategy&gt;());</span><br><span class="line">    sorter-&gt;<span class="built_in">performSort</span>(data);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sorted data: &quot;</span>;</span><br><span class="line">    <span class="built_in">printVector</span>(data);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，如果我们要添加一个新的排序算法（比如“堆排序”），我们只需要：</p><ol><li>创建一个新的 <code>HeapSortStrategy</code> 类，继承自 <code>SortStrategy</code>。</li><li>在客户端代码中实例化并使用它。</li></ol><p><code>Sorter</code> 类完全不需要任何修改，完美符合开放&#x2F;封闭原则。</p><hr><h3 id="5-策略模式的优缺点分析"><a href="#5-策略模式的优缺点分析" class="headerlink" title="5. 策略模式的优缺点分析"></a>5. 策略模式的优缺点分析</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol><li><strong>开闭原则</strong>：策略模式很好地支持了开闭原则，可以轻松地增加新的策略而无需修改上下文代码。</li><li><strong>避免多重条件语句</strong>：它将 <code>if-else</code> 或 <code>switch</code> 结构替换为对象的多态性，使代码更清晰、更易于维护。</li><li><strong>策略的复用</strong>：可以将策略类定义为公共组件，在不同的上下文中复用。</li><li><strong>关注点分离</strong>：上下文只关心“何时”执行，而具体策略关心“如何”执行，职责清晰。</li><li><strong>运行时切换</strong>：可以在程序运行时动态地改变对象的行为（算法）。</li></ol><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol><li><strong>类数量增多</strong>：每个策略都是一个独立的类，如果策略很多，会导致系统中类的数量增加。</li><li><strong>客户端必须了解所有策略</strong>：客户端需要知道有哪些具体的策略，并自行决定使用哪一个。在某些情况下，这可能会将策略的实现细节暴露给客户端。</li><li><strong>增加了对象间的通信</strong>：上下文和策略之间存在一次间接的调用，对于非常简单的算法，可能会显得有些小题大做。</li></ol><hr><h3 id="6-C-中的其他实现方式"><a href="#6-C-中的其他实现方式" class="headerlink" title="6. C++ 中的其他实现方式"></a>6. C++ 中的其他实现方式</h3><p>经典的基于继承和多态的方式非常通用，但在现代 C++ 中，我们有更灵活、更轻量级的选择。</p><h4 id="方式一：使用-std-function-和-Lambda-表达式"><a href="#方式一：使用-std-function-和-Lambda-表达式" class="headerlink" title="方式一：使用 std::function 和 Lambda 表达式"></a>方式一：使用 <code>std::function</code> 和 Lambda 表达式</h4><p>我们可以用 <code>std::function</code> 替代策略基类指针。<code>std::function</code> 是一个通用的、可调用对象的包装器，它可以存储、复制和调用任何可调用目标——包括普通函数、Lambda 表达式、函数指针和函数对象。</p><p><strong>修改后的 <code>Sorter</code> (Context):</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span> <span class="comment">// for std::function</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sorter</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::function&lt;<span class="type">void</span>(std::vector&lt;<span class="type">int</span>&gt;&amp;)&gt; sort_func_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Sorter</span>(std::function&lt;<span class="built_in">void</span>(std::vector&lt;<span class="type">int</span>&gt;&amp;)&gt; func) : <span class="built_in">sort_func_</span>(std::<span class="built_in">move</span>(func)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setStrategy</span><span class="params">(std::function&lt;<span class="type">void</span>(std::vector&lt;<span class="type">int</span>&gt;&amp;)&gt; func)</span> </span>&#123;</span><br><span class="line">        sort_func_ = std::<span class="built_in">move</span>(func);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">performSort</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sort_func_) &#123;</span><br><span class="line">            <span class="built_in">sort_func_</span>(vec);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>客户端调用：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们可以定义独立的函数作为策略</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSortFunc</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sorting using bubble sort function...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// ... logic</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; data = &#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 Lambda 表达式作为策略</span></span><br><span class="line">    <span class="function">Sorter <span class="title">sorter</span><span class="params">([](std::vector&lt;<span class="type">int</span>&gt;&amp; vec) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        std::cout &lt;&lt; <span class="string">&quot;Sorting using a lambda (Quick Sort)...&quot;</span> &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">        std::sort(vec.begin(), vec.end());</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    sorter.<span class="built_in">performSort</span>(data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更换策略为一个独立的函数</span></span><br><span class="line">    data = &#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    sorter.<span class="built_in">setStrategy</span>(bubbleSortFunc);</span><br><span class="line">    sorter.<span class="built_in">performSort</span>(data);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式<strong>优点</strong>是<strong>非常轻量</strong>，不需要定义一堆策略类，尤其适合那些逻辑简单、只用一次的策略。</p><h4 id="方式二：使用模板元编程（静态策略模式）"><a href="#方式二：使用模板元编程（静态策略模式）" class="headerlink" title="方式二：使用模板元编程（静态策略模式）"></a>方式二：使用模板元编程（静态策略模式）</h4><p>如果策略在编译时就已经确定，并且不需要在运行时动态切换，那么可以使用模板实现<strong>静态策略模式</strong>。这种方式没有运行时多态的开销（虚函数调用），性能更好。</p><p><strong>修改后的 <code>Sorter</code> (Context):</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Context 变成了一个模板类</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> SortStrategy&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sorter</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    SortStrategy strategy_; <span class="comment">// 直接拥有一个策略对象，而不是指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">performSort</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">        strategy_.<span class="built_in">sort</span>(vec);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 策略类不再需要继承自公共基类，只需要有 sort 方法即可 (Duck Typing)</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BubbleSortStrategy</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; vec)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Static sorting using Bubble Sort...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// ... logic</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">QuickSortStrategy</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; vec)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Static sorting using Quick Sort...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// ... logic</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>客户端调用：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; data1 = &#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; data2 = &#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 策略在编译时通过模板参数确定</span></span><br><span class="line">    Sorter&lt;BubbleSortStrategy&gt; bubbleSorter;</span><br><span class="line">    bubbleSorter.<span class="built_in">performSort</span>(data1);</span><br><span class="line">    </span><br><span class="line">    Sorter&lt;QuickSortStrategy&gt; quickSorter;</span><br><span class="line">    quickSorter.<span class="built_in">performSort</span>(data2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意：一个 bubbleSorter 对象无法在运行时变成 quickSorter</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式的<strong>优点</strong>是<strong>性能高</strong>（没有虚函数调用开销），<strong>类型安全</strong>在编译期检查。<strong>缺点</strong>是<strong>失去了运行时动态切换策略的灵活性</strong>。</p><hr><h3 id="7-总结与适用场景"><a href="#7-总结与适用场景" class="headerlink" title="7. 总结与适用场景"></a>7. 总结与适用场景</h3><h4 id="何时应该使用策略模式？"><a href="#何时应该使用策略模式？" class="headerlink" title="何时应该使用策略模式？"></a>何时应该使用策略模式？</h4><ol><li><strong>当你有多个相关的类，它们只有行为上的差异时</strong>。策略模式可以让你用一个统一的接口来处理这些不同的行为。</li><li><strong>当你需要一个算法的多个变体时</strong>。例如，不同的压缩算法、不同的验证规则、不同的文件保存格式。</li><li><strong>当你希望避免使用大量的条件语句时</strong>。将这些分支逻辑移到各自的策略类中，可以使主逻辑更清晰。</li><li><strong>当你希望算法的实现细节与客户端代码分离时</strong>。客户端只需知道使用哪个策略，而不需要关心策略内部是如何工作的。</li><li><strong>当你希望在运行时能够动态地为一个对象选择或切换算法时</strong>。（这是动态策略模式的核心优势）</li></ol><p>策略模式是面向对象设计中一个非常强大且常用的工具，它体现了“组合优于继承”和“面向接口编程”等核心设计原则。掌握它对于编写可扩展、可维护的软件至关重要。</p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CPP学习笔记—std::function的用法</title>
      <link href="/2025/10/22/CPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94std-function%E7%9A%84%E7%94%A8%E6%B3%95/"/>
      <url>/2025/10/22/CPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94std-function%E7%9A%84%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p><code>std::function</code> 是 C++11 中引入的一个极其有用的工具，位于 <code>&lt;functional&gt;</code> 头文件中。它是一个<strong>通用的、多态的函数包装器</strong>。它的实例可以存储、复制和调用任何<strong>可调用 (Callable)</strong> 目标——包括普通函数、Lambda 表达式、函数指针、成员函数指针、以及函数对象（functors）。</p><hr><h3 id="1-std-function-是什么？"><a href="#1-std-function-是什么？" class="headerlink" title="1. std::function 是什么？"></a>1. <code>std::function</code> 是什么？</h3><h4 id="一句话定义"><a href="#一句话定义" class="headerlink" title="一句话定义"></a>一句话定义</h4><p><code>std::function</code> 是一个<strong>类型安全</strong>的包装器，它可以持有任何符合其函数签名的可调用对象。</p><p>可以把它想象成一个“万能的函数指针”，但它比函数指针强大得多，因为它可以指向任何可调用的东西，而不仅仅是全局函数。</p><h4 id="解决的问题：类型不统一的“可调用物”"><a href="#解决的问题：类型不统一的“可调用物”" class="headerlink" title="解决的问题：类型不统一的“可调用物”"></a>解决的问题：类型不统一的“可调用物”</h4><p>在 C++ 中，有很多东西都可以被“调用”，比如：</p><ul><li><strong>普通函数指针</strong>: <code>void (*p_func)(int);</code></li><li><strong>函数对象 (Functor)</strong>: 一个重载了 <code>operator()</code> 的类的对象。每个函数对象都有自己独特的类型。</li><li><strong>Lambda 表达式</strong>: 编译器会为每个 Lambda 生成一个唯一的、匿名的闭包类型。</li></ul><p>在 <code>std::function</code> 出现之前，如果你想编写一个函数来接受一个“回调”，你将面临一个难题。例如，一个按钮的点击事件处理：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我想让这个函数能接受任何“无参数、无返回值”的回调</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_on_click_handler</span><span class="params">(??? handler)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 <code>???</code> 应该是什么类型？</p><ul><li>如果是 <code>void (*)()</code>，那么它就不能接受带捕获的 Lambda 或函数对象。</li><li>如果使用模板 <code>template &lt;typename T&gt; void set_on_click_handler(T handler)</code>，那么这个类型会“渗透”到你的类定义中，使其也必须是模板，这会大大增加复杂性。</li></ul><p><code>std::function</code> 完美地解决了这个问题。它提供了一个统一的类型来表示所有具有相同签名的可调用对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_on_click_handler</span><span class="params">(std::function&lt;<span class="type">void</span>()&gt; handler)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，任何无参数、无返回值的可调用物都可以传递给这个函数了。</p><hr><h3 id="2-基本语法和用法"><a href="#2-基本语法和用法" class="headerlink" title="2. 基本语法和用法"></a>2. 基本语法和用法</h3><h4 id="包含头文件"><a href="#包含头文件" class="headerlink" title="包含头文件"></a>包含头文件</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br></pre></td></tr></table></figure><h4 id="声明与初始化"><a href="#声明与初始化" class="headerlink" title="声明与初始化"></a>声明与初始化</h4><p><code>std::function</code> 是一个类模板，其模板参数是<strong>函数签名</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个可以持有“接受一个 int 和一个 double，返回一个 bool”的函数的包装器</span></span><br><span class="line">std::function&lt;<span class="type">bool</span>(<span class="type">int</span>, <span class="type">double</span>)&gt; my_func; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明并初始化</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">my_division</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(a) / b; &#125;</span><br><span class="line">std::function&lt;<span class="type">double</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; func_divider = my_division;</span><br></pre></td></tr></table></figure><h4 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h4><p>调用 <code>std::function</code> 对象就像调用一个普通函数一样。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> result = <span class="built_in">func_divider</span>(<span class="number">10</span>, <span class="number">3</span>); <span class="comment">// result is 3.333...</span></span><br></pre></td></tr></table></figure><h4 id="检查是否为空"><a href="#检查是否为空" class="headerlink" title="检查是否为空"></a>检查是否为空</h4><p>一个未初始化的 <code>std::function</code> 对象是“空的”。在调用之前检查它是否持有可调用对象是一个好习惯，否则会抛出 <code>std::bad_function_call</code> 异常。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">std::function&lt;<span class="type">void</span>()&gt; empty_func;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (empty_func) &#123; <span class="comment">// bool conversion operator checks if it&#x27;s non-empty</span></span><br><span class="line">    <span class="built_in">empty_func</span>(); <span class="comment">// 如果不检查，这行会抛出异常</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Function wrapper is empty.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以与 nullptr 比较</span></span><br><span class="line"><span class="keyword">if</span> (empty_func == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;It&#x27;s null!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="3-std-function-可以存储什么？"><a href="#3-std-function-可以存储什么？" class="headerlink" title="3. std::function 可以存储什么？"></a>3. <code>std::function</code> 可以存储什么？</h3><p>这是 <code>std::function</code> 最强大的地方。只要签名匹配，它可以存储几乎任何可调用物。</p><h4 id="示例1：普通函数-Free-Functions"><a href="#示例1：普通函数-Free-Functions" class="headerlink" title="示例1：普通函数 (Free Functions)"></a>示例1：普通函数 (Free Functions)</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_message</span><span class="params">(<span class="type">const</span> std::string&amp; msg)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Message: &quot;</span> &lt;&lt; msg &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::function&lt;<span class="type">void</span>(<span class="type">const</span> std::string&amp;)&gt; func = print_message;</span><br><span class="line">    <span class="built_in">func</span>(<span class="string">&quot;Hello from a free function!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="示例2：Lambda-表达式"><a href="#示例2：Lambda-表达式" class="headerlink" title="示例2：Lambda 表达式"></a>示例2：Lambda 表达式</h4><p>这是最常见的用法，尤其是对于带状态（有捕获）的 Lambda。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> counter = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 一个捕获了 counter 变量的 Lambda</span></span><br><span class="line">    std::function&lt;<span class="type">void</span>()&gt; lambda_func = [&amp;counter]() &#123;</span><br><span class="line">        counter++;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Counter value: &quot;</span> &lt;&lt; counter &lt;&lt; std::endl;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">lambda_func</span>(); <span class="comment">// 输出: Counter value: 11</span></span><br><span class="line">    <span class="built_in">lambda_func</span>(); <span class="comment">// 输出: Counter value: 12</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Original counter: &quot;</span> &lt;&lt; counter &lt;&lt; std::endl; <span class="comment">// 输出: Original counter: 12</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="示例3：函数对象-Functors"><a href="#示例3：函数对象-Functors" class="headerlink" title="示例3：函数对象 (Functors)"></a>示例3：函数对象 (Functors)</h4><p>一个重载了 <code>operator()</code> 的类的实例。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Multiplier</span> &#123;</span><br><span class="line">    <span class="type">int</span> factor;</span><br><span class="line">    <span class="built_in">Multiplier</span>(<span class="type">int</span> f) : <span class="built_in">factor</span>(f) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> value)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value * factor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Multiplier <span class="title">mul_by_5</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Functor 对象可以直接赋值给 std::function</span></span><br><span class="line">    std::function&lt;<span class="type">int</span>(<span class="type">int</span>)&gt; func = mul_by_5;</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;5 * 10 = &quot;</span> &lt;&lt; <span class="built_in">func</span>(<span class="number">10</span>) &lt;&lt; std::endl; <span class="comment">// 输出: 5 * 10 = 50</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也可以用临时对象或 Lambda 创建</span></span><br><span class="line">    std::function&lt;<span class="type">int</span>(<span class="type">int</span>)&gt; func2 = Multiplier&#123;<span class="number">100</span>&#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;100 * 10 = &quot;</span> &lt;&lt; <span class="built_in">func2</span>(<span class="number">10</span>) &lt;&lt; std::endl; <span class="comment">// 输出: 100 * 10 = 1000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="示例4：类的成员函数"><a href="#示例4：类的成员函数" class="headerlink" title="示例4：类的成员函数"></a>示例4：类的成员函数</h4><p>这是稍微复杂一点的情况，因为成员函数需要一个 <code>this</code> 指针（即一个类的实例）来调用。通常有两种方法来包装它们。</p><p><strong>方法 A：使用 <code>std::bind</code> (传统方式)</strong></p><p><code>std::bind</code> 可以将成员函数、对象实例和参数“绑定”在一起，生成一个新的可调用对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::placeholders; <span class="comment">// for _1, _2, etc.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Greeter</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">say_hello</span><span class="params">(<span class="type">const</span> std::string&amp; name)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Hello, &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Greeter greeter_obj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定 Greeter::say_hello 成员函数到 greeter_obj 实例上</span></span><br><span class="line">    <span class="comment">// _1 是一个占位符，表示 std::function 调用时的第一个参数</span></span><br><span class="line">    std::function&lt;<span class="type">void</span>(<span class="type">const</span> std::string&amp;)&gt; member_func = </span><br><span class="line">        std::<span class="built_in">bind</span>(&amp;Greeter::say_hello, &amp;greeter_obj, _1);</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">member_func</span>(<span class="string">&quot;World&quot;</span>); <span class="comment">// 实际上调用的是 greeter_obj.say_hello(&quot;World&quot;)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法 B：使用 Lambda 表达式 (现代 C++ 推荐方式)</strong></p><p>Lambda 表达式通常更清晰、更易读。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Greeter greeter_obj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用 Lambda 捕获对象实例的引用（或指针）</span></span><br><span class="line">    std::function&lt;<span class="type">void</span>(<span class="type">const</span> std::string&amp;)&gt; member_func_lambda = </span><br><span class="line">        [&amp;greeter_obj](<span class="type">const</span> std::string&amp; name) &#123;</span><br><span class="line">            greeter_obj.<span class="built_in">say_hello</span>(name);</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">member_func_lambda</span>(<span class="string">&quot;Alice&quot;</span>); <span class="comment">// 调用 Lambda，Lambda 内部再调用成员函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="4-std-function-的内部机制与关键特性"><a href="#4-std-function-的内部机制与关键特性" class="headerlink" title="4. std::function 的内部机制与关键特性"></a>4. <code>std::function</code> 的内部机制与关键特性</h3><h4 id="类型擦除-Type-Erasure"><a href="#类型擦除-Type-Erasure" class="headerlink" title="类型擦除 (Type Erasure)"></a>类型擦除 (Type Erasure)</h4><p><code>std::function</code> 的核心魔法是<strong>类型擦除</strong>。当你把一个 Lambda （类型为 <code>ClosureType_A</code>）或者一个 Functor （类型为 <code>MyFunctor</code>）赋值给 <code>std::function&lt;void()&gt;</code> 时，<code>std::function</code> 内部会通过动态内存（通常）和虚函数来“擦除”原始对象的具体类型，只保留其“可调用性”和函数签名。</p><p>它内部大致像这样（极度简化）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伪代码</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">function</span> &#123;</span><br><span class="line">    <span class="comment">// 指向一个抽象基类的指针</span></span><br><span class="line">    CallableBase* callable_ptr; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F&gt;</span></span><br><span class="line"><span class="function">    <span class="title">function</span><span class="params">(F f)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 为具体的 f 类型创建一个派生类实例，并存入基类指针</span></span><br><span class="line">        callable_ptr = <span class="keyword">new</span> <span class="built_in">ConcreteCallable</span>&lt;F&gt;(f); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">R <span class="title">operator</span><span class="params">()</span><span class="params">(Args... args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 通过虚函数调用</span></span><br><span class="line">        <span class="keyword">return</span> callable_ptr-&gt;<span class="built_in">invoke</span>(args...); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这就是为什么它可以接受不同类型的可调用对象——它们都被包装在了一个统一的接口后面。</p><h4 id="小对象优化-Small-Object-Optimization-SOO"><a href="#小对象优化-Small-Object-Optimization-SOO" class="headerlink" title="小对象优化 (Small Object Optimization, SOO)"></a>小对象优化 (Small Object Optimization, SOO)</h4><p>由于类型擦除通常需要堆分配（<code>new</code>），这会带来性能开销。为了缓解这个问题，大多数标准库的 <code>std::function</code> 实现都采用了<strong>小对象优化</strong>。</p><p>如果赋给 <code>std::function</code> 的可调用对象足够小（比如一个不捕获任何东西的 Lambda 或一个小的函数对象），它会被直接存储在 <code>std::function</code> 对象自身的内存缓冲区中，从而避免了堆分配。这大大提高了在这些常见情况下的性能。</p><h4 id="性能考量"><a href="#性能考量" class="headerlink" title="性能考量"></a>性能考量</h4><ul><li><strong>调用开销</strong>: 调用 <code>std::function</code> 通常比直接调用函数或通过函数指针调用要慢，因为它可能涉及一次虚函数分派。</li><li><strong>构造&#x2F;赋值开销</strong>: 如果没有触发小对象优化，构造或赋值 <code>std::function</code> 会有一次堆内存分配的开销。</li><li><strong>内存占用</strong>: <code>std::function</code> 对象本身的大小通常是几个指针的大小，用于存储内部缓冲区和管理信息。</li></ul><hr><h3 id="5-实际应用场景"><a href="#5-实际应用场景" class="headerlink" title="5. 实际应用场景"></a>5. 实际应用场景</h3><h4 id="场景1：实现回调函数系统"><a href="#场景1：实现回调函数系统" class="headerlink" title="场景1：实现回调函数系统"></a>场景1：实现回调函数系统</h4><p>这是 <code>std::function</code> 的经典用途。比如一个定时器类，它在特定时间后执行一个回调。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Timer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">(<span class="type">int</span> milliseconds, std::function&lt;<span class="type">void</span>()&gt; on_timeout)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 存储回调</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;callback_ = on_timeout;</span><br><span class="line">        <span class="comment">// 启动一个线程或系统定时器...</span></span><br><span class="line">        <span class="comment">// ...在时间到了之后...</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;callback_) &#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;<span class="built_in">callback_</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::function&lt;<span class="type">void</span>()&gt; callback_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="场景2：作为策略模式的轻量级替代方案"><a href="#场景2：作为策略模式的轻量级替代方案" class="headerlink" title="场景2：作为策略模式的轻量级替代方案"></a>场景2：作为策略模式的轻量级替代方案</h4><p>在策略模式中，我们通常定义一个接口和多个实现类。如果策略很简单，<code>std::function</code> 可以提供一种更轻量级的方法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Context</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TextFormatter</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> FormattingStrategy = std::function&lt;std::<span class="built_in">string</span>(<span class="type">const</span> std::string&amp;)&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setStrategy</span><span class="params">(FormattingStrategy strategy)</span> </span>&#123;</span><br><span class="line">        strategy_ = std::<span class="built_in">move</span>(strategy);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> std::string&amp; text)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (strategy_) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="built_in">strategy_</span>(text) &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    FormattingStrategy strategy_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    TextFormatter formatter;</span><br><span class="line">    </span><br><span class="line">    formatter.<span class="built_in">setStrategy</span>([](<span class="type">const</span> std::string&amp; s) &#123; <span class="keyword">return</span> <span class="string">&quot;### &quot;</span> + s + <span class="string">&quot; ###&quot;</span>; &#125;);</span><br><span class="line">    formatter.<span class="built_in">print</span>(<span class="string">&quot;Title&quot;</span>); <span class="comment">// 输出: ### Title ###</span></span><br><span class="line"></span><br><span class="line">    formatter.<span class="built_in">setStrategy</span>([](<span class="type">const</span> std::string&amp; s) &#123; <span class="keyword">return</span> <span class="string">&quot;*** &quot;</span> + s + <span class="string">&quot; ***&quot;</span>; &#125;);</span><br><span class="line">    formatter.<span class="built_in">print</span>(<span class="string">&quot;Important&quot;</span>); <span class="comment">// 输出: *** Important ***</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="场景3：在容器中存储不同的操作"><a href="#场景3：在容器中存储不同的操作" class="headerlink" title="场景3：在容器中存储不同的操作"></a>场景3：在容器中存储不同的操作</h4><p>比如，构建一个命令分派器。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">std::map&lt;std::string, std::function&lt;<span class="type">void</span>()&gt;&gt; command_map;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">command_save</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Saving file...&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">command_exit</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Exiting application...&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line"></span><br><span class="line">command_map[<span class="string">&quot;save&quot;</span>] = command_save;</span><br><span class="line">command_map[<span class="string">&quot;exit&quot;</span>] = command_exit;</span><br><span class="line"></span><br><span class="line">std::string user_input = <span class="string">&quot;save&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (command_map.<span class="built_in">count</span>(user_input)) &#123;</span><br><span class="line">    command_map[user_input](); <span class="comment">// 调用 &quot;save&quot; 对应的函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="6-注意事项与最佳实践"><a href="#6-注意事项与最佳实践" class="headerlink" title="6. 注意事项与最佳实践"></a>6. 注意事项与最佳实践</h3><h4 id="空-std-function-的调用"><a href="#空-std-function-的调用" class="headerlink" title="空 std::function 的调用"></a>空 <code>std::function</code> 的调用</h4><p>如前所述，调用一个空的 <code>std::function</code> 会抛出 <code>std::bad_function_call</code> 异常。<strong>在调用前务必检查</strong>。</p><h4 id="捕获的生命周期问题"><a href="#捕获的生命周期问题" class="headerlink" title="捕获的生命周期问题"></a>捕获的生命周期问题</h4><p>当 Lambda 捕获变量时（尤其是按引用捕获 <code>[&amp;]</code>），你需要非常小心。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::function&lt;<span class="title">void</span><span class="params">()</span>&gt; <span class="title">create_bad_callback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> local_value = <span class="number">42</span>;</span><br><span class="line">    <span class="comment">// 错误！捕获了局部变量的引用</span></span><br><span class="line">    <span class="keyword">return</span> [&amp;]() &#123;</span><br><span class="line">        <span class="comment">// 当这个 Lambda 被调用时，local_value 已经销毁了！</span></span><br><span class="line">        <span class="comment">// 这会导致未定义行为（通常是程序崩溃）。</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; local_value &lt;&lt; std::endl; </span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::function&lt;<span class="type">void</span>()&gt; bad_func = <span class="built_in">create_bad_callback</span>();</span><br><span class="line">    <span class="built_in">bad_func</span>(); <span class="comment">// 危险操作！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>规则</strong>: 确保被 Lambda 捕获的对象的生命周期不短于 <code>std::function</code> 对象本身及其任何副本的生命周期。对于局部变量，要么按值捕获 <code>[=]</code>，要么使用 <code>std::shared_ptr</code> 等智能指针来管理生命周期。</p><h4 id="与模板的对比：何时使用-std-function"><a href="#与模板的对比：何时使用-std-function" class="headerlink" title="与模板的对比：何时使用 std::function"></a>与模板的对比：何时使用 <code>std::function</code></h4><ul><li><p><strong>使用模板</strong>: 当你可以在<strong>编译时</strong>确定可调用对象的类型，并且不需要在运行时更改它时，优先使用模板。模板会为每种类型生成专用代码，编译器可以进行内联等优化，性能最高（通常是零开销）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Callable&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">run_task</span><span class="params">(Callable task)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">task</span>(); <span class="comment">// 编译器可以直接内联</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>使用 <code>std::function</code></strong>: 当你需要<strong>在运行时</strong>存储或传递一个类型未知的可调用对象时，使用 <code>std::function</code>。这是典型的“运行时多态”场景，比如存储回调的容器、需要动态切换的策略等。你为此付出的代价是潜在的性能开销。</p></li></ul><hr><h3 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h3><p><code>std::function</code> 是现代 C++ 中一个强大而灵活的组件。它通过类型擦除技术，为 C++ 中各种形式的“可调用物”提供了一个统一的、类型安全的接口。</p><p><strong>要点回顾</strong>:</p><ul><li>它是<strong>通用的函数包装器</strong>。</li><li>它能存储<strong>函数、Lambda、Functor、成员函数</strong>等。</li><li>它是实现<strong>回调、事件处理和策略模式</strong>的利器。</li><li>使用它需要注意<strong>生命周期</strong>和<strong>性能开销</strong>。</li><li>在性能敏感且类型可在编译期确定的场景下，<strong>模板是更好的选择</strong>。</li></ul>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CPP学习笔记—右值引用和移动语义</title>
      <link href="/2025/10/22/CPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%92%8C%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89/"/>
      <url>/2025/10/22/CPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%92%8C%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89/</url>
      
        <content type="html"><![CDATA[<p>右值引用（Rvalue Reference）和移动语义（Move Semantics）是 C++11 中引入的最重要的特性之一，它极大地提升了 C++ 的性能，并使得一些新的编程范式（如资源所有权的唯一性）成为可能。</p><hr><h3 id="1-背景知识：左值（Lvalue）与右值（Rvalue）"><a href="#1-背景知识：左值（Lvalue）与右值（Rvalue）" class="headerlink" title="1. 背景知识：左值（Lvalue）与右值（Rvalue）"></a>1. 背景知识：左值（Lvalue）与右值（Rvalue）</h3><p>在 C++ 中，每一个表达式都有两个属性：<strong>类型（Type）</strong> 和 <strong>值类别（Value Category）</strong>。值类别中最基本的就是左值和右值。</p><h4 id="左值-Lvalue-Locator-Value"><a href="#左值-Lvalue-Locator-Value" class="headerlink" title="左值 (Lvalue - Locator Value)"></a>左值 (Lvalue - Locator Value)</h4><p>可以把它粗略地理解为 <strong>“有固定内存地址、可以被赋值”</strong> 的表达式。它就像一个有名字、有固定住址的“居民”。</p><ul><li><strong>特征</strong>：<ul><li>可以取地址（使用 <code>&amp;</code> 运算符）。</li><li>通常出现在赋值运算符 <code>=</code> 的左边。</li><li>在表达式结束后依然存在。</li></ul></li><li><strong>例子</strong>：<ul><li>变量名：<code>int x = 10;</code> (<code>x</code> 是一个左值)。</li><li>数组元素：<code>arr[0]</code>。</li><li>解引用的指针：<code>*p</code>。</li><li>返回左值引用的函数调用：<code>get_string_ref()</code>。</li></ul></li></ul><h4 id="右值-Rvalue-Read-Value"><a href="#右值-Rvalue-Read-Value" class="headerlink" title="右值 (Rvalue - Read Value)"></a>右值 (Rvalue - Read Value)</h4><p>可以把它粗略地理解为 <strong>“临时的、即将被销毁”</strong> 的值。它就像一个信件里的内容，读完就扔了，没有固定的“家”。</p><ul><li><strong>特征</strong>：<ul><li>不可以取地址。</li><li>不能出现在赋值运算符 <code>=</code> 的左边。</li><li>生命周期很短，通常在表达式结束时就被销毁。</li></ul></li><li><strong>例子</strong>：<ul><li>字面量：<code>10</code>, <code>true</code>, <code>&quot;hello&quot;</code>。</li><li>算术表达式的结果：<code>x + y</code>。</li><li>按值返回的函数调用：<code>get_string()</code>。</li><li><code>this</code> 指针。</li></ul></li></ul><p><strong>一个简单的区分方法</strong>：能对表达式取地址的就是左值，不能的就是右值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span>* p = &amp;a; <span class="comment">// 正确，a是左值</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* p_err = &amp;(a + <span class="number">1</span>); <span class="comment">// 错误！ a + 1 是一个临时结果，是右值，不能取地址</span></span><br></pre></td></tr></table></figure><hr><h3 id="2-C-11-前的困境：不必要的深拷贝"><a href="#2-C-11-前的困境：不必要的深拷贝" class="headerlink" title="2. C++11 前的困境：不必要的深拷贝"></a>2. C++11 前的困境：不必要的深拷贝</h3><p>考虑一个管理动态内存的类，比如一个简单的字符串类 <code>MyString</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyString</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">MyString</span>(<span class="type">const</span> <span class="type">char</span>* s = <span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;构造函数\n&quot;</span>;</span><br><span class="line">        _len = <span class="built_in">strlen</span>(s);</span><br><span class="line">        _data = <span class="keyword">new</span> <span class="type">char</span>[_len + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(_data, s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数 (深拷贝)</span></span><br><span class="line">    <span class="built_in">MyString</span>(<span class="type">const</span> MyString&amp; other) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;拷贝构造函数 (深拷贝)\n&quot;</span>;</span><br><span class="line">        _len = other._len;</span><br><span class="line">        _data = <span class="keyword">new</span> <span class="type">char</span>[_len + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(_data, other._data);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 拷贝赋值运算符 (深拷贝)</span></span><br><span class="line">    MyString&amp; <span class="keyword">operator</span>=(<span class="type">const</span> MyString&amp; other) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;拷贝赋值运算符 (深拷贝)\n&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">            <span class="keyword">delete</span>[] _data;</span><br><span class="line">            _len = other._len;</span><br><span class="line">            _data = <span class="keyword">new</span> <span class="type">char</span>[_len + <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">strcpy</span>(_data, other._data);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">MyString</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (_data) &#123;</span><br><span class="line">            <span class="keyword">delete</span>[] _data;</span><br><span class="line">            _data = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* _data;</span><br><span class="line">    <span class="type">size_t</span> _len;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在看一个场景：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MyString <span class="title">make_string</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">MyString</span>(<span class="string">&quot;world&quot;</span>); <span class="comment">// 返回一个临时对象 (右值)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyString <span class="title">s1</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;</span><br><span class="line">    MyString s2 = <span class="built_in">make_string</span>(); <span class="comment">// 问题在这里</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>make_string()</code> 函数返回了一个临时的 <code>MyString</code> 对象。这个临时对象是一个<strong>右值</strong>。为了用这个临时对象初始化 <code>s2</code>，编译器会调用<strong>拷贝构造函数</strong>：</p><ol><li>在 <code>make_string</code> 内部，构造一个 <code>MyString(&quot;world&quot;)</code> 对象。</li><li><code>make_string</code> 返回时，创建一个临时的 <code>MyString</code> 对象（右值）。</li><li>调用 <code>MyString</code> 的<strong>拷贝构造函数</strong>，将这个临时对象的内容<strong>深拷贝</strong>到 <code>s2</code> 中。这涉及：<ul><li>为 <code>s2._data</code> 分配新内存。</li><li>将临时对象的数据逐字节拷贝到新内存中。</li></ul></li><li>临时对象被销毁，其内部的 <code>_data</code> 被 <code>delete[]</code>。</li></ol><p><strong>问题</strong>：那个临时对象马上就要被销毁了，它里面的资源（<code>_data</code> 指向的内存）完全可以直接“偷”过来给 <code>s2</code> 用，而不是花大力气去重新分配内存并拷贝一遍内容。这种不必要的深拷贝在处理大型对象（如容器、矩阵、文件流等）时会造成巨大的性能浪费。</p><hr><h3 id="3-核心概念：右值引用（Rvalue-Reference）"><a href="#3-核心概念：右值引用（Rvalue-Reference）" class="headerlink" title="3. 核心概念：右值引用（Rvalue Reference）"></a>3. 核心概念：右值引用（Rvalue Reference）</h3><p>为了解决上述问题，C++11 引入了<strong>右值引用</strong>，专门用来“绑定”右值。</p><ul><li><strong>语法</strong>：<code>T&amp;&amp;</code> (类型 + 双与号)</li><li><strong>作用</strong>：<ol><li><strong>识别右值</strong>：通过函数重载，我们可以为左值和右值提供不同的实现。</li><li><strong>延长生命周期</strong>：虽然右值引用本身可以延长临时对象的生命周期（不常用），但其主要目的是在函数参数中识别出右值。</li></ol></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;          <span class="comment">// x 是左值</span></span><br><span class="line"><span class="type">int</span>&amp; ref_l = x;      <span class="comment">// 左值引用绑定到左值，正确</span></span><br><span class="line"><span class="type">int</span>&amp;&amp; ref_r = <span class="number">20</span>;    <span class="comment">// 右值引用绑定到右值，正确</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>&amp; ref_l2 = <span class="number">20</span>;    <span class="comment">// 错误！不能将左值引用绑定到右值</span></span><br><span class="line"><span class="type">int</span>&amp;&amp; ref_r2 = x;    <span class="comment">// 错误！不能将右值引用绑定到左值</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>特例</strong>：<code>const</code> 左值引用 (<code>const T&amp;</code>) 是一个“万能引用”，它可以绑定到左值、右值、<code>const</code> 对象和非 <code>const</code> 对象。这是 C++11 之前能够接收临时对象作为参数的原因。但它只提供了只读访问，我们无法修改它，也就无法“偷”走它的资源。</p></blockquote><p>有了右值引用，我们就可以通过函数重载来区分传入的是左值还是右值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">int</span>&amp; x)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;处理左值\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">int</span>&amp;&amp; x)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;处理右值\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">process</span>(a);      <span class="comment">// 输出: 处理左值</span></span><br><span class="line">    <span class="built_in">process</span>(<span class="number">20</span>);     <span class="comment">// 输出: 处理右值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="4-核心应用：移动语义（Move-Semantics）"><a href="#4-核心应用：移动语义（Move-Semantics）" class="headerlink" title="4. 核心应用：移动语义（Move Semantics）"></a>4. 核心应用：移动语义（Move Semantics）</h3><p>移动语义的核心思想是：<strong>对于即将消亡的对象（右值），我们不进行内容的“拷贝”，而是进行资源的“转移”或“窃取”。</strong></p><p>这是通过重载<strong>移动构造函数</strong>和<strong>移动赋值运算符</strong>来实现的，它们的参数都是右值引用。</p><h4 id="移动构造函数-Move-Constructor"><a href="#移动构造函数-Move-Constructor" class="headerlink" title="移动构造函数 (Move Constructor)"></a>移动构造函数 (Move Constructor)</h4><ul><li><strong>签名</strong>：<code>ClassName(ClassName&amp;&amp; other)</code></li><li><strong>实现</strong>：<ol><li>从 <code>other</code> 对象中“窃取”资源指针。</li><li>将 <code>other</code> 对象置于一个<strong>有效但无资源</strong>的状态（例如，将其内部指针设为 <code>nullptr</code>）。这至关重要，因为 <code>other</code> 的析构函数马上会被调用，我们不希望它释放我们刚刚偷走的资源。</li></ol></li></ul><p>我们来为 <code>MyString</code> 添加移动构造函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyString</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ... 其他成员函数 ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动构造函数</span></span><br><span class="line">    <span class="built_in">MyString</span>(MyString&amp;&amp; other) <span class="keyword">noexcept</span> &#123; <span class="comment">// noexcept 很重要，后面解释</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;移动构造函数 (资源转移)\n&quot;</span>;</span><br><span class="line">        <span class="comment">// 1. 窃取资源</span></span><br><span class="line">        _data = other._data;</span><br><span class="line">        _len = other._len;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 将 other 置于有效但无资源的状态</span></span><br><span class="line">        other._data = <span class="literal">nullptr</span>;</span><br><span class="line">        other._len = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在再看之前的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyString s2 = <span class="built_in">make_string</span>();</span><br></pre></td></tr></table></figure><ol><li><code>make_string()</code> 返回一个临时对象（右值）。</li><li>编译器发现有一个参数为 <code>MyString&amp;&amp;</code> 的构造函数，并且传入的实参是右值，完美匹配。</li><li>调用<strong>移动构造函数</strong>。<code>s2</code> 直接接管了临时对象的 <code>_data</code> 指针，几乎没有成本。</li><li>临时对象的析构函数被调用，但此时它的 <code>_data</code> 已经是 <code>nullptr</code>，<code>delete[] nullptr</code> 是安全无害的操作。</li></ol><p><strong>结果</strong>：没有了昂贵的内存分配和数据拷贝，性能大幅提升！</p><h4 id="移动赋值运算符-Move-Assignment-Operator"><a href="#移动赋值运算符-Move-Assignment-Operator" class="headerlink" title="移动赋值运算符 (Move Assignment Operator)"></a>移动赋值运算符 (Move Assignment Operator)</h4><ul><li><strong>签名</strong>：<code>ClassName&amp; operator=(ClassName&amp;&amp; other)</code></li><li><strong>实现</strong>：逻辑与移动构造函数类似，但需要先释放自己已有的资源。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyString</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ... 其他成员函数 ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动赋值运算符</span></span><br><span class="line">    MyString&amp; <span class="keyword">operator</span>=(MyString&amp;&amp; other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;移动赋值运算符 (资源转移)\n&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123; <span class="comment">// 防止自我移动</span></span><br><span class="line">            <span class="comment">// 1. 释放自身资源</span></span><br><span class="line">            <span class="keyword">delete</span>[] _data;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2. 窃取 other 的资源</span></span><br><span class="line">            _data = other._data;</span><br><span class="line">            _len = other._len;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3. 将 other 置于有效但无资源的状态</span></span><br><span class="line">            other._data = <span class="literal">nullptr</span>;</span><br><span class="line">            other._len = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>使用场景</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MyString <span class="title">s1</span><span class="params">(<span class="string">&quot;old&quot;</span>)</span></span>;</span><br><span class="line">s1 = <span class="built_in">make_string</span>(); <span class="comment">// 调用移动赋值运算符</span></span><br></pre></td></tr></table></figure><h4 id="noexcept-的重要性"><a href="#noexcept-的重要性" class="headerlink" title="noexcept 的重要性"></a><code>noexcept</code> 的重要性</h4><p>标准库中的许多容器（如 <code>std::vector</code>）在进行扩容等操作时，会把旧内存的元素移动到新内存。如果移动构造函数可能抛出异常，容器为了保证强异常安全（要么操作成功，要么对象状态回滚到操作前），就不敢使用移动操作，而会退回到更安全的拷贝操作。将移动操作标记为 <code>noexcept</code> 是在向编译器承诺“我的移动绝不抛异常”，这样容器等才能放心地使用移动语义进行优化。</p><hr><h3 id="5-关键工具：std-move"><a href="#5-关键工具：std-move" class="headerlink" title="5. 关键工具：std::move"></a>5. 关键工具：<code>std::move</code></h3><p>我们已经知道，右值引用不能绑定到左值。但有时我们有一个左值，并且<strong>确定它之后不再需要了</strong>，希望也能对它执行移动操作以提高性能。这时就需要 <code>std::move</code>。</p><ul><li><strong><code>std::move</code> 不做任何移动操作！</strong></li><li><strong><code>std::move</code> 的唯一功能是：将一个左值强制转换为右值引用。</strong></li></ul><p>它就像一个“强转”工具，它告诉编译器：“请把这个左值当作一个右值来处理，我保证它之后没用了，你可以放心地移动它的资源。”</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MyString <span class="title">s1</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;</span><br><span class="line"><span class="comment">// MyString s2 = s1; // 这里会调用拷贝构造函数，因为 s1 是左值</span></span><br><span class="line"></span><br><span class="line">MyString s3 = std::<span class="built_in">move</span>(s1); <span class="comment">// 调用移动构造函数</span></span><br><span class="line"><span class="comment">// 此时，s1 的资源已经被 s3 “偷走”了</span></span><br><span class="line"><span class="comment">// s1 处于一个“有效但未定义”的状态，不能再使用它的值，除非重新赋值</span></span><br></pre></td></tr></table></figure><p><strong>警告</strong>：使用 <code>std::move</code> 之后，原对象（上例中的 <code>s1</code>）的状态是“被掏空”了。虽然它仍然是一个合法的对象（可以被析构、被重新赋值），但你不应该再对其原始值做任何假设。访问一个被移动过的对象（除了赋值和析构）是未定义行为。</p><hr><h3 id="6-延伸话题：完美转发（Perfect-Forwarding）"><a href="#6-延伸话题：完美转发（Perfect-Forwarding）" class="headerlink" title="6. 延伸话题：完美转发（Perfect Forwarding）"></a>6. 延伸话题：完美转发（Perfect Forwarding）</h3><p>这是一个更高级的应用，主要用在泛型编程（模板）中。</p><p><strong>问题</strong>：假设我们要写一个工厂函数，它接收一些参数，然后用这些参数去构造一个对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function">std::unique_ptr&lt;MyString&gt; <span class="title">create_string</span><span class="params">(Args... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;MyString&gt;(args...); <span class="comment">// 把参数转发给 MyString 的构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们希望：</p><ul><li>如果传给 <code>create_string</code> 的是左值，那么 <code>MyString</code> 的构造函数也接收到左值。</li><li>如果传给 <code>create_string</code> 的是右值，那么 <code>MyString</code> 的构造函数也接收到右值（从而触发移动构造）。</li></ul><p>如果像上面那样写，<code>args</code> 在 <code>create_string</code> 函数内部本身是一个左值（因为它有名字），直接传递会导致右值变成左值，移动语义就失效了。</p><p>为了解决这个问题，C++11 提供了<strong>完美转发</strong>机制，它由两部分组成：</p><ol><li><p><strong>转发引用（Forwarding Reference，也叫万能引用 Universal Reference）</strong></p><ul><li>当模板参数 <code>T</code> 以 <code>T&amp;&amp;</code> 的形式出现在函数参数中时，它就是一个转发引用。</li><li>它既可以接收左值，也可以接收右值。</li><li><strong>引用折叠规则</strong>：<ul><li>传左值 <code>L</code> 给 <code>T&amp;&amp;</code>，<code>T</code> 被推导为 <code>L&amp;</code>，参数类型为 <code>L&amp; &amp;&amp;</code> -&gt; <code>L&amp;</code>。</li><li>传右值 <code>R</code> 给 <code>T&amp;&amp;</code>，<code>T</code> 被推导为 <code>R</code>，参数类型为 <code>R&amp;&amp;</code> -&gt; <code>R&amp;&amp;</code>。</li></ul></li></ul></li><li><p><strong><code>std::forward</code></strong></p><ul><li>一个<strong>条件转换</strong>工具，配合转发引用使用。</li><li>如果传递给转发引用的原始实参是右值，<code>std::forward</code> 就将其转换为右值引用。</li><li>如果传递给转发引用的原始实参是左值，<code>std::forward</code> 就什么都不做，保持其左值引用属性。</li></ul></li></ol><p>正确的工厂函数写法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function">std::unique_ptr&lt;MyString&gt; <span class="title">create_string</span><span class="params">(Args&amp;&amp;... args)</span> </span>&#123; <span class="comment">// Args&amp;&amp; 是转发引用</span></span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;MyString&gt;(std::forward&lt;Args&gt;(args)...); <span class="comment">// 使用 std::forward 完美转发</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyString <span class="title">s</span><span class="params">(<span class="string">&quot;template&quot;</span>)</span></span>;</span><br><span class="line">    <span class="built_in">create_string</span>(<span class="string">&quot;literal&quot;</span>);      <span class="comment">// &quot;literal&quot;是右值，MyString 的构造函数接收到右值</span></span><br><span class="line">    <span class="built_in">create_string</span>(s);              <span class="comment">// s 是左值，MyString 的拷贝构造函数接收到左值</span></span><br><span class="line">    <span class="built_in">create_string</span>(std::<span class="built_in">move</span>(s));   <span class="comment">// std::move(s)是右值，MyString 的移动构造函数接收到右值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 <code>T&amp;&amp;</code> 和 <code>std::forward</code> 的组合，我们实现了参数值类别的完美传递，确保了无论传递何种参数，都能调用到最合适的函数版本，充分利用移动语义。</p><hr><h3 id="7-总结与实践"><a href="#7-总结与实践" class="headerlink" title="7. 总结与实践"></a>7. 总结与实践</h3><h4 id="带来的好处"><a href="#带来的好处" class="headerlink" title="带来的好处"></a>带来的好处</h4><ol><li><strong>性能提升</strong>：极大地减少了临时对象和大型对象拷贝带来的开销，尤其是在函数返回值、容器操作（如 <code>push_back</code>）等场景。</li><li><strong>实现移动专有类型</strong>：一些资源是不能被复制，只能被转移的，例如文件句柄、网络套接字、线程所有权。移动语义使得 <code>std::unique_ptr</code>, <code>std::thread</code>, <code>std::fstream</code> 等“移动专有”（Move-only）类型成为可能。</li></ol><h4 id="实际应用场景"><a href="#实际应用场景" class="headerlink" title="实际应用场景"></a>实际应用场景</h4><ul><li><strong>STL 容器</strong>：<code>std::vector</code> 的 <code>push_back</code> 有两个重载版本，一个接收 <code>const T&amp;</code> (拷贝)，一个接收 <code>T&amp;&amp;</code> (移动)。当你 <code>push_back</code> 一个右值时，会触发移动操作。<code>emplace_back</code> 则利用完美转发，直接在容器内部构造元素，避免了任何拷贝和移动。</li><li><strong>智能指针</strong>：<code>std::unique_ptr</code> 禁止拷贝，但允许移动，清晰地表达了对所管理资源的“唯一所有权”的转移。</li><li><strong>函数返回值</strong>：现代 C++ 中，按值返回大型对象（如 <code>std::vector</code>）不再是性能杀手，因为编译器会利用移动语义（或返回值优化 RVO）来避免拷贝。</li></ul>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CPP学习笔记—现代C++的特性</title>
      <link href="/2025/10/22/CPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E7%8E%B0%E4%BB%A3C-%E7%9A%84%E7%89%B9%E6%80%A7/"/>
      <url>/2025/10/22/CPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E7%8E%B0%E4%BB%A3C-%E7%9A%84%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<p>C++11 被认为是 C++ 语言的一次重生，标志着“现代 C++”的开端。后续的标准则在这个基础上不断完善、增强和现代化。</p><hr><h3 id="一、-C-11：现代-C-的基石"><a href="#一、-C-11：现代-C-的基石" class="headerlink" title="一、 C++11：现代 C++ 的基石"></a>一、 C++11：现代 C++ 的基石</h3><p>C++11 是一次巨大的飞跃，引入了大量深刻影响 C++ 编程范式的特性。</p><h4 id="1-语言核心增强-提升易用性和表达力"><a href="#1-语言核心增强-提升易用性和表达力" class="headerlink" title="1. 语言核心增强 (提升易用性和表达力)"></a>1. 语言核心增强 (提升易用性和表达力)</h4><ul><li><p><strong><code>auto</code> 关键字</strong>：</p><ul><li><strong>是什么</strong>：自动类型推导。编译器可以根据变量的初始化表达式自动推导出其类型。</li><li><strong>为什么需要</strong>：避免编写冗长、复杂的类型名，特别是对于 STL 迭代器和模板类型。</li><li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 旧式</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt;::iterator it = my_vector.<span class="built_in">begin</span>();</span><br><span class="line"><span class="comment">// C++11</span></span><br><span class="line"><span class="keyword">auto</span> it_new = my_vector.<span class="built_in">begin</span>(); <span class="comment">// 自动推导为 std::vector&lt;int&gt;::iterator</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>nullptr</code></strong>：</p><ul><li><strong>是什么</strong>：一个类型安全的空指针常量，类型为 <code>std::nullptr_t</code>。</li><li><strong>为什么需要</strong>：解决了旧 <code>NULL</code> (通常是 <code>0</code> 或 <code>(void*)0</code>) 的类型不明确问题，后者在函数重载时可能导致歧义。</li><li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">char</span>*)</span></span>;</span><br><span class="line"><span class="built_in">foo</span>(<span class="literal">NULL</span>); <span class="comment">// 可能会调用 foo(int)，不符合预期</span></span><br><span class="line"><span class="built_in">foo</span>(<span class="literal">nullptr</span>); <span class="comment">// 明确调用 foo(char*)</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>基于范围的 <code>for</code> 循环 (Range-based for loop)</strong>：</p><ul><li><strong>是什么</strong>：一种更简洁的遍历容器或序列的语法。</li><li><strong>为什么需要</strong>：简化循环代码，减少因迭代器操作而出错的可能。</li><li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="comment">// 旧式</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = nums.<span class="built_in">begin</span>(); it != nums.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">    std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// C++11</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">    std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>统一初始化 (Uniform Initialization) &amp; 初始化列表 (<code>std::initializer_list</code>)</strong>：</p><ul><li><strong>是什么</strong>：使用花括号 <code>{}</code> 对变量、对象、数组、容器等进行统一的初始化。</li><li><strong>为什么需要</strong>：提供一种通用的、无歧义的初始化语法，防止“最令人烦恼的解析”（Most Vexing Parse）。</li><li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x&#123;<span class="number">0</span>&#125;;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">MyClass obj&#123;arg1, arg2&#125;; <span class="comment">// 调用构造函数</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>Lambda 表达式</strong>：</p><ul><li><strong>是什么</strong>：一种在代码中就地定义匿名函数的方式。</li><li><strong>为什么需要</strong>：极大地简化了向 STL 算法等传递“可调用对象”（callable）的过程。</li><li><strong>语法</strong>：<code>[捕获列表](参数列表) -&gt; 返回类型 { 函数体 }</code></li><li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">1</span>&#125;;</span><br><span class="line">std::<span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), [](<span class="type">int</span> a, <span class="type">int</span> b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a &lt; b; <span class="comment">// 就地定义一个比较函数</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>类型别名 (<code>using</code>)</strong>：</p><ul><li><strong>是什么</strong>：<code>using</code> 提供了比 <code>typedef</code> 更清晰、更强大的类型别名语法，并且可以用于模板。</li><li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> std::map&lt;std::string, <span class="type">int</span>&gt; OldMap; <span class="comment">// 旧式</span></span><br><span class="line"><span class="keyword">using</span> NewMap = std::map&lt;std::string, <span class="type">int</span>&gt;;  <span class="comment">// C++11</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> Vec = std::vector&lt;T&gt;; <span class="comment">// 别名模板</span></span><br><span class="line">Vec&lt;<span class="type">int</span>&gt; v;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="2-性能与资源管理"><a href="#2-性能与资源管理" class="headerlink" title="2. 性能与资源管理"></a>2. 性能与资源管理</h4><ul><li><p><strong>右值引用 (<code>&amp;&amp;</code>) 与移动语义 (Move Semantics)</strong>：</p><ul><li><strong>是什么</strong>：引入了新的引用类型“右值引用”，专门用于绑定到临时对象（右值）。“移动语义”允许将资源（如动态分配的内存）从一个对象“转移”到另一个对象，而不是进行昂贵的拷贝。</li><li><strong>为什么需要</strong>：大幅提升性能，避免对临时对象进行不必要的深拷贝。</li><li><strong>核心</strong>：通过定义<strong>移动构造函数</strong>和<strong>移动赋值运算符</strong>来实现。<code>std::move</code> 函数用于将一个左值强制转换为右值引用。</li><li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ResourceHolder</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 移动构造函数</span></span><br><span class="line">    <span class="built_in">ResourceHolder</span>(ResourceHolder&amp;&amp; other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        data = other.data; <span class="comment">// &quot;窃取&quot;资源</span></span><br><span class="line">        other.data = <span class="literal">nullptr</span>; <span class="comment">// 将源对象置于有效但空的状态</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span>* data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>智能指针 (Smart Pointers)</strong>：</p><ul><li><strong>是什么</strong>：在 <code>&lt;memory&gt;</code> 头文件中引入了 <code>std::unique_ptr</code>, <code>std::shared_ptr</code>, <code>std::weak_ptr</code>。</li><li><strong>为什么需要</strong>：利用 RAII（资源获取即初始化）原则，自动化内存管理，极大地减少了内存泄漏和悬挂指针的风险。<ul><li><code>std::unique_ptr</code>：<strong>独占所有权</strong>，轻量级，无法拷贝，但可以移动。</li><li><code>std::shared_ptr</code>：<strong>共享所有权</strong>，通过引用计数管理资源生命周期。</li><li><code>std::weak_ptr</code>：<code>shared_ptr</code> 的观察者，不增加引用计数，用于打破循环引用。</li></ul></li></ul></li><li><p><strong><code>constexpr</code></strong>：</p><ul><li><strong>是什么</strong>：编译时常量表达式。<code>constexpr</code> 函数可以在编译期求值（当其参数是编译期常量时），<code>constexpr</code> 变量则必须是编译期常量。</li><li><strong>为什么需要</strong>：将计算从运行时提前到编译时，提升性能，并允许这些值用于需要编译期常量的地方（如数组大小、模板参数）。</li><li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">factorial</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n &lt;= <span class="number">1</span> ? <span class="number">1</span> : n * <span class="built_in">factorial</span>(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> arr[<span class="built_in">factorial</span>(<span class="number">5</span>)]; <span class="comment">// 在编译时计算数组大小</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="3-并发编程"><a href="#3-并发编程" class="headerlink" title="3. 并发编程"></a>3. 并发编程</h4><ul><li><strong><code>std::thread</code></strong>：提供了标准化的线程库，用于创建和管理线程。</li><li><strong><code>std::mutex</code></strong>, <strong><code>std::lock_guard</code></strong>, <strong><code>std::unique_lock</code></strong>：提供了互斥锁机制，用于保护共享数据，防止数据竞争。</li><li><strong><code>std::atomic</code></strong>：提供了原子类型和操作，用于无锁编程。</li><li><strong><code>std::future</code></strong>, <strong><code>std::promise</code></strong>, <strong><code>std::async</code></strong>：提供了高级异步编程工具，用于管理异步任务的结果。</li></ul><h4 id="4-其他重要特性"><a href="#4-其他重要特性" class="headerlink" title="4. 其他重要特性"></a>4. 其他重要特性</h4><ul><li><strong>变长参数模板 (Variadic Templates)</strong>：允许模板接受任意数量的参数，是实现 <code>std::tuple</code>, <code>std::function</code> 等的基础。</li><li><strong><code>enum class</code> (强类型枚举)</strong>：解决了传统 <code>enum</code> 的作用域污染和隐式类型转换问题。</li><li><strong><code>final</code> 和 <code>override</code></strong>：<code>override</code> 确保派生类函数确实重写了基类的虚函数（否则编译错误），<code>final</code> 阻止类被继承或虚函数被再次重写。</li></ul><hr><h3 id="二、-C-14：对-C-11-的完善和优化"><a href="#二、-C-14：对-C-11-的完善和优化" class="headerlink" title="二、 C++14：对 C++11 的完善和优化"></a>二、 C++14：对 C++11 的完善和优化</h3><p>C++14 是一个小的修订版本，主要目标是修复 C++11 的一些问题并提供便利性改进。</p><ul><li><p><strong>泛型 Lambda (Generic Lambdas)</strong>：</p><ul><li><strong>是什么</strong>：允许在 Lambda 的参数中使用 <code>auto</code>，使其可以接受任意类型的参数。</li><li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> add = [](<span class="keyword">auto</span> a, <span class="keyword">auto</span> b) &#123; <span class="keyword">return</span> a + b; &#125;;</span><br><span class="line"><span class="built_in">add</span>(<span class="number">1</span>, <span class="number">2</span>);      <span class="comment">// a, b 是 int</span></span><br><span class="line"><span class="built_in">add</span>(<span class="number">1.5</span>, <span class="number">2.5</span>);  <span class="comment">// a, b 是 double</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>函数返回类型推导</strong>：</p><ul><li>普通函数也可以使用 <code>auto</code> 作为返回类型，编译器会自动推导。</li><li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a + b; &#125; <span class="comment">// 返回类型被推导为 int</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>std::make_unique</code></strong>：</p><ul><li>C++11 提供了 <code>std::make_shared</code>，但漏掉了 <code>std::make_unique</code>。C++14 补上了它。</li><li><strong>为什么需要</strong>：提供异常安全保证，并使代码更简洁。</li><li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 旧式</span></span><br><span class="line"><span class="function">std::unique_ptr&lt;MyClass&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> MyClass())</span></span>;</span><br><span class="line"><span class="comment">// C++14</span></span><br><span class="line"><span class="keyword">auto</span> p_new = std::<span class="built_in">make_unique</span>&lt;MyClass&gt;();</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>二进制字面量和数字分隔符</strong>：</p><ul><li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> binary_val = <span class="number">0b101010</span>; <span class="comment">// 二进制</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> large_num = <span class="number">1&#x27;000&#x27;000&#x27;000</span>; <span class="comment">// 数字分隔符，提高可读性</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>constexpr</code> 的扩展</strong>：放宽了对 <code>constexpr</code> 函数的限制，允许在其中使用局部变量、循环和 <code>if</code> 语句等。</p></li></ul><hr><h3 id="三、-C-17：现代化的又一次飞跃"><a href="#三、-C-17：现代化的又一次飞跃" class="headerlink" title="三、 C++17：现代化的又一次飞跃"></a>三、 C++17：现代化的又一次飞跃</h3><p>C++17 带来了大量实用的库和语言特性，显著提升了日常编程的效率和代码的清晰度。</p><ul><li><p><strong>结构化绑定 (Structured Bindings)</strong>：</p><ul><li><strong>是什么</strong>：允许用一条语句将 <code>struct</code>, <code>pair</code>, <code>tuple</code>, 数组等对象的成员或元素解构到独立的变量中。</li><li><strong>为什么需要</strong>：极大地简化了对复合类型成员的访问。</li><li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">std::map&lt;std::string, <span class="type">int</span>&gt; my_map;</span><br><span class="line"><span class="comment">// 旧式</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span>&amp; pair : my_map) &#123;</span><br><span class="line">    std::cout &lt;&lt; pair.first &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; pair.second &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// C++17</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span>&amp; [key, value] : my_map) &#123;</span><br><span class="line">    std::cout &lt;&lt; key &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>if</code> 和 <code>switch</code> 的初始化语句</strong>：</p><ul><li><strong>是什么</strong>：允许在 <code>if</code> 或 <code>switch</code> 语句中直接声明和初始化一个仅在该语句块内有效的变量。</li><li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">auto</span> it = my_map.<span class="built_in">find</span>(<span class="string">&quot;key&quot;</span>); it != my_map.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="comment">// &#x27;it&#x27; 只在 if 和 else 块中可见</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Found: &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>if constexpr</code></strong>：</p><ul><li><strong>是什么</strong>：一种在编译期进行条件判断的 <code>if</code> 语句。如果条件为假，对应的代码块将不会被编译。</li><li><strong>为什么需要</strong>：在模板元编程中，可以根据类型特性选择性地编译代码，避免了复杂的 SFINAE 技术。</li><li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">get_value</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(std::is_pointer_v&lt;T&gt;)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *t; <span class="comment">// 只有当 T 是指针类型时，这行代码才会被编译</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>库特性</strong>：</p><ul><li><strong><code>std::optional</code></strong>：表示一个可能存在或不存在的值，用于替代使用魔法值（如 <code>-1</code>）或空指针来表示“无值”的情况。</li><li><strong><code>std::variant</code></strong>：一个类型安全的联合体（union），可以在其生命周期内存储不同类型的值，但同一时间只能存储一种。</li><li><strong><code>std::any</code></strong>：一个可以存储任意可拷贝类型值的类型安全容器。</li><li><strong><code>std::filesystem</code></strong>：提供了标准化的文件系统操作库，可以跨平台地处理路径、文件和目录。</li><li><strong>并行算法 (Parallel Algorithms)</strong>：STL 的许多算法（如 <code>sort</code>, <code>for_each</code>）增加了并行执行策略，可以轻松利用多核 CPU。</li></ul></li><li><p><strong>折叠表达式 (Fold Expressions)</strong>：</p><ul><li><strong>是什么</strong>：一种简化对变长参数模板参数包进行操作的语法。</li><li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">sum</span><span class="params">(Args... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (args + ...); <span class="comment">// 将所有参数相加</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><h3 id="四、-C-20：革命性的新时代"><a href="#四、-C-20：革命性的新时代" class="headerlink" title="四、 C++20：革命性的新时代"></a>四、 C++20：革命性的新时代</h3><p>C++20 是继 C++11 之后最大的一次更新，引入了被称为“四大特性”的革命性功能。</p><ul><li><p><strong>Concepts (概念)</strong>：</p><ul><li><strong>是什么</strong>：对模板参数的约束。它允许我们明确指定模板参数必须满足哪些要求（如必须支持 <code>+</code> 运算，必须是可迭代的等）。</li><li><strong>为什么需要</strong>：解决了模板长期以来因 SFINAE 导致的极其晦涩难懂的编译错误信息。Concepts 提供了清晰、简洁的错误报告，并使模板接口的意图更加明确。</li><li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> Integral = std::is_integral_v&lt;T&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;Integral T&gt; <span class="comment">// T 必须满足 Integral 概念</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(T val)</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>Modules (模块)</strong>：</p><ul><li><strong>是什么</strong>：一种现代化的源码组织方式，旨在替代传统的头文件 <code>#include</code> 机制。</li><li><strong>为什么需要</strong>：<ol><li><strong>极大提升编译速度</strong>：模块只会被编译一次。</li><li><strong>避免宏污染</strong>：宏的作用域被限制在模块内部。</li><li><strong>明确的接口</strong>：通过 <code>export</code> 关键字明确指定对外暴露的内容。</li></ol></li></ul></li><li><p><strong>Coroutines (协程)</strong>：</p><ul><li><strong>是什么</strong>：一种可以被挂起（suspend）和恢复（resume）的函数，用于简化异步编程。</li><li><strong>为什么需要</strong>：让异步代码（如网络I&#x2F;O、事件循环）写起来像同步代码一样直观，避免了“回调地狱”（callback hell）。</li><li><strong>关键字</strong>：<code>co_await</code>, <code>co_yield</code>, <code>co_return</code>。</li></ul></li><li><p><strong>Ranges (范围库)</strong>：</p><ul><li><strong>是什么</strong>：一套全新的处理数据序列的组件和思想。它将算法和容器解耦，并支持惰性求值和函数式编程风格的管道操作。</li><li><strong>为什么需要</strong>：使代码更具表现力和组合性。</li><li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> results = nums | std::views::<span class="built_in">filter</span>([](<span class="type">int</span> n)&#123; <span class="keyword">return</span> n % <span class="number">2</span> == <span class="number">0</span>; &#125;)</span><br><span class="line">                      | std::views::<span class="built_in">transform</span>([](<span class="type">int</span> n)&#123; <span class="keyword">return</span> n * n; &#125;);</span><br><span class="line"><span class="comment">// results 是一个视图，只有在迭代时才会计算</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> n : results) &#123;</span><br><span class="line">    std::cout &lt;&lt; n &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 输出 4 16 36 64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>其他重要特性</strong>：</p><ul><li><strong>三路比较运算符 (<code>&lt;=&gt;</code>，宇宙飞船运算符)</strong>：自动生成所有六个比较运算符（<code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>）。</li><li><strong><code>consteval</code> 和 <code>constinit</code></strong>：更严格的编译期求值和初始化控制。</li><li><strong><code>std::format</code></strong>：一个现代化、类型安全且高性能的文本格式化库。</li></ul></li></ul><hr><h3 id="五、-展望-C-23-及未来"><a href="#五、-展望-C-23-及未来" class="headerlink" title="五、 展望 C++23 及未来"></a>五、 展望 C++23 及未来</h3><p>C++ 标准委员会继续以每三年一个版本的节奏推进语言发展。</p><ul><li><strong>C++23</strong> 已正式发布，主要特性包括：<ul><li><strong><code>std::expected</code></strong>：一个表示“期望的值或错误”的类型，是 <code>std::optional</code> 和异常处理的强大补充。</li><li><strong><code>std::mdspan</code></strong>：一个非拥有所有权的多维数组视图，是科学计算和高性能计算领域的重要工具。</li><li><strong>对 Ranges 的进一步增强</strong>：如 <code>std::views::zip</code>, <code>std::ranges::to</code> 等。</li><li><strong><code>import std;</code></strong>：将整个标准库作为命名模块导入，极大地简化了模块的使用。</li><li><strong><code>if consteval</code></strong>：更精细的编译期求值判断。</li></ul></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>从 C++11 到 C++23，C++ 的演进路径非常清晰：</p><ol><li><strong>提升易用性和安全性</strong>：通过 <code>auto</code>, 智能指针, <code>nullptr</code>, <code>enum class</code> 等特性降低了语言的学习曲线和出错率。</li><li><strong>增强表达能力和简洁性</strong>：Lambda, 范围 for, 结构化绑定, Ranges 等让代码更贴近问题本身，而非底层实现。</li><li><strong>拥抱现代化编程范式</strong>：全面支持并发、异步（协程）、函数式编程（Ranges）和元编程（Concepts, <code>if constexpr</code>）。</li><li><strong>解决历史遗留问题</strong>：Modules 旨在解决头文件系统带来的编译效率和代码隔离问题。</li></ol><p>学习现代 C++，通常意味着从 C++11&#x2F;14 开始，并逐步掌握 C++17 和 C++20 的核心特性。这些新标准共同构建了一个功能更强大、使用更安全、代码更优雅的 C++ 语言。</p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CPP学习笔记—模板</title>
      <link href="/2025/10/22/CPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E6%A8%A1%E6%9D%BF/"/>
      <url>/2025/10/22/CPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<h3 id="一、-什么是C-模板-What-are-C-Templates"><a href="#一、-什么是C-模板-What-are-C-Templates" class="headerlink" title="一、 什么是C++模板 (What are C++ Templates?)"></a>一、 什么是C++模板 (What are C++ Templates?)</h3><p>C++模板是 <strong>泛型编程（Generic Programming）</strong> 的核心工具。它允许我们编写与类型无关的代码，即编写一份代码，可以用于多种不同的数据类型。</p><p>可以把模板想象成一个 <strong>“代码的蓝图”或“配方”</strong> 。它本身并不是一个可以直接运行的函数或类，而是一个指令，告诉编译器如何根据我们提供的具体类型（如 <code>int</code>, <code>double</code>, <code>std::string</code> 或自定义类）来生成一个特定版本的函数或类。</p><p>这个在编译时根据模板生成具体类型代码的过程，称为<strong>模板实例化（Template Instantiation）</strong>。</p><h3 id="二、-为什么需要模板-Why-Do-We-Need-Templates"><a href="#二、-为什么需要模板-Why-Do-We-Need-Templates" class="headerlink" title="二、 为什么需要模板 (Why Do We Need Templates?)"></a>二、 为什么需要模板 (Why Do We Need Templates?)</h3><p>假设我们要写一个交换两个整数值的函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap_int</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果现在还需要交换两个 <code>double</code> 或 <code>string</code> 类型的值，我们就必须重载这个函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap_double</span><span class="params">(<span class="type">double</span>&amp; a, <span class="type">double</span>&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap_string</span><span class="params">(std::string&amp; a, std::string&amp; b)</span> </span>&#123;</span><br><span class="line">    std::string temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你会发现，这些函数的<strong>逻辑完全一样</strong>，唯一的区别就是处理的数据类型不同。这种代码重复是冗余且难以维护的。模板就是为了解决这个问题而生的。</p><p>使用模板，我们可以只写一个通用的 <code>swap</code> 函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap_generic</span><span class="params">(T&amp; a, T&amp; b)</span> </span>&#123;</span><br><span class="line">    T temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，这个 <code>swap_generic</code> 函数可以用于任何支持拷贝和赋值操作的类型。</p><h3 id="三、-模板的类型与使用"><a href="#三、-模板的类型与使用" class="headerlink" title="三、 模板的类型与使用"></a>三、 模板的类型与使用</h3><p>C++中的模板主要分为以下几类：</p><h4 id="1-函数模板-Function-Templates"><a href="#1-函数模板-Function-Templates" class="headerlink" title="1. 函数模板 (Function Templates)"></a>1. 函数模板 (Function Templates)</h4><p>这是最常见的模板形式，用于创建通用的函数。</p><p><strong>语法:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, ...&gt;</span><br><span class="line"><span class="function">return_type <span class="title">function_name</span><span class="params">(parameter_list)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>template &lt;...&gt;</code>: 模板声明，尖括号中是模板参数列表。</li><li><code>typename</code> 和 <code>class</code>: 在模板参数列表中，<code>typename</code> 和 <code>class</code> 关键字是完全等价的，可以互换使用。<code>typename</code> 在某些情况下更清晰地表明这是一个类型参数。</li><li><code>T1, T2</code>: 模板参数，通常用大写字母表示（如 <code>T</code>, <code>U</code>, <code>V</code>），它们是类型的占位符。</li></ul><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个简单的泛型max函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">max</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a &gt; b) ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 模板参数自动推导 (Template Argument Deduction)</span></span><br><span class="line">    <span class="comment">// 编译器看到 max(10, 20) 的调用，推导出 T 的类型是 int</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Max of 10, 20 is: &quot;</span> &lt;&lt; <span class="built_in">max</span>(<span class="number">10</span>, <span class="number">20</span>) &lt;&lt; std::endl; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编译器推导出 T 的类型是 double</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Max of 3.14, 2.71 is: &quot;</span> &lt;&lt; <span class="built_in">max</span>(<span class="number">3.14</span>, <span class="number">2.71</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编译器推导出 T 的类型是 char</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Max of &#x27;a&#x27;, &#x27;z&#x27; is: &quot;</span> &lt;&lt; <span class="built_in">max</span>(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;z&#x27;</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 显式指定模板参数 (Explicit Specification)</span></span><br><span class="line">    <span class="comment">// 当自动推导失败或不符合预期时，可以显式指定</span></span><br><span class="line">    <span class="comment">// 例如，max(10, 20.5) 会编译错误，因为编译器无法确定 T 是 int 还是 double</span></span><br><span class="line">    <span class="comment">// 我们可以显式指定 T 为 double</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Max of 10, 20.5 is: &quot;</span> &lt;&lt; <span class="built_in">max</span>&lt;<span class="type">double</span>&gt;(<span class="number">10</span>, <span class="number">20.5</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-类模板-Class-Templates"><a href="#2-类模板-Class-Templates" class="headerlink" title="2. 类模板 (Class Templates)"></a>2. 类模板 (Class Templates)</h4><p>类模板用于创建通用的类，例如容器（如 <code>vector</code>, <code>stack</code>）、智能指针等。</p><p><strong>语法:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ... 成员变量和成员函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">someMethod</span><span class="params">(T param)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T memberVar;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>示例：一个简单的栈（Stack）类</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> T&amp; element)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">T&amp; <span class="title">top</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;T&gt; elements;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// **注意：**类模板的成员函数定义在类外时，必须再次使用 template&lt;...&gt; 声明</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> Stack&lt;T&gt;::<span class="built_in">push</span>(<span class="type">const</span> T&amp; element) &#123;</span><br><span class="line">    elements.<span class="built_in">push_back</span>(element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> Stack&lt;T&gt;::<span class="built_in">pop</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;Stack&lt;T&gt;::pop(): empty stack&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    elements.<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T&amp; Stack&lt;T&gt;::<span class="built_in">top</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;Stack&lt;T&gt;::top(): empty stack&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> elements.<span class="built_in">back</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> Stack&lt;T&gt;::<span class="built_in">isEmpty</span>() <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> elements.<span class="built_in">empty</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 实例化一个处理 int 类型的栈</span></span><br><span class="line">    <span class="comment">// 对于类模板，必须显式指定模板参数</span></span><br><span class="line">    Stack&lt;<span class="type">int</span>&gt; intStack;</span><br><span class="line">    intStack.<span class="built_in">push</span>(<span class="number">10</span>);</span><br><span class="line">    intStack.<span class="built_in">push</span>(<span class="number">20</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Top of intStack: &quot;</span> &lt;&lt; intStack.<span class="built_in">top</span>() &lt;&lt; std::endl; <span class="comment">// 输出 20</span></span><br><span class="line">    intStack.<span class="built_in">pop</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Top of intStack after pop: &quot;</span> &lt;&lt; intStack.<span class="built_in">top</span>() &lt;&lt; std::endl; <span class="comment">// 输出 10</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实例化一个处理 std::string 类型的栈</span></span><br><span class="line">    Stack&lt;std::string&gt; stringStack;</span><br><span class="line">    stringStack.<span class="built_in">push</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    stringStack.<span class="built_in">push</span>(<span class="string">&quot;World&quot;</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Top of stringStack: &quot;</span> &lt;&lt; stringStack.<span class="built_in">top</span>() &lt;&lt; std::endl; <span class="comment">// 输出 &quot;World&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-变量模板-Variable-Templates-C-14"><a href="#3-变量模板-Variable-Templates-C-14" class="headerlink" title="3. 变量模板 (Variable Templates) (C++14)"></a>3. 变量模板 (Variable Templates) (C++14)</h4><p>C++14 引入了变量模板，允许我们定义一个模板化的变量。</p><p><strong>语法:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">constexpr</span> T my_variable = some_value;</span><br></pre></td></tr></table></figure><p><strong>示例：定义一个泛型的 PI 值</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">constexpr</span> T pi = <span class="built_in">T</span>(<span class="number">3.1415926535897932385</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 float 版本的 pi</span></span><br><span class="line">    <span class="type">float</span> pi_f = pi&lt;<span class="type">float</span>&gt;;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Pi (float): &quot;</span> &lt;&lt; std::<span class="built_in">setprecision</span>(<span class="number">10</span>) &lt;&lt; pi_f &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 double 版本的 pi</span></span><br><span class="line">    <span class="type">double</span> pi_d = pi&lt;<span class="type">double</span>&gt;;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Pi (double): &quot;</span> &lt;&lt; std::<span class="built_in">setprecision</span>(<span class="number">20</span>) &lt;&lt; pi_d &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 也可以直接使用</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Pi (int): &quot;</span> &lt;&lt; pi&lt;<span class="type">int</span>&gt; &lt;&lt; std::endl; <span class="comment">// 会被截断为 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-别名模板-Alias-Templates-C-11"><a href="#4-别名模板-Alias-Templates-C-11" class="headerlink" title="4. 别名模板 (Alias Templates) (C++11)"></a>4. 别名模板 (Alias Templates) (C++11)</h4><p>C++11 引入了 <code>using</code> 关键字来创建模板化的别名，比 <code>typedef</code> 更加强大和直观。</p><p><strong>语法:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> NewTypeName = SomeExistingType&lt;T, ...&gt;;</span><br></pre></td></tr></table></figure><p><strong>示例：为 <code>std::map</code> 创建一个更简洁的别名</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个别名模板，表示一个键为 std::string，值为泛型 T 的 map</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> StringMap = std::map&lt;std::string, T&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以用于更复杂的类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> VecPtr = std::vector&lt;T*&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用别名模板，代码更清晰</span></span><br><span class="line">    StringMap&lt;<span class="type">int</span>&gt; ageMap;</span><br><span class="line">    ageMap[<span class="string">&quot;Alice&quot;</span>] = <span class="number">30</span>;</span><br><span class="line">    ageMap[<span class="string">&quot;Bob&quot;</span>] = <span class="number">25</span>;</span><br><span class="line"></span><br><span class="line">    VecPtr&lt;<span class="type">double</span>&gt; doublePointers;</span><br><span class="line">    doublePointers.<span class="built_in">push_back</span>(<span class="keyword">new</span> <span class="built_in">double</span>(<span class="number">3.14</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... 清理 new 出来的内存</span></span><br><span class="line">    <span class="keyword">delete</span> doublePointers[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四、-模板的进阶主题"><a href="#四、-模板的进阶主题" class="headerlink" title="四、 模板的进阶主题"></a>四、 模板的进阶主题</h3><h4 id="1-非类型模板参数-Non-Type-Template-Parameters"><a href="#1-非类型模板参数-Non-Type-Template-Parameters" class="headerlink" title="1. 非类型模板参数 (Non-Type Template Parameters)"></a>1. 非类型模板参数 (Non-Type Template Parameters)</h4><p>模板参数不仅可以是类型，还可以是具体的<strong>常量表达式</strong>，如整型、指针、引用等。</p><p><strong>示例：一个固定大小的数组类</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span> <span class="comment">// std::array 就是一个很好的例子</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// T 是类型参数，N 是非类型参数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="type">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FixedArray</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T&amp; <span class="keyword">operator</span>[](<span class="type">size_t</span> index) &#123; <span class="keyword">return</span> data[index]; &#125;</span><br><span class="line">    <span class="type">const</span> T&amp; <span class="keyword">operator</span>[](<span class="type">size_t</span> index) <span class="type">const</span> &#123; <span class="keyword">return</span> data[index]; &#125;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> N; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T data[N]; <span class="comment">// 数组的大小在编译时就已确定</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个包含10个int的数组</span></span><br><span class="line">    FixedArray&lt;<span class="type">int</span>, <span class="number">10</span>&gt; intArray;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; intArray.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        intArray[i] = i * i;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;intArray[3] = &quot;</span> &lt;&lt; intArray[<span class="number">3</span>] &lt;&lt; std::endl; <span class="comment">// 输出 9</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个包含5个double的数组</span></span><br><span class="line">    FixedArray&lt;<span class="type">double</span>, <span class="number">5</span>&gt; doubleArray;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>std::array&lt;T, N&gt;</code> 就是使用这种技术实现的。</p><h4 id="2-模板特化-Template-Specialization"><a href="#2-模板特化-Template-Specialization" class="headerlink" title="2. 模板特化 (Template Specialization)"></a>2. 模板特化 (Template Specialization)</h4><p>有时候，一个通用的模板实现对于某个或某些特定类型可能不是最优的，或者根本不可行。这时，我们可以为这些特定类型提供一个“特供版”的实现，这就是模板特化。</p><h5 id="a-全特化-Full-Specialization"><a href="#a-全特化-Full-Specialization" class="headerlink" title="a. 全特化 (Full Specialization)"></a>a. 全特化 (Full Specialization)</h5><p>为模板的一个特定实例提供完整的、独立的定义。</p><p><strong>示例：比较两个 C 风格字符串</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span> <span class="comment">// for strcmp</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通用模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Comparer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">areEqual</span><span class="params">(<span class="type">const</span> T&amp; a, <span class="type">const</span> T&amp; b)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Using generic Comparer&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> a == b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对 const char* 类型的全特化版本</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Comparer</span>&lt;<span class="type">const</span> <span class="type">char</span>*&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">areEqual</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* a, <span class="type">const</span> <span class="type">char</span>* b)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Using specialized Comparer for const char*&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">strcmp</span>(a, b) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Comparer&lt;<span class="type">int</span>&gt;::<span class="built_in">areEqual</span>(<span class="number">10</span>, <span class="number">10</span>); <span class="comment">// 调用通用版本</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* s1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* s2 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    Comparer&lt;<span class="type">const</span> <span class="type">char</span>*&gt;::<span class="built_in">areEqual</span>(s1, s2); <span class="comment">// 调用特化版本</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通用模板比较 <code>const char*</code> 时，比较的是指针地址，这通常不是我们想要的。特化版本使用 <code>strcmp</code> 来比较字符串内容，这才是正确的行为。</p><h5 id="b-偏特化-Partial-Specialization"><a href="#b-偏特化-Partial-Specialization" class="headerlink" title="b. 偏特化 (Partial Specialization)"></a>b. 偏特化 (Partial Specialization)</h5><p>如果不想为某个具体类型特化，而是为<strong>某一类</strong>符合特定模式的类型进行特化，可以使用偏特化。偏特化只能用于类模板。</p><p><strong>示例：对所有指针类型进行特化</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通用版本</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TypeInfo</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;It&#x27;s a non-pointer type.&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对所有 T* (指针) 类型进行偏特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TypeInfo</span>&lt;T*&gt; &#123;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;It&#x27;s a pointer type!&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一个例子：对两个模板参数相同的 Pair 类进行偏特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Pair</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Pair</span>&lt;T, T&gt; &#123; <span class="comment">// 当 T 和 U 是同一种类型时的特化版本</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    TypeInfo&lt;<span class="type">int</span>&gt;::<span class="built_in">print</span>();      <span class="comment">// 匹配通用版本</span></span><br><span class="line">    TypeInfo&lt;<span class="type">double</span>*&gt;::<span class="built_in">print</span>();  <span class="comment">// 匹配 T* 偏特化版本</span></span><br><span class="line">    TypeInfo&lt;<span class="type">char</span>*&gt;::<span class="built_in">print</span>();    <span class="comment">// 匹配 T* 偏特化版本</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-变长参数模板-Variadic-Templates-C-11"><a href="#3-变长参数模板-Variadic-Templates-C-11" class="headerlink" title="3. 变长参数模板 (Variadic Templates) (C++11)"></a>3. 变长参数模板 (Variadic Templates) (C++11)</h4><p>C++11 引入了变长参数模板，允许模板接受任意数量、任意类型的参数。这对于实现 <code>printf</code>、<code>std::tuple</code>、<code>std::function</code> 等功能至关重要。</p><p><strong>语法:</strong><br>使用 <code>...</code> 来表示一个“参数包”（parameter pack）。</p><p><strong>示例：一个通用的 <code>print</code> 函数</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本情况：当没有参数时，停止递归</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归定义：处理第一个参数，然后用剩余的参数递归调用自己</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(T first, Args... args)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; first &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 处理第一个参数</span></span><br><span class="line">    <span class="built_in">print</span>(args...);           <span class="comment">// 递归调用，参数包 `args` 被展开</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello&quot;</span>, <span class="number">10</span>, <span class="number">3.14</span>, <span class="string">&#x27;a&#x27;</span>); <span class="comment">// 输出: Hello 10 3.14 a </span></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);          <span class="comment">// 输出: 1 2 3 4 5 </span></span><br><span class="line">    <span class="built_in">print</span>();                       <span class="comment">// 输出一个换行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>C++17 折叠表达式 (Fold Expressions)</strong><br>C++17 引入了折叠表达式，使得处理参数包更加简洁：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_cpp17</span><span class="params">(Args... args)</span> </span>&#123;</span><br><span class="line">    ( (std::cout &lt;&lt; args &lt;&lt; <span class="string">&quot; &quot;</span>), ... ); <span class="comment">// C++17 折叠表达式</span></span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="五、-模板的编译与实现机制"><a href="#五、-模板的编译与实现机制" class="headerlink" title="五、 模板的编译与实现机制"></a>五、 模板的编译与实现机制</h3><h4 id="1-编译时代码生成"><a href="#1-编译时代码生成" class="headerlink" title="1. 编译时代码生成"></a>1. 编译时代码生成</h4><p>模板本身不产生任何代码。只有当模板被<strong>实例化</strong>时（即被一个具体的类型使用时），编译器才会根据模板和指定的类型生成实际的 C++ 代码。<br>例如，<code>max(10, 20)</code> 会让编译器生成一个 <code>int max(int, int)</code> 的函数实例。<code>max(3.14, 2.71)</code> 会生成另一个 <code>double max(double, double)</code> 的函数实例。</p><h4 id="2-“包含模型”-Inclusion-Model"><a href="#2-“包含模型”-Inclusion-Model" class="headerlink" title="2. “包含模型” (Inclusion Model)"></a>2. “包含模型” (Inclusion Model)</h4><p>由于编译器需要在编译时访问模板的<strong>完整定义</strong>（而不仅仅是声明）来生成代码，所以模板的实现（函数体、类成员函数定义）通常必须放在头文件（<code>.h</code> 或 <code>.hpp</code>）中。</p><p>如果你将模板的声明放在 <code>.h</code> 文件，而将定义放在 <code>.cpp</code> 文件，那么在另一个 <code>.cpp</code> 文件中包含这个头文件并使用模板时，编译器将找不到模板的定义，导致链接错误（unresolved external symbol）。</p><p><strong>正确做法：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// my_template.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MY_TEMPLATE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MY_TEMPLATE_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">my_print</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义和声明都在头文件中</span></span><br><span class="line">    std::cout &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="六、-模板的优缺点"><a href="#六、-模板的优缺点" class="headerlink" title="六、 模板的优缺点"></a>六、 模板的优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol><li><strong>代码重用</strong>：一次编写，多处使用，减少了代码冗余。</li><li><strong>类型安全</strong>：所有类型检查都在编译时进行，不会有运行时的类型错误。</li><li><strong>高性能</strong>：模板是编译时多态，没有运行时开销（如虚函数的vtable查询）。生成的代码是针对特定类型高度优化的，与手写非模板代码的性能相当。</li><li><strong>泛型编程能力</strong>：是实现强大、灵活库（如STL）的基础。</li></ol><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol><li><strong>编译时间长</strong>：每次实例化都会生成新的代码，这会增加编译器的负担，导致编译时间变长。</li><li><strong>代码膨胀 (Code Bloat)</strong>：如果一个模板被多种类型大量实例化，最终生成的可执行文件体积可能会变大。</li><li><strong>错误信息复杂</strong>：模板代码的编译错误信息通常非常冗长、复杂，难以阅读和调试。因为错误可能发生在模板实例化的深层嵌套中。</li><li><strong>接口和实现紧耦合</strong>：模板的实现必须暴露在头文件中，破坏了接口与实现分离的原则。</li></ol><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>C++模板是一种极其强大的元编程工具，是现代C++的基石之一。它从简单的函数和类模板，到复杂的变长参数和特化技术，为开发者提供了编写高度通用、类型安全且高性能代码的能力。虽然它有编译时间长和错误信息复杂等缺点，但其带来的巨大优势使得它在系统编程、库开发等领域不可或缺。熟练掌握模板是成为一名高级C++程序员的必经之路。</p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令</title>
      <link href="/2025/10/20/Linux%E5%91%BD%E4%BB%A4/"/>
      <url>/2025/10/20/Linux%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h3 id="第一部分：Linux-命令行的基石"><a href="#第一部分：Linux-命令行的基石" class="headerlink" title="第一部分：Linux 命令行的基石"></a><strong>第一部分：Linux 命令行的基石</strong></h3><p>在开始学习具体命令之前，理解几个核心概念至关重要。</p><h4 id="1-什么是-Shell？"><a href="#1-什么是-Shell？" class="headerlink" title="1. 什么是 Shell？"></a><strong>1. 什么是 Shell？</strong></h4><p>你输入的命令并不是由 Linux 内核直接处理的。你是在和一个叫做 <strong>Shell</strong> 的程序交互。Shell 是一个命令解释器，它接收你输入的命令，解释它们，然后请求操作系统（Linux 内核）来执行。</p><ul><li><strong>常见的 Shell：</strong><ul><li><code>bash</code> (Bourne Again SHell)：绝大多数 Linux 发行版的默认 Shell。</li><li><code>zsh</code> (Z Shell)：功能更强大，配置更灵活，是很多开发者的最爱。</li><li><code>fish</code> (Friendly Interactive SHell)：开箱即用，有很好的自动补全和语法高亮功能。</li></ul></li></ul><p>本介绍将以最常见的 <code>bash</code> 为例。</p><h4 id="2-命令的基本结构"><a href="#2-命令的基本结构" class="headerlink" title="2. 命令的基本结构"></a><strong>2. 命令的基本结构</strong></h4><p>一个典型的 Linux 命令遵循以下结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command [options] [arguments]</span><br></pre></td></tr></table></figure><ul><li><strong><code>command</code> (命令)</strong>：你要执行的程序的名称，例如 <code>ls</code>, <code>cp</code>, <code>mkdir</code>。</li><li><strong><code>options</code> (选项&#x2F;标志)</strong>：用来修改命令的行为。通常以一个或两个破折号 (<code>-</code> 或 <code>--</code>) 开头。<ul><li>短选项：一个破折号后跟一个字母，例如 <code>-l</code>, <code>-a</code>。可以合并，如 <code>-la</code>。</li><li>长选项：两个破折号后跟一个单词，例如 <code>--list</code>, <code>--all</code>。</li></ul></li><li><strong><code>arguments</code> (参数)</strong>：命令作用的对象，通常是文件名、目录路径、URL 等。</li></ul><p><strong>示例：</strong><br><code>ls -l /home/user</code></p><ul><li><code>ls</code> 是命令。</li><li><code>-l</code> 是选项（长格式列出）。</li><li><code>/home/user</code> 是参数（要列出的目录）。</li></ul><h4 id="3-关键概念"><a href="#3-关键概念" class="headerlink" title="3. 关键概念"></a><strong>3. 关键概念</strong></h4><ul><li><strong>当前工作目录 (Current Working Directory)</strong>：你当前所在的目录位置。可以使用 <code>pwd</code> (Print Working Directory) 命令查看。</li><li><strong>路径 (Path)</strong>：文件或目录在文件系统中的位置。<ul><li><strong>绝对路径</strong>：从根目录 <code>/</code> 开始的完整路径，例如 <code>/home/user/documents/report.txt</code>。</li><li><strong>相对路径</strong>：从当前目录开始的路径。<ul><li><code>.</code> 代表当前目录。</li><li><code>..</code> 代表上一级目录。</li><li>例如，如果你在 <code>/home/user</code>，那么 <code>documents/report.txt</code> 就是一个相对路径。</li></ul></li></ul></li></ul><hr><h3 id="第二部分：按功能分类的核心命令"><a href="#第二部分：按功能分类的核心命令" class="headerlink" title="第二部分：按功能分类的核心命令"></a><strong>第二部分：按功能分类的核心命令</strong></h3><p>下面我们将命令按照它们的常见用途进行分类介绍。</p><h4 id="类别一：文件和目录管理"><a href="#类别一：文件和目录管理" class="headerlink" title="类别一：文件和目录管理"></a><strong>类别一：文件和目录管理</strong></h4><p>这是最基础也是最常用的一类命令。</p><ul><li><p><strong><code>ls</code> (List)</strong>：列出目录中的文件和子目录。</p><ul><li><code>ls</code>：列出当前目录内容。</li><li><code>ls -l</code>：长格式显示，包含权限、所有者、大小、修改日期等详细信息。</li><li><code>ls -a</code>：显示所有文件，包括以 <code>.</code> 开头的隐藏文件。</li><li><code>ls -h</code>：与 <code>-l</code> 结合使用 (<code>ls -lh</code>)，以人类可读的格式显示文件大小 (K, M, G)。</li><li><code>ls -t</code>：按修改时间排序。</li><li><strong>组合使用</strong>：<code>ls -lath</code> 是一个非常常用的组合。</li></ul></li><li><p><strong><code>cd</code> (Change Directory)</strong>：切换目录。</p><ul><li><code>cd /path/to/directory</code>：切换到指定目录。</li><li><code>cd ~</code> 或 <code>cd</code>：切换到当前用户的家目录。</li><li><code>cd ..</code>：切换到上一级目录。</li><li><code>cd -</code>：切换到上一次所在的目录。</li></ul></li><li><p><strong><code>pwd</code> (Print Working Directory)</strong>：显示当前工作目录的绝对路径。</p></li><li><p><strong><code>mkdir</code> (Make Directory)</strong>：创建新目录。</p><ul><li><code>mkdir new_folder</code>：在当前位置创建名为 <code>new_folder</code> 的目录。</li><li><code>mkdir -p project/src/main</code>：<code>-p</code> 选项可以递归创建多层目录。</li></ul></li><li><p><strong><code>rmdir</code> (Remove Directory)</strong>：删除 <strong>空</strong> 目录。</p></li><li><p><strong><code>touch</code> (Touch)</strong>：创建一个空文件，或更新已有文件的时间戳。</p><ul><li><code>touch new_file.txt</code></li></ul></li><li><p><strong><code>cp</code> (Copy)</strong>：复制文件或目录。</p><ul><li><code>cp source_file destination_file</code>：复制文件。</li><li><code>cp source_file destination_folder/</code>：将文件复制到指定目录。</li><li><code>cp -r source_folder destination_folder</code>：<code>-r</code> (recursive) 选项用于复制整个目录及其内容。</li></ul></li><li><p><strong><code>mv</code> (Move)</strong>：移动或重命名文件&#x2F;目录。</p><ul><li><code>mv old_name.txt new_name.txt</code>：重命名文件。</li><li><code>mv file.txt /path/to/destination/</code>：移动文件到另一个位置。</li></ul></li><li><p><strong><code>rm</code> (Remove)</strong>：删除文件或目录。<strong>这是一个非常危险的命令，删除后通常无法恢复！</strong></p><ul><li><code>rm file.txt</code>：删除文件。</li><li><code>rm -r folder_name</code>：<code>-r</code> (recursive) 递归删除整个目录及其所有内容。</li><li><code>rm -f</code>：<code>-f</code> (force) 强制删除，不进行任何提示。</li><li><strong><code>rm -rf /</code> 是 Linux 中最臭名昭著的命令，会删除整个系统，请永远不要尝试！</strong></li></ul></li></ul><h4 id="类别二：文本处理"><a href="#类别二：文本处理" class="headerlink" title="类别二：文本处理"></a><strong>类别二：文本处理</strong></h4><p>在 Linux 中，一切皆文件。处理文本是核心技能。</p><ul><li><p><strong><code>cat</code> (Concatenate)</strong>：查看、合并文件内容。</p><ul><li><code>cat file.txt</code>：在终端显示 <code>file.txt</code> 的全部内容。</li><li><code>cat file1.txt file2.txt &gt; new_file.txt</code>：将两个文件合并成一个新文件。</li></ul></li><li><p><strong><code>less</code> &#x2F; <code>more</code></strong>：分页查看文件内容。<code>less</code> 功能更强，允许前后翻页。</p><ul><li><code>less large_log_file.log</code></li><li>在 <code>less</code> 中，使用箭头键或 <code>PageUp</code>&#x2F;<code>PageDown</code> 翻页，按 <code>/</code> 进行搜索，按 <code>q</code> 退出。</li></ul></li><li><p><strong><code>head</code> &#x2F; <code>tail</code></strong>：查看文件的开头或结尾部分。</p><ul><li><code>head -n 20 file.txt</code>：查看文件的前 20 行（默认是 10 行）。</li><li><code>tail -n 20 file.txt</code>：查看文件的后 20 行。</li><li><code>tail -f /var/log/syslog</code>：<code>-f</code> (follow) 选项可以实时监控文件的追加内容，常用于查看日志。</li></ul></li><li><p><strong><code>grep</code> (Global Regular Expression Print)</strong>：在文本中搜索匹配的行。</p><ul><li><code>grep &quot;error&quot; log.txt</code>：在 <code>log.txt</code> 中查找包含 “error” 的行。</li><li><code>grep -i &quot;error&quot; log.txt</code>：<code>-i</code> (ignore case) 忽略大小写。</li><li><code>grep -r &quot;keyword&quot; /path/to/dir</code>：<code>-r</code> (recursive) 递归在目录中所有文件中搜索。</li><li><code>grep -v &quot;debug&quot;</code>：<code>-v</code> (invert match) 显示不匹配的行。</li></ul></li><li><p><strong><code>wc</code> (Word Count)</strong>：统计文件的行数、单词数、字节数。</p><ul><li><code>wc -l file.txt</code>：只统计行数。</li><li><code>wc -w file.txt</code>：只统计单词数。</li><li><code>wc -c file.txt</code>：只统计字节数。</li></ul></li></ul><h4 id="类别三：系统信息与管理"><a href="#类别三：系统信息与管理" class="headerlink" title="类别三：系统信息与管理"></a><strong>类别三：系统信息与管理</strong></h4><ul><li><p><strong><code>uname</code></strong>: 显示系统信息。</p><ul><li><code>uname -a</code>：显示所有详细信息（内核名称、版本、主机名等）。</li></ul></li><li><p><strong><code>df</code> (Disk Free)</strong>：查看磁盘空间使用情况。</p><ul><li><code>df -h</code>：<code>-h</code> (human-readable) 以更易读的格式显示。</li></ul></li><li><p><strong><code>du</code> (Disk Usage)</strong>：查看文件或目录占用的磁盘空间。</p><ul><li><code>du -sh /path/to/dir</code>：<code>-s</code> (summary) 只显示总大小，<code>-h</code> 以易读格式显示。</li></ul></li><li><p><strong><code>free</code></strong>: 查看内存和交换空间使用情况。</p><ul><li><code>free -h</code>：以易读格式显示。</li></ul></li><li><p><strong><code>top</code> &#x2F; <code>htop</code></strong>: 实时显示系统进程和资源占用情况。<code>htop</code> 是一个更强大、更友好的版本，通常需要单独安装。</p></li><li><p><strong><code>date</code></strong>: 显示或设置系统时间。</p></li><li><p><strong><code>history</code></strong>: 显示当前用户执行过的历史命令。</p></li></ul><h4 id="类别四：进程管理"><a href="#类别四：进程管理" class="headerlink" title="类别四：进程管理"></a><strong>类别四：进程管理</strong></h4><ul><li><p><strong><code>ps</code> (Process Status)</strong>：列出当前运行的进程。</p><ul><li><code>ps aux</code>：显示所有用户的所有进程（BSD 风格）。</li><li><code>ps -ef</code>：显示所有进程的完整格式（System V 风格）。</li><li>通常两者结合 <code>grep</code> 使用，如 <code>ps aux | grep nginx</code> 来查找 nginx 进程。</li></ul></li><li><p><strong><code>kill</code></strong>: 向进程发送信号（通常是终止）。</p><ul><li><code>kill PID</code>：终止指定 PID (Process ID) 的进程（发送 TERM 信号）。</li><li><code>kill -9 PID</code>：强制杀死进程（发送 KILL 信号），这是一种最后的手段。</li></ul></li><li><p><strong><code>killall</code></strong>: 按进程名称杀死进程。</p><ul><li><code>killall firefox</code></li></ul></li><li><p><strong><code>jobs</code>, <code>fg</code>, <code>bg</code></strong>: 作业控制。</p><ul><li>在一个命令后按 <code>Ctrl+Z</code> 可以将其暂停并放到后台。</li><li><code>jobs</code>：查看后台作业。</li><li><code>bg</code>：让一个暂停的作业在后台继续运行。</li><li><code>fg %N</code>：将第 N 个作业切换到前台运行。</li></ul></li></ul><h4 id="类别五：权限和所有权"><a href="#类别五：权限和所有权" class="headerlink" title="类别五：权限和所有权"></a><strong>类别五：权限和所有权</strong></h4><ul><li><p><strong><code>chmod</code> (Change Mode)</strong>：修改文件或目录的权限。</p><ul><li>权限分为读(r&#x3D;4)、写(w&#x3D;2)、执行(x&#x3D;1)三种。</li><li>对象分为所有者(u)、所属组(g)、其他用户(o)。</li><li><strong>数字模式</strong>：<code>chmod 755 script.sh</code><ul><li>7 &#x3D; 4+2+1 (rwx) -&gt; 所有者有读、写、执行权限。</li><li>5 &#x3D; 4+0+1 (r-x) -&gt; 所属组有读、执行权限。</li><li>5 &#x3D; 4+0+1 (r-x) -&gt; 其他用户有读、执行权限。</li></ul></li><li><strong>符号模式</strong>：<ul><li><code>chmod u+x file.txt</code>：为所有者(u)增加(+)执行(x)权限。</li><li><code>chmod g-w file.txt</code>：为所属组(g)移除(-)写(w)权限。</li><li><code>chmod o=r file.txt</code>：将其他用户(o)的权限设置为(&#x3D;)只读(r)。</li></ul></li><li><code>chmod -R 755 /path/to/dir</code>：递归修改目录及内部所有内容的权限。</li></ul></li><li><p><strong><code>chown</code> (Change Owner)</strong>：修改文件或目录的所有者和所属组。</p><ul><li><code>chown user:group file.txt</code></li><li><code>chown -R user:group /path/to/dir</code>：递归修改。</li></ul></li><li><p><strong><code>sudo</code> (Superuser Do)</strong>：以超级用户（root）的权限执行命令。</p><ul><li><code>sudo apt update</code>：需要 root 权限才能更新软件包列表。</li></ul></li></ul><h4 id="类别六：网络"><a href="#类别六：网络" class="headerlink" title="类别六：网络"></a><strong>类别六：网络</strong></h4><ul><li><p><strong><code>ping</code></strong>: 测试与另一台主机的网络连通性。</p><ul><li><code>ping google.com</code></li></ul></li><li><p><strong><code>ip</code> &#x2F; <code>ifconfig</code></strong>: 查看和配置网络接口。<code>ip</code> 是现代 Linux 系统中推荐的命令。</p><ul><li><code>ip addr show</code> 或 <code>ifconfig</code>：显示所有网络接口的 IP 地址等信息。</li></ul></li><li><p><strong><code>ssh</code> (Secure Shell)</strong>：安全地远程登录到另一台主机。</p><ul><li><code>ssh user@hostname</code></li></ul></li><li><p><strong><code>scp</code> (Secure Copy)</strong>：通过 SSH 安全地在本地和远程主机之间复制文件。</p><ul><li><code>scp local_file.txt user@remote:/path/</code>：本地复制到远程。</li><li><code>scp user@remote:/path/remote_file.txt .</code>：远程复制到本地当前目录。</li></ul></li><li><p><strong><code>rsync</code></strong>: 一个功能更强大的文件同步工具，支持增量同步。</p></li><li><p><strong><code>wget</code> &#x2F; <code>curl</code></strong>: 从网络上下载文件。<code>curl</code> 功能更强大，常用于 API 测试。</p><ul><li><code>wget https://example.com/file.zip</code></li><li><code>curl -O https://example.com/file.zip</code></li></ul></li><li><p><strong><code>netstat</code> &#x2F; <code>ss</code></strong>: 显示网络连接、路由表等信息。<code>ss</code> 是 <code>netstat</code> 的现代替代品，速度更快。</p><ul><li><code>ss -tunlp</code>：显示所有监听中的 TCP&#x2F;UDP 端口及对应的程序。</li></ul></li></ul><h4 id="类别七：搜索"><a href="#类别七：搜索" class="headerlink" title="类别七：搜索"></a><strong>类别七：搜索</strong></h4><ul><li><p><strong><code>find</code></strong>: 在文件系统中按条件搜索文件。</p><ul><li><code>find /path/to/search -name &quot;*.log&quot;</code>：按文件名搜索。</li><li><code>find . -type f -mtime -7</code>：在当前目录(.)下查找类型为文件(-type f)且在过去7天内被修改过(-mtime -7)的文件。</li><li><code>find . -size +100M</code>：查找大于 100MB 的文件。</li></ul></li><li><p><strong><code>locate</code></strong>: 使用一个预先建立的数据库来快速查找文件，速度比 <code>find</code> 快，但可能不是最新的。</p><ul><li><code>sudo updatedb</code>：更新数据库。</li><li><code>locate my_file.conf</code></li></ul></li></ul><h4 id="类别八：归档和压缩"><a href="#类别八：归档和压缩" class="headerlink" title="类别八：归档和压缩"></a><strong>类别八：归档和压缩</strong></h4><ul><li><p><strong><code>tar</code> (Tape Archive)</strong>：将多个文件或目录打包成一个 <code>.tar</code> 文件，也可以结合压缩工具使用。</p><ul><li><code>tar -cvf archive.tar /path/to/dir</code>：<strong>c</strong>(reate) 创建，<strong>v</strong>(erbose) 显示过程，<strong>f</strong>(ile) 指定文件名。</li><li><code>tar -xvf archive.tar</code>：<strong>x</strong>(extract) 解包。</li><li><code>tar -tvf archive.tar</code>：<strong>t</strong>(est) 查看包内文件列表。</li><li><strong>结合 gzip 压缩 (<code>.tar.gz</code> 或 <code>.tgz</code>)</strong>：<ul><li>压缩：<code>tar -czvf archive.tar.gz /path/to/dir</code></li><li>解压：<code>tar -xzvf archive.tar.gz</code></li></ul></li><li><strong>结合 bzip2 压缩 (<code>.tar.bz2</code>)</strong>: 使用 <code>-j</code> 选项。</li><li><strong>结合 xz 压缩 (<code>.tar.xz</code>)</strong>: 使用 <code>-J</code> 选项。</li></ul></li><li><p><strong><code>zip</code> &#x2F; <code>unzip</code></strong>: 用于处理 Windows 中常见的 <code>.zip</code> 格式。</p><ul><li><code>zip -r archive.zip /path/to/dir</code></li><li><code>unzip archive.zip</code></li></ul></li></ul><h4 id="类别九：软件包管理"><a href="#类别九：软件包管理" class="headerlink" title="类别九：软件包管理"></a><strong>类别九：软件包管理</strong></h4><p>不同的 Linux 发行版使用不同的包管理器。</p><ul><li><p><strong>Debian&#x2F;Ubuntu (使用 APT)</strong></p><ul><li><code>sudo apt update</code>：刷新可用软件包列表。</li><li><code>sudo apt upgrade</code>：升级所有已安装的软件包。</li><li><code>sudo apt install package_name</code>：安装一个新包。</li><li><code>sudo apt remove package_name</code>：卸载一个包。</li><li><code>apt search keyword</code>：搜索软件包。</li></ul></li><li><p><strong>Red Hat&#x2F;CentOS&#x2F;Fedora (使用 DNF&#x2F;YUM)</strong></p><ul><li><code>sudo dnf check-update</code></li><li><code>sudo dnf upgrade</code></li><li><code>sudo dnf install package_name</code></li><li><code>sudo dnf remove package_name</code></li><li><code>dnf search keyword</code></li></ul></li></ul><hr><h3 id="第三部分：命令的组合与重定向"><a href="#第三部分：命令的组合与重定向" class="headerlink" title="第三部分：命令的组合与重定向"></a><strong>第三部分：命令的组合与重定向</strong></h3><p>单个命令功能有限，但将它们组合起来，威力无穷。</p><h4 id="1-I-O-重定向"><a href="#1-I-O-重定向" class="headerlink" title="1. I&#x2F;O 重定向"></a><strong>1. I&#x2F;O 重定向</strong></h4><ul><li><p><strong><code>&gt;</code> (输出重定向)</strong>：将命令的 <strong>标准输出 (stdout)</strong> 重定向到一个文件（会覆盖文件原有内容）。</p><ul><li><code>ls -l &gt; file_list.txt</code>：将 <code>ls -l</code> 的结果写入 <code>file_list.txt</code>。</li></ul></li><li><p><strong><code>&gt;&gt;</code> (追加重定向)</strong>：将标准输出追加到文件末尾。</p><ul><li><code>echo &quot;New log entry&quot; &gt;&gt; app.log</code></li></ul></li><li><p><strong><code>&lt;</code> (输入重定向)</strong>：将文件的内容作为命令的 <strong>标准输入 (stdin)</strong>。</p><ul><li><code>wc -l &lt; file_list.txt</code>：统计 <code>file_list.txt</code> 的行数。</li></ul></li><li><p><strong><code>2&gt;</code> (错误重定向)</strong>：将命令的 <strong>标准错误 (stderr)</strong> 重定向到一个文件。</p><ul><li><code>command_that_fails 2&gt; error.log</code></li></ul></li><li><p><strong><code>&amp;&gt;</code> 或 <code>2&gt;&amp;1</code></strong>: 将标准输出和标准错误都重定向到同一个地方。</p><ul><li><code>./run_script.sh &gt; script.log 2&gt;&amp;1</code></li></ul></li></ul><h4 id="2-管道-Pipe"><a href="#2-管道-Pipe" class="headerlink" title="2. 管道 (Pipe |)"></a><strong>2. 管道 (Pipe <code>|</code>)</strong></h4><p>管道是 Linux 中最强大的功能之一。它将前一个命令的 <strong>标准输出</strong> 直接作为后一个命令的 <strong>标准输入</strong>，形成一个处理流水线。</p><p><strong>经典示例：</strong></p><ol><li><p><strong>统计当前目录下的文件数量：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -l | grep <span class="string">&quot;^-&quot;</span> | <span class="built_in">wc</span> -l</span><br></pre></td></tr></table></figure><ul><li><code>ls -l</code>：列出详细信息。</li><li><code>grep &quot;^-&quot;</code>：筛选出以 <code>-</code> 开头的行（这些是文件，目录以 <code>d</code> 开头）。</li><li><code>wc -l</code>：统计最终结果的行数。</li></ul></li><li><p><strong>查找占用 CPU 最多的 5 个进程：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps aux --<span class="built_in">sort</span>=-%cpu | <span class="built_in">head</span> -n 6</span><br></pre></td></tr></table></figure><ul><li><code>ps aux --sort=-%cpu</code>：列出所有进程，并按 CPU 使用率降序排序。</li><li><code>head -n 6</code>：取前 6 行（包括标题行）。</li></ul></li></ol><hr><h3 id="第四部分：如何获取帮助？"><a href="#第四部分：如何获取帮助？" class="headerlink" title="第四部分：如何获取帮助？"></a><strong>第四部分：如何获取帮助？</strong></h3><p>你不可能记住所有命令和选项。学会如何查找帮助至关重要。</p><ul><li><p><strong><code>man</code> (Manual)</strong>：查看命令的官方手册页。这是最权威的帮助来源。</p><ul><li><code>man ls</code>：查看 <code>ls</code> 的手册。在 <code>man</code> 页面中，按 <code>q</code> 退出。</li></ul></li><li><p><strong><code>command --help</code></strong>: 大多数命令都支持 <code>--help</code> 选项，可以快速显示其用法和选项列表。</p><ul><li><code>ls --help</code></li></ul></li><li><p><strong><code>info</code></strong>: 提供比 <code>man</code> 更详细的 GNU 文档。</p><ul><li><code>info coreutils</code></li></ul></li><li><p><strong><code>apropos</code> 或 <code>man -k</code></strong>: 根据关键词搜索相关的 <code>man</code> 页面。</p><ul><li><code>apropos &quot;copy files&quot;</code></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>I/O多路复用</title>
      <link href="/2025/10/20/I-O%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"/>
      <url>/2025/10/20/I-O%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>I&#x2F;O 多路复用（I&#x2F;O Multiplexing）是一种在计算机网络编程中至关重要的技术，也是构建高性能服务器的基石。</p><hr><h3 id="1-背景：为什么需要-I-O-多路复用？"><a href="#1-背景：为什么需要-I-O-多路复用？" class="headerlink" title="1. 背景：为什么需要 I&#x2F;O 多路复用？"></a>1. 背景：为什么需要 I&#x2F;O 多路复用？</h3><p>想象一下你要开发一个网络服务器，需要同时处理多个客户端的连接。我们来看看几种最原始的模型以及它们的缺陷。</p><h4 id="模型一：阻塞-I-O-多进程-多线程"><a href="#模型一：阻塞-I-O-多进程-多线程" class="headerlink" title="模型一：阻塞 I&#x2F;O + 多进程&#x2F;多线程"></a>模型一：阻塞 I&#x2F;O + 多进程&#x2F;多线程</h4><p>这是最直观的模型。主进程负责监听（<code>listen</code>）新的连接请求。每当有一个新的客户端连接进来（<code>accept</code>），服务器就创建一个新的进程或线程专门为这个客户端服务。</p><ul><li><p><strong>工作流程</strong>：</p><ol><li>主线程&#x2F;进程 <code>accept()</code> 等待新连接，阻塞。</li><li>新连接到达，<code>accept()</code> 返回一个新的<code>socket</code>文件描述符（<code>fd</code>）。</li><li>创建一个子线程&#x2F;进程，将这个新的<code>fd</code>交给它处理。</li><li>子线程&#x2F;进程在这个<code>fd</code>上调用 <code>read()</code>&#x2F;<code>recv()</code>，等待客户端发送数据，阻塞。</li><li>数据到达，<code>read()</code> 返回，处理数据，然后可能调用 <code>write()</code>&#x2F;<code>send()</code>，也可能阻塞。</li><li>主线程&#x2F;进程继续循环，等待下一个连接。</li></ol></li><li><p><strong>缺点</strong>：</p><ul><li><strong>资源开销巨大</strong>：每来一个连接就要创建一个线程&#x2F;进程。线程需要栈空间（通常是 MB 级别），进程开销更大。当连接数成千上万时（即著名的 <strong>C10K 问题</strong>），系统资源会迅速耗尽。</li><li><strong>上下文切换频繁</strong>：大量的线程&#x2F;进程会导致 CPU 在它们之间频繁切换，这本身就是一笔巨大的性能开销。</li></ul></li></ul><h4 id="模型二：非阻塞-I-O-忙轮询-Busy-Polling"><a href="#模型二：非阻塞-I-O-忙轮询-Busy-Polling" class="headerlink" title="模型二：非阻塞 I&#x2F;O + 忙轮询 (Busy-Polling)"></a>模型二：非阻塞 I&#x2F;O + 忙轮询 (Busy-Polling)</h4><p>为了解决阻塞问题，我们可以将 <code>socket</code> 设置为非阻塞模式。</p><ul><li><p><strong>工作流程</strong>：</p><ol><li>将监听 <code>socket</code> 和所有已连接的 <code>socket</code> 都设置为非阻塞。</li><li>用一个循环，不断地遍历所有的 <code>socket</code> 文件描述符。</li><li>对监听 <code>socket</code> 尝试调用 <code>accept()</code>，如果有新连接就处理，没有就立即返回错误（如 <code>EWOULDBLOCK</code>）。</li><li>对已连接的 <code>socket</code> 尝试调用 <code>read()</code>，如果有数据就处理，没有就立即返回错误。</li></ol></li><li><p><strong>缺点</strong>：</p><ul><li><strong>CPU 100%</strong>：无论 <code>socket</code> 是否活跃，这个循环都在疯狂地、无差别地遍历所有 <code>socket</code>，进行大量的无效系统调用。这会导致 CPU 使用率飙升，大部分时间都在做无用功。</li></ul></li></ul><p>这两种模型都有致命的缺陷。我们需要一种更优雅的方式：<strong>既能避免为每个连接创建线程，又能避免 CPU 空转。</strong></p><hr><h3 id="2-核心思想：它到底是什么？"><a href="#2-核心思想：它到底是什么？" class="headerlink" title="2. 核心思想：它到底是什么？"></a>2. 核心思想：它到底是什么？</h3><p><strong>I&#x2F;O 多路复用</strong> 就是为了解决上述问题而生的。</p><p>它的核心思想可以概括为：<strong>将“等待”这个任务交给操作系统内核去做。</strong></p><ul><li><strong>“I&#x2F;O”</strong>：指的是网络 I&#x2F;O，如 <code>read</code>、<code>write</code>。</li><li><strong>“多路”</strong>：指的是多个网络连接，即多个 <code>socket</code> 文件描述符（<code>fd</code>）。</li><li><strong>“复用”</strong>：指的是复用同一个线程（或少量线程）来处理这些连接。</li></ul><p><strong>技术上讲，I&#x2F;O 多路复用是一种同步I&#x2F;O模型。</strong> 它的关键是一个能够<strong>同时监视多个文件描述符</strong>的系统调用（如 <code>select</code>, <code>poll</code>, <code>epoll</code>）。这个调用会<strong>阻塞</strong>，直到一个或多个 <code>fd</code> 变为“就绪”状态（比如可读、可写、或出错）。当调用返回时，它会告诉我们哪些 <code>fd</code> 已经准备好了，然后我们的单个线程就可以去依次处理这些就绪的 <code>fd</code>，而不会在未就绪的 <code>fd</code> 上浪费时间。</p><hr><h3 id="3-三种主要实现：select-poll-epoll"><a href="#3-三种主要实现：select-poll-epoll" class="headerlink" title="3. 三种主要实现：select, poll, epoll"></a>3. 三种主要实现：<code>select</code>, <code>poll</code>, <code>epoll</code></h3><p>这三种是 Linux 系统下 I&#x2F;O 多路复用的主要实现机制。</p><h4 id="A-select"><a href="#A-select" class="headerlink" title="A. select"></a>A. <code>select</code></h4><p><code>select</code> 是最早的、最通用的 I&#x2F;O 多路复用实现，几乎所有操作系统都支持。</p><ul><li><p><strong>工作方式</strong>：</p><ol><li>你需要创建三个文件描述符集合（<code>fd_set</code>），分别用于监视<strong>可读</strong>、<strong>可写</strong>和<strong>异常</strong>事件。<code>fd_set</code> 本质上是一个位图（bitmask）。</li><li>将你关心的 <code>fd</code> 添加到相应的集合中。</li><li>调用 <code>select(max_fd + 1, &amp;read_fds, &amp;write_fds, &amp;except_fds, &amp;timeout)</code>。</li><li><code>select</code> 函数会阻塞，直到有 <code>fd</code> 就绪或者超时。</li><li>函数返回后，<code>fd_set</code> 会被内核修改，只有那些就绪的 <code>fd</code> 对应的位仍然是 1。</li><li>你需要遍历整个 <code>fd_set</code>（从 0 到 <code>max_fd</code>），检查哪个 <code>fd</code> 对应的位是 1，然后处理它。</li></ol></li><li><p><strong>缺点</strong>：</p><ol><li><strong>最大连接数限制</strong>：<code>fd_set</code> 的大小是固定的（通常是 1024 或 2048），由 <code>FD_SETSIZE</code> 宏定义，这限制了 <code>select</code> 能同时监视的 <code>fd</code> 数量。</li><li><strong>重复的数据拷贝</strong>：每次调用 <code>select</code> 前，都需要重新构建 <code>fd_set</code>，因为内核会修改它。并且，每次调用时，都需要将这个 <code>fd_set</code> 从用户空间完整地拷贝到内核空间。连接数越多，拷贝开销越大。</li><li><strong>线性扫描开销</strong>：<code>select</code> 返回后，你只知道“有 <code>fd</code> 就绪了”，但不知道是哪几个。你必须遍历所有被监视的 <code>fd</code> 来找到就绪的那些。如果监视了 1000 个 <code>fd</code>，但只有 1 个就绪，你仍然要做 1000 次检查。这个开销是 O(N)，N 是被监视的 <code>fd</code> 总数。</li></ol></li></ul><h4 id="B-poll"><a href="#B-poll" class="headerlink" title="B. poll"></a>B. <code>poll</code></h4><p><code>poll</code> 是对 <code>select</code> 的改进，解决了 <code>select</code> 的一些问题。</p><ul><li><p><strong>工作方式</strong>：</p><ol><li><code>poll</code> 不再使用 <code>fd_set</code>，而是使用一个 <code>pollfd</code> 结构体数组。每个 <code>pollfd</code> 结构体包含 <code>fd</code>、关心的事件（<code>events</code>）和返回的实际发生的事件（<code>revents</code>）。</li><li>你创建一个 <code>pollfd</code> 数组，填入你关心的 <code>fd</code> 和事件。</li><li>调用 <code>poll(fds_array, num_fds, timeout)</code>。</li><li><code>poll</code> 返回后，你遍历这个数组，检查每个 <code>pollfd</code> 结构体的 <code>revents</code> 字段，来判断该 <code>fd</code> 是否就绪。</li></ol></li><li><p><strong>相比 <code>select</code> 的改进</strong>：</p><ol><li><strong>无最大连接数限制</strong>：它使用数组而非位图，理论上可以监视的 <code>fd</code> 数量只受限于系统内存。</li></ol></li><li><p><strong>仍然存在的缺点</strong>：</p><ol><li><strong>重复的数据拷贝</strong>：每次调用 <code>poll</code>，仍然需要将整个 <code>pollfd</code> 数组从用户空间拷贝到内核空间。</li><li><strong>线性扫描开销</strong>：<code>poll</code> 返回后，你仍然需要遍历整个 <code>pollfd</code> 数组来找到就绪的 <code>fd</code>。开销依然是 O(N)。</li></ol></li></ul><h4 id="C-epoll-Linux-特有"><a href="#C-epoll-Linux-特有" class="headerlink" title="C. epoll (Linux 特有)"></a>C. <code>epoll</code> (Linux 特有)</h4><p><code>epoll</code> 是对 <code>select</code> 和 <code>poll</code> 的重大改进，是 Linux 下实现高性能网络服务器的首选，它彻底解决了前两者的核心性能瓶瓶颈。</p><ul><li><p><strong>工作方式</strong>：<code>epoll</code> 将其功能分成了三个独立的系统调用。</p><ol><li><code>epoll_create()</code>: 在内核中创建一个 <code>epoll</code> 实例，并返回一个指向该实例的文件描述符（<code>epoll_fd</code>）。这个实例内部维护了需要监视的 <code>fd</code> 集合（通常是红黑树）和就绪 <code>fd</code> 列表（链表）。<strong>这个创建动作只需要一次</strong>。</li><li><code>epoll_ctl()</code>: 用于向 <code>epoll</code> 实例中<strong>添加</strong>（<code>EPOLL_CTL_ADD</code>）、<strong>修改</strong>（<code>EPOLL_CTL_MOD</code>）或<strong>删除</strong>（<code>EPOLL_CTL_DEL</code>）需要监视的 <code>fd</code>。每个 <code>fd</code> 只需要通过 <code>epoll_ctl</code> 添加一次，之后它就一直在内核的监视列表中，无需在每次等待时重复提交。</li><li><code>epoll_wait()</code>: 等待事件发生，类似于 <code>select</code> 和 <code>poll</code>。但它返回时，<strong>只会返回那些已经就绪的 <code>fd</code></strong>，而不是所有被监视的 <code>fd</code>。它会将就绪的 <code>fd</code> 列表从内核空间拷贝到用户空间的一个数组里。</li></ol></li><li><p><strong>相比 <code>select</code> 和 <code>poll</code> 的巨大优势</strong>：</p><ol><li><strong>无需重复拷贝</strong>：<code>fd</code> 列表通过 <code>epoll_ctl</code> 维护在内核中，调用 <code>epoll_wait</code> 时无需重复拷贝整个列表。</li><li><strong>没有线性扫描</strong>：<code>epoll</code> 的核心是事件驱动。当某个 <code>fd</code> 就绪时，内核会通过<strong>回调机制</strong>将其加入到一个就绪链表中。<code>epoll_wait</code> 只是检查这个链表是否为空，如果不为空，就返回链表中的内容。因此，其时间复杂度是 O(1)（或者说 O(k)，k 为就绪的 <code>fd</code> 数量），与被监视的 <code>fd</code> 总数无关！</li><li><strong>内存共享 (mmap)</strong>: <code>epoll</code> 通过 <code>mmap</code> 技术让内核和用户空间共享一块内存，进一步避免了不必要的内存拷贝。</li></ol></li></ul><hr><h3 id="4-详细对比：select-vs-poll-vs-epoll"><a href="#4-详细对比：select-vs-poll-vs-epoll" class="headerlink" title="4. 详细对比：select vs poll vs epoll"></a>4. 详细对比：<code>select</code> vs <code>poll</code> vs <code>epoll</code></h3><table><thead><tr><th align="left">特性</th><th align="left"><code>select</code></th><th align="left"><code>poll</code></th><th align="left"><code>epoll</code></th></tr></thead><tbody><tr><td align="left"><strong>底层数据结构</strong></td><td align="left">位图 (Bitmask)</td><td align="left">结构体数组 (Array of structs)</td><td align="left">红黑树 + 双向链表</td></tr><tr><td align="left"><strong>FD 数量限制</strong></td><td align="left">有，通常是 1024 (<code>FD_SETSIZE</code>)</td><td align="left">无 (受限于内存)</td><td align="left">无 (受限于内存)</td></tr><tr><td align="left"><strong>用户&#x2F;内核拷贝</strong></td><td align="left">每次调用都拷贝整个 <code>fd_set</code></td><td align="left">每次调用都拷贝整个 <code>pollfd</code> 数组</td><td align="left">初始 <code>epoll_ctl</code> 时拷贝，<code>epoll_wait</code> 只拷贝就绪的 fd</td></tr><tr><td align="left"><strong>内核扫描方式</strong></td><td align="left">线性扫描所有被监视的 fd</td><td align="left">线性扫描所有被监视的 fd</td><td align="left">事件回调，只处理活跃的 fd</td></tr><tr><td align="left"><strong>效率</strong></td><td align="left">O(N)</td><td align="left">O(N)</td><td align="left">O(1) 或 O(k) (k为活跃连接数)</td></tr><tr><td align="left"><strong>可移植性</strong></td><td align="left">非常好，所有主流系统支持</td><td align="left">较好，大部分 Unix-like 系统支持</td><td align="left">差，仅 Linux 2.6+ 支持</td></tr><tr><td align="left"><strong>API 使用</strong></td><td align="left">简单，但每次调用需重置 <code>fd_set</code></td><td align="left">简单</td><td align="left">稍复杂，分为 <code>create</code>, <code>ctl</code>, <code>wait</code></td></tr></tbody></table><p><strong>总结</strong>：在连接数少、且都比较活跃的情况下，<code>select</code> 和 <code>poll</code> 的性能尚可。但在高并发、大量连接（其中大部分是空闲的）场景下，<code>epoll</code> 的性能优势是压倒性的。</p><hr><h3 id="5-工作模式：水平触发-LT-vs-边沿触发-ET"><a href="#5-工作模式：水平触发-LT-vs-边沿触发-ET" class="headerlink" title="5. 工作模式：水平触发 (LT) vs 边沿触发 (ET)"></a>5. 工作模式：水平触发 (LT) vs 边沿触发 (ET)</h3><p>首先，我们要明白“触发”指的是什么。在 <code>epoll</code> 的语境下，“触发”是指<strong>当一个被监视的文件描述符（<code>fd</code>）满足了我们所关心的事件（如可读、可写）时，<code>epoll_wait</code> 会被唤醒并返回该 <code>fd</code></strong>。</p><p>LT 和 ET 的根本区别在于 <strong><code>epoll_wait</code> 被唤醒并返回的“时机”和“条件”</strong>。</p><h4 id="A、-水平触发-Level-Triggered-LT"><a href="#A、-水平触发-Level-Triggered-LT" class="headerlink" title="A、 水平触发 (Level Triggered, LT)"></a>A、 水平触发 (Level Triggered, LT)</h4><p>LT 是 <code>epoll</code> 的<strong>默认工作模式</strong>。它的行为模式非常直观，也和传统的 <code>select</code>、<code>poll</code> 类似。</p><p><strong>只要文件描述符处于某个我们关心的状态（State），<code>epoll_wait</code> 就会一直触发通知。</strong></p><ul><li><strong>对于读事件</strong>：只要该 <code>fd</code> 的内核接收缓冲区里<strong>有数据</strong>（缓冲区大小 &gt; 0），<code>epoll_wait</code> 每次被调用时都会返回这个 <code>fd</code>，告诉你“嘿，这里有数据，你可以读了！”。</li><li><strong>对于写事件</strong>：只要该 <code>fd</code> 的内核发送缓冲区<strong>没有满</strong>（还有空间可以写入），<code>epoll_wait</code> 每次被调用时都会返回这个 <code>fd</code>，告诉你“嘿，这里有地方，你可以写了！”。</li></ul><p>假设一个客户端发送了 1000 字节的数据到服务器。</p><ol><li><strong>数据到达</strong>：1000 字节数据进入了服务器端 <code>socket</code> 的内核接收缓冲区。</li><li><strong>第一次触发</strong>：应用程序调用 <code>epoll_wait</code>，它会立即返回，报告这个 <code>socket fd</code> 是可读的。</li><li><strong>不完整的处理</strong>：你的应用程序代码从这个 <code>fd</code> 中只读取了 500 字节，因为你程序里的 buffer 只有这么大。此时，内核缓冲区里还<strong>剩下 500 字节</strong>。</li><li><strong>再次调用 <code>epoll_wait</code></strong>：当你的事件循环下一次调用 <code>epoll_wait</code> 时，由于内核缓冲区里<strong>仍然有数据</strong>（满足“可读”状态），<code>epoll_wait</code> 会<strong>再一次</strong>立即返回，告诉你这个 <code>fd</code> 还是可读的。</li><li><strong>继续处理</strong>：你的程序再次读取剩下的 500 字节。现在内核缓冲区空了。</li><li><strong>停止触发</strong>：再下一次调用 <code>epoll_wait</code> 时，由于“可读”状态已经不存在，它将不会再因为这个 <code>fd</code> 而返回（除非有新数据到达）。</li></ol><ul><li><p><strong>优点</strong>：</p><ul><li><strong>编程简单，不易出错</strong>：它的逻辑非常稳健（robust）。即使你因为某些原因没有一次性把数据处理完，也不用担心数据会“丢失”事件通知。下一次循环 <code>epoll</code> 还会提醒你，给了你“亡羊补牢”的机会。</li><li><strong>与 <code>select</code>&#x2F;<code>poll</code> 兼容</strong>：行为模式一致，从旧模型迁移过来比较容易。</li></ul></li><li><p><strong>缺点</strong>：</p><ul><li><strong>可能导致不必要的唤醒</strong>：如果你的程序逻辑有问题，一直不去处理某个 <code>fd</code> 上的数据，<code>epoll_wait</code> 会被反复地、无效地唤醒，造成一点性能开销（尽管这个开销远小于 <code>select</code> 的 O(N) 扫描）。这在某种程度上是“惊群效应”的微缩版。</li></ul></li></ul><h4 id="B、-边沿触发-Edge-Triggered-ET"><a href="#B、-边沿触发-Edge-Triggered-ET" class="headerlink" title="B、 边沿触发 (Edge Triggered, ET)"></a>B、 边沿触发 (Edge Triggered, ET)</h4><p>ET 是一种更高性能但编程要求也更高的模式。要使用 ET 模式，你需要在 <code>epoll_ctl</code> 添加 <code>fd</code> 时明确指定 <code>EPOLLET</code> 标志。</p><p><strong>只有当文件描述符的状态发生变化（Transition &#x2F; Edge）时，<code>epoll_wait</code> 才会触发一次通知。</strong></p><ul><li><strong>对于读事件</strong>：只有当 <code>fd</code> 的内核接收缓冲区<strong>从空变为非空</strong>的那一刻，<code>epoll_wait</code> 才会返回这个 <code>fd</code>。之后，即使缓冲区里还有数据，只要没有<strong>新</strong>的数据到达，<code>epoll_wait</code> 也<strong>不会</strong>再返回这个 <code>fd</code>。</li><li><strong>对于写事件</strong>：只有当 <code>fd</code> 的内核发送缓冲区<strong>从满变为非满</strong>的那一刻，<code>epoll_wait</code> 才会返回这个 <code>fd</code>。</li></ul><p>同样，客户端发送了 1000 字节的数据到服务器。</p><ol><li><strong>数据到达</strong>：1000 字节数据进入内核缓冲区，状态从<strong>空 -&gt; 非空</strong>，一个“边沿”产生了。</li><li><strong>第一次触发</strong>：应用程序调用 <code>epoll_wait</code>，它会返回，报告这个 <code>socket fd</code> 可读。</li><li><strong>不完整的处理</strong>：你的应用程序只读取了 500 字节。内核缓冲区里还<strong>剩下 500 字节</strong>。</li><li><strong>再次调用 <code>epoll_wait</code></strong>：当你的事件循环下一次调用 <code>epoll_wait</code> 时，尽管缓冲区里还有数据，但因为<strong>没有新的“边沿”产生</strong>（状态没有从空变为非空），<code>epoll_wait</code> 将会<strong>阻塞</strong>，<strong>不会</strong>因为这个 <code>fd</code> 而返回！</li><li><strong>后果</strong>：剩下的 500 字节数据就被“遗忘”在缓冲区里了。你的程序将永远不会收到关于这 500 字节的通知，直到客户端<strong>发送下一批新数据</strong>，从而产生一个新的“边沿”。这就导致了数据处理的延迟甚至丢失。</li></ol><p>为了避免上述问题，使用 ET 模式时必须遵循一个黄金法则：</p><p><strong>当收到一个 ET 事件通知时，你必须持续地对该 <code>fd</code> 进行 I&#x2F;O 操作，直到该操作返回 <code>EAGAIN</code> 或 <code>EWOULDBLOCK</code> 错误为止。</strong></p><p>这意味着：</p><ul><li><strong>文件描述符必须设置为非阻塞（<code>O_NONBLOCK</code>）</strong>。这是绝对的前提，否则当缓冲区读完后，最后一次 <code>read()</code> 调用会永远阻塞你的程序。</li><li><strong>使用循环来处理 I&#x2F;O</strong>。</li></ul><p>正确的ET读操作代码伪代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// epoll_wait 返回了就绪的 fd</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 循环读取</span></span><br><span class="line">    bytes_read = read(fd, buffer, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bytes_read == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果错误是 EAGAIN 或 EWOULDBLOCK，说明数据已经读完了</span></span><br><span class="line">        <span class="keyword">if</span> (errno == EAGAIN || errno == EWOULDBLOCK) &#123;</span><br><span class="line">            <span class="comment">// 这不是一个真正的错误，只是一个信号：ET事件处理完毕</span></span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 其他错误，表示连接出错了</span></span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            close(fd);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bytes_read == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 对端关闭了连接</span></span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 成功读取了 bytes_read 字节的数据，处理它</span></span><br><span class="line">        process_data(buffer, bytes_read);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写操作同理，需要在一个循环里 <code>write()</code>，直到数据全部写完或者 <code>write()</code> 返回 <code>EAGAIN</code>。</p><ul><li><p><strong>优点</strong>：</p><ul><li><strong>性能极高</strong>：它极大地减少了 <code>epoll_wait</code> 被唤醒的次数，从而降低了系统调用的开销。一个事件只通知一次，非常高效，特别是在有大量连接但只有少数活跃的场景下。Nginx、Redis 等高性能组件都重度使用 ET 模式。</li><li><strong>避免“惊群”</strong>：在多线程环境下，一个事件不会被多个线程同时处理，因为只有一个线程会收到该事件的通知。</li></ul></li><li><p><strong>缺点</strong>：</p><ul><li><strong>编程复杂度高</strong>：逻辑比 LT 复杂得多，非常容易出错。如果忘记了循环处理 I&#x2F;O 直到 <code>EAGAIN</code>，就会导致数据饥饿（starvation）或连接假死。</li><li><strong>对程序员要求高</strong>：需要对非阻塞 I&#x2F;O 和事件循环有深刻的理解。</li></ul></li></ul><h4 id="C、-总结与对比"><a href="#C、-总结与对比" class="headerlink" title="C、 总结与对比"></a>C、 总结与对比</h4><table><thead><tr><th align="left">特性</th><th align="left">水平触发 (Level Triggered, LT)</th><th align="left">边沿触发 (Edge Triggered, ET)</th></tr></thead><tbody><tr><td align="left"><strong>触发条件</strong></td><td align="left">只要满足条件（缓冲区有数据&#x2F;有空间），就<strong>持续触发</strong></td><td align="left">仅在状态<strong>发生改变</strong>（空-&gt;非空，满-&gt;非满）时，<strong>触发一次</strong></td></tr><tr><td align="left"><strong>工作模式</strong></td><td align="left">状态驱动 (State-driven)</td><td align="left">变化驱动 (Transition-driven)</td></tr><tr><td align="left"><strong>处理要求</strong></td><td align="left">可以不一次性处理完所有数据，下次还会收到通知</td><td align="left"><strong>必须</strong>一次性处理完所有数据，直到返回 <code>EAGAIN</code>&#x2F;<code>EWOULDBLOCK</code></td></tr><tr><td align="left"><strong>依赖</strong></td><td align="left">无特殊依赖</td><td align="left"><strong>必须</strong>与非阻塞 I&#x2F;O (<code>O_NONBLOCK</code>) 配合使用</td></tr><tr><td align="left"><strong>编程复杂度</strong></td><td align="left"><strong>低</strong>，逻辑简单，容错性好</td><td align="left"><strong>高</strong>，逻辑复杂，易出错（如数据饥饿）</td></tr><tr><td align="left"><strong>性能</strong></td><td align="left">较好，但可能有不必要的唤醒</td><td align="left"><strong>极高</strong>，系统调用次数最少</td></tr><tr><td align="left"><strong>适用场景</strong></td><td align="left">绝大多数常规场景，追求稳健和开发效率</td><td align="left">追求极致性能的场景，如高性能服务器 (Nginx)、中间件 (Redis)</td></tr><tr><td align="left"><strong>比喻</strong></td><td align="left">水位传感器（持续报警）</td><td align="left">门铃（只响一次）</td></tr></tbody></table><ul><li><strong>如果你不确定用哪个，或者你是初学者，请使用默认的 LT 模式。</strong> 它的稳健性可以帮你避免很多难以调试的 bug。</li><li><strong>只有当你明确知道你的应用瓶颈在于 <code>epoll</code> 的唤醒次数，并且你对非阻塞 I&#x2F;O 的编程模型有十足的把握时，才考虑使用 ET 模式。</strong> ET 是为追求极致性能的专家准备的“利器”，用不好很容易伤到自己。</li></ul><hr><h3 id="6-优缺点与应用场景"><a href="#6-优缺点与应用场景" class="headerlink" title="6. 优缺点与应用场景"></a>6. 优缺点与应用场景</h3><h4 id="I-O-多路复用的优点"><a href="#I-O-多路复用的优点" class="headerlink" title="I&#x2F;O 多路复用的优点"></a>I&#x2F;O 多路复用的优点</h4><ul><li><strong>高并发，低资源消耗</strong>：可以用极少的线程（甚至单线程）处理成千上万的并发连接，极大地节省了内存和 CPU 上下文切换的开销。</li><li><strong>统一事件源</strong>：可以将网络 I&#x2F;O、文件 I&#x2F;O、信号等多种事件源放在一起统一处理。</li></ul><h4 id="I-O-多路复用的缺点"><a href="#I-O-多路复用的缺点" class="headerlink" title="I&#x2F;O 多路复用的缺点"></a>I&#x2F;O 多路复用的缺点</h4><ul><li><strong>编程复杂度高</strong>：相比简单的多线程阻塞模型，使用 <code>select/poll/epoll</code> 需要自己管理连接状态，编写状态机，处理起来更复杂，尤其是 <code>epoll</code> 的 ET 模式。</li><li><strong>不适用于 CPU 密集型任务</strong>：如果每个连接的业务逻辑需要大量的 CPU 计算，那么单线程模型会导致所有其他连接被阻塞。在这种情况下，”I&#x2F;O线程 + 工作线程池” 的模式会更合适。</li></ul><h4 id="经典应用"><a href="#经典应用" class="headerlink" title="经典应用"></a>经典应用</h4><p>I&#x2F;O 多路复用是所有高性能网络框架和服务器的基石：</p><ul><li><strong>Nginx</strong>：经典的高性能 Web 服务器，其事件驱动模型就是基于 <code>epoll</code>。</li><li><strong>Redis</strong>：著名的内存数据库，其单线程却能实现极高 QPS 的原因就在于它采用了 <code>epoll</code> 进行 I&#x2F;O 多路复用。</li><li><strong>Node.js</strong>：其异步、非阻塞的特性底层就是由 libuv 库实现的，而 libuv 在 Linux 上正是封装了 <code>epoll</code>。</li><li><strong>Netty (Java)</strong>：Java NIO 的高性能网络框架，其 Selector 机制也是对 <code>select/poll/epoll</code> 的封装。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>零拷贝</title>
      <link href="/2025/10/20/%E9%9B%B6%E6%8B%B7%E8%B4%9D/"/>
      <url>/2025/10/20/%E9%9B%B6%E6%8B%B7%E8%B4%9D/</url>
      
        <content type="html"><![CDATA[<h3 id="摘要：什么是零拷贝？"><a href="#摘要：什么是零拷贝？" class="headerlink" title="摘要：什么是零拷贝？"></a><strong>摘要：什么是零拷贝？</strong></h3><p><strong>零拷贝（Zero-Copy）</strong> 并不是指完全没有数据拷贝，而是指<strong>尽可能地减少或避免在应用程序的用户空间（User Space）和操作系统的内核空间（Kernel Space）之间进行不必要的CPU数据拷贝</strong>。其核心目标是让数据在从一个I&#x2F;O设备（如硬盘）到另一个I&#x2F;O设备（如网卡）的传输过程中，最大限度地利用硬件（如DMA）来搬运数据，从而解放CPU，减少上下文切换，显著提升数据传输的性能和效率。</p><hr><h3 id="一、-理解背景：传统I-O的痛点"><a href="#一、-理解背景：传统I-O的痛点" class="headerlink" title="一、 理解背景：传统I&#x2F;O的痛点"></a><strong>一、 理解背景：传统I&#x2F;O的痛点</strong></h3><p>要理解零拷贝的价值，我们必须先了解传统的数据传输方式有多么“昂贵”。</p><p>假设我们要实现一个简单的文件服务器，其功能是：从磁盘读取一个文件，然后通过网络发送给客户端。</p><p><strong>传统I&#x2F;O的操作流程：</strong></p><p>我们用代码来看，通常是这样的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">read(file_fd, buffer, len);</span><br><span class="line">write(socket_fd, buffer, len);</span><br></pre></td></tr></table></figure><p>这个看似简单的两行代码，在操作系统层面会触发一系列复杂的步骤：</p><ol><li><p><strong>第一次拷贝（DMA Copy）：</strong></p><ul><li>应用程序调用 <code>read()</code> 系统调用，发起读文件请求。</li><li>CPU 发出指令，<strong>上下文从用户态切换到内核态</strong>。</li><li>DMA（Direct Memory Access）控制器介入，将磁盘上的文件数据直接拷贝到内核空间的一个缓冲区，我们称之为<strong>内核缓冲区（Page Cache）</strong>。这个过程由DMA完成，不占用CPU。</li></ul></li><li><p><strong>第二次拷贝（CPU Copy）：</strong></p><ul><li><code>read()</code> 系统调用需要返回数据给应用程序。</li><li>CPU 将数据从<strong>内核缓冲区</strong>拷贝到应用程序指定的<strong>用户缓冲区</strong>（<code>buffer</code>）。</li><li><code>read()</code> 调用返回，<strong>上下文从内核态切换回用户态</strong>。此时，数据已经到了我们的应用程序内存中。</li></ul></li><li><p><strong>第三次拷贝（CPU Copy）：</strong></p><ul><li>应用程序调用 <code>write()</code> 系统调用，发起网络发送请求。</li><li><strong>上下文再次从用户态切换到内核态</strong>。</li><li>CPU 将数据从<strong>用户缓冲区</strong>（<code>buffer</code>）拷贝到与网络套接字（Socket）关联的另一个内核缓冲区，即 <strong>Socket 缓冲区</strong>。</li></ul></li><li><p><strong>第四次拷贝（DMA Copy）：</strong></p><ul><li>数据已经准备好发送。</li><li>DMA 控制器将数据从 <strong>Socket 缓冲区</strong>拷贝到网卡的缓冲区（NIC Buffer）。</li><li>网卡将数据打包成网络帧，通过物理链路发送出去。</li><li><code>write()</code> 调用返回，<strong>上下文再次从内核态切换回用户态</strong>。</li></ul></li></ol><p><img src="/img_1/21.png" alt="传统I&#x2F;O"></p><p><strong>传统I&#x2F;O的成本总结：</strong></p><ul><li><strong>4 次数据拷贝</strong>：2次DMA拷贝 + 2次CPU拷贝。</li><li><strong>4 次上下文切换</strong>：2次 <code>read()</code> 切换 + 2次 <code>write()</code> 切换。</li></ul><p><strong>问题在哪里？</strong></p><ul><li><strong>CPU拷贝是多余的</strong>：在整个流程中，应用程序（用户空间）只是一个“中转站”。数据从内核缓冲区拷贝到用户缓冲区，又原封不动地拷贝回内核的Socket缓冲区。这个来回拷贝对于“数据传输”这个场景来说，是完全没有必要的，白白浪费了CPU周期和内存带宽。</li><li><strong>上下文切换是昂贵的</strong>：每次用户态和内核态之间的切换，都需要保存和恢复大量的寄存器状态、程序计数器等信息，开销很大。</li></ul><p>零拷贝技术就是为了解决这两个核心问题而生的。</p><hr><h3 id="二、-零拷贝的实现方式"><a href="#二、-零拷贝的实现方式" class="headerlink" title="二、 零拷贝的实现方式"></a><strong>二、 零拷贝的实现方式</strong></h3><p>零拷贝有多种实现技术，下面我们由浅入深地介绍几种主流的方式。</p><h4 id="1-mmap-write-方式"><a href="#1-mmap-write-方式" class="headerlink" title="1. mmap + write 方式"></a><strong>1. mmap + write 方式</strong></h4><p><code>mmap</code>（Memory Map）是一种内存映射技术，它可以将内核缓冲区的一部分直接映射到应用程序的地址空间。这样，应用程序就可以像访问普通内存一样访问这块内核缓冲区，而无需将数据从内核拷贝到用户空间。</p><p><strong>操作流程：</strong></p><ol><li>应用程序调用 <code>mmap()</code> 系统调用。<ul><li><strong>上下文切换到内核态</strong>。</li><li>DMA 控制器将磁盘数据拷贝到<strong>内核缓冲区（Page Cache）</strong>。</li><li><code>mmap()</code> 系统调用将这块内核缓冲区<strong>映射</strong>到用户空间的虚拟地址，此时内核空间和用户空间共享了这块内存。</li><li><code>mmap()</code> 返回，<strong>上下文切换回用户态</strong>。</li></ul></li><li>应用程序调用 <code>write()</code> 系统调用。<ul><li><strong>上下文再次切换到内核态</strong>。</li><li>CPU 将数据从<strong>内核缓冲区</strong>（现在也被用户空间共享）直接拷贝到 <strong>Socket 缓冲区</strong>。</li><li>DMA 控制器将数据从 Socket 缓冲区拷贝到网卡。</li><li><code>write()</code> 返回，<strong>上下文切换回用户态</strong>。</li></ul></li></ol><p><img src="/img_1/22.png" alt="mmap + write 方式"></p><p><strong>mmap + write 的改进：</strong></p><ul><li><strong>数据拷贝减少为 3 次</strong>：1次DMA拷贝 + 1次CPU拷贝 + 1次DMA拷贝。<ul><li>我们成功地<strong>消除了一次从内核到用户的CPU拷贝</strong>。</li></ul></li><li><strong>上下文切换仍为 4 次</strong>（<code>mmap</code>两次，<code>write</code>两次）。</li></ul><p><strong>优点</strong>：减少了一次CPU拷贝。<br><strong>缺点</strong>：<code>mmap</code> 映射的内存如果被其他进程意外修改，可能会导致数据污染。此外，对于小文件，<code>mmap</code> 的开销（建立映射、管理页表）可能比传统的 <code>read</code> 更大。</p><h4 id="2-sendfile-方式-Linux"><a href="#2-sendfile-方式-Linux" class="headerlink" title="2. sendfile 方式 (Linux)"></a><strong>2. sendfile 方式 (Linux)</strong></h4><p><code>sendfile</code> 是 Linux 2.1 内核引入的一个专门用于在两个文件描述符之间传输数据的系统调用，它极大地简化了数据传输过程，是零拷贝的经典实现。</p><p><code>ssize_t sendfile(int out_fd, int in_fd, off_t *offset, size_t count);</code></p><ul><li><code>out_fd</code>: 目标文件描述符（如 socket）。</li><li><code>in_fd</code>: 源文件描述符（如文件）。</li></ul><p><strong>操作流程（基础版）：</strong></p><ol><li>应用程序调用 <code>sendfile()</code> 系统调用。<ul><li><strong>上下文切换到内核态</strong>。</li><li>DMA 控制器将磁盘数据拷贝到<strong>内核缓冲区（Page Cache）</strong>。</li><li>CPU 将数据从<strong>内核缓冲区</strong>直接拷贝到 <strong>Socket 缓冲区</strong>。</li><li>DMA 控制器将数据从 Socket 缓冲区拷贝到网卡。</li><li><code>sendfile()</code> 返回，<strong>上下文切换回用户态</strong>。</li></ul></li></ol><p><img src="/img_1/23.png" alt="sendfile 方式"></p><p><strong>sendfile 的改进：</strong></p><ul><li><strong>数据拷贝减少为 3 次</strong>：1次DMA拷贝 + 1次CPU拷贝 + 1次DMA拷贝。</li><li><strong>上下文切换减少为 2 次</strong>：一次系统调用就完成了所有操作。</li></ul><p>相比 <code>mmap</code>，<code>sendfile</code> 进一步减少了上下文切换次数，性能更好。</p><h4 id="3-sendfile-DMA-Scatter-Gather-真正的零拷贝"><a href="#3-sendfile-DMA-Scatter-Gather-真正的零拷贝" class="headerlink" title="3. sendfile + DMA Scatter&#x2F;Gather (真正的零拷贝)"></a><strong>3. sendfile + DMA Scatter&#x2F;Gather (真正的零拷贝)</strong></h4><p>从 Linux 2.4 内核开始，<code>sendfile</code> 得到了进一步增强，如果网卡硬件支持 <strong>Scatter-Gather I&#x2F;O</strong>（分散-聚集 I&#x2F;O）功能，那么连内核内部的CPU拷贝都可以省掉。</p><p><strong>Scatter-Gather I&#x2F;O 是什么？</strong><br>它是一种 DMA 技术，允许 DMA 控制器从多个不连续的内存缓冲区中读取数据（Scatter），然后将它们组装成一个连续的数据流写入到目标设备（Gather）。</p><p><strong>操作流程（增强版）：</strong></p><ol><li>应用程序调用 <code>sendfile()</code> 系统调用。<ul><li><strong>上下文切换到内核态</strong>。</li><li>DMA 控制器将磁盘数据拷贝到<strong>内核缓冲区（Page Cache）</strong>。</li></ul></li><li><strong>关键步骤</strong>：CPU 不再拷贝数据到 Socket 缓冲区。取而代之的是，CPU 将一个<strong>描述符（Descriptor）</strong> 追加到 Socket 缓冲区。这个描述符包含了两个信息：<ul><li>数据在内核缓冲区中的<strong>内存地址</strong>。</li><li>数据的<strong>长度</strong>。</li></ul></li><li>DMA 控制器根据 Socket 缓冲区中的描述符，直接从<strong>内核缓冲区</strong>将数据拷贝到网卡。这个过程被称为 <strong>DMA Gather Copy</strong>。</li><li><code>sendfile()</code> 返回，<strong>上下文切换回用户态</strong>。</li></ol><p><img src="/img_1/24.png" alt="sendfile + DMA Scatter&#x2F;Gather"></p><p><strong>终极改进：</strong></p><ul><li><strong>数据拷贝减少为 2 次</strong>：全部是 DMA 拷贝，<strong>CPU 拷贝次数为 0</strong>！这才是“零拷贝”这个名字最贴切的诠释。</li><li><strong>上下文切换为 2 次</strong>。</li></ul><p>这是目前在Linux上实现文件到网络传输最高效的方式。</p><hr><h3 id="三、-零拷贝的应用场景"><a href="#三、-零拷贝的应用场景" class="headerlink" title="三、 零拷贝的应用场景"></a><strong>三、 零拷贝的应用场景</strong></h3><p>零拷贝技术被广泛应用于需要高性能数据传输的场景，特别是那些数据内容本身不需要被应用程序处理的场景。</p><ul><li><strong>Web 服务器</strong>：像 Nginx、Apache 等，在处理静态文件请求（如图片、HTML、CSS文件）时，会大量使用 <code>sendfile</code> 来提高性能。</li><li><strong>消息中间件</strong>：像 Kafka、RocketMQ 等，它们在从磁盘读取消息数据并发送给消费者时，也严重依赖零拷贝技术来达到极高的吞吐量。Kafka 的高性能传说很大程度上就归功于对 <code>sendfile</code> 的极致运用。</li><li><strong>文件服务器</strong>：如 FTP、Samba 服务器。</li><li><strong>数据库</strong>：某些数据库在进行数据备份或网络同步时也会使用。</li></ul><hr><h3 id="四、-总结：零拷贝的优势与局限"><a href="#四、-总结：零拷贝的优势与局限" class="headerlink" title="四、 总结：零拷贝的优势与局限"></a><strong>四、 总结：零拷贝的优势与局限</strong></h3><p><strong>优势：</strong></p><ol><li><strong>减少CPU开销</strong>：避免了用户空间和内核空间之间多余的CPU数据拷贝。</li><li><strong>减少上下文切换</strong>：使用 <code>sendfile</code> 等系统调用可以将多次I&#x2F;O操作合并为一次，减少了内核态和用户态之间的切换次数。</li><li><strong>提升性能</strong>：CPU被解放出来去处理其他任务，系统的整体吞吐量得到显著提升。</li><li><strong>避免内存带宽瓶颈</strong>：减少了对内存总线的占用。</li></ol><p><strong>局限性：</strong></p><ol><li><strong>数据无法修改</strong>：因为数据没有被拷贝到用户空间，所以应用程序在数据传输过程中无法对其进行修改（如加密、压缩）。如果需要修改数据，就必须走传统I&#x2F;O的路径。</li><li><strong>依赖操作系统和硬件支持</strong>：最高效的零拷贝（如 <code>sendfile</code> + DMA Gather）需要操作系统内核和网卡硬件的同时支持。</li><li><strong>适用场景有限</strong>：主要适用于数据“原封不动”的转发场景。</li></ol><hr><h3 id="零拷贝方案对比"><a href="#零拷贝方案对比" class="headerlink" title="零拷贝方案对比"></a><strong>零拷贝方案对比</strong></h3><table><thead><tr><th align="left">技术方案</th><th align="center">CPU 拷贝次数</th><th align="center">DMA 拷贝次数</th><th align="center">上下文切换次数</th><th align="left">核心思想</th></tr></thead><tbody><tr><td align="left"><strong>传统 I&#x2F;O</strong></td><td align="center">2</td><td align="center">2</td><td align="center">4</td><td align="left">简单直接，但效率低下</td></tr><tr><td align="left"><strong>mmap + write</strong></td><td align="center">1</td><td align="center">2</td><td align="center">4</td><td align="left">共享内核与用户空间内存，减少一次CPU拷贝</td></tr><tr><td align="left"><strong>sendfile</strong></td><td align="center">1</td><td align="center">2</td><td align="center">2</td><td align="left">合并系统调用，减少上下文切换</td></tr><tr><td align="left"><strong>sendfile + SG-DMA</strong></td><td align="center"><strong>0</strong></td><td align="center">2</td><td align="center">2</td><td align="left">利用硬件特性，彻底消除CPU拷贝</td></tr></tbody></table><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>[1] <a href="https://xiaolincoding.com/os/8_network_system/zero_copy.html">什么是零拷贝？</a></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式与模式匹配</title>
      <link href="/2025/10/17/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8E%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/"/>
      <url>/2025/10/17/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8E%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="第一部分：正则表达式（Regular-Expression）详解"><a href="#第一部分：正则表达式（Regular-Expression）详解" class="headerlink" title="第一部分：正则表达式（Regular Expression）详解"></a>第一部分：正则表达式（Regular Expression）详解</h2><h3 id="1-什么是正则表达式？"><a href="#1-什么是正则表达式？" class="headerlink" title="1. 什么是正则表达式？"></a>1. 什么是正则表达式？</h3><p>正则表达式是一种<strong>描述字符模式的对象</strong>。可以把它想象成一种极其强大的“查找和替换”工具，它不是用固定的字符（如 “abc”）去查找，而是用一种描述性的语言（如 “查找三个数字”）去匹配一系列符合某个句法规则的字符串。</p><p>它的核心用途包括：</p><ul><li><strong>数据验证</strong>：检查输入的数据是否符合某种格式（如邮箱、手机号、身份证号）。</li><li><strong>文本搜索与定位</strong>：在大量文本中快速找到符合特定模式的内容。</li><li><strong>文本提取</strong>：从一段文本中抽取出需要的信息（如网页爬虫中提取标题和链接）。</li><li><strong>文本替换</strong>：将符合模式的文本替换成其他内容。</li></ul><h3 id="2-核心组成元素（元字符-Metacharacters）"><a href="#2-核心组成元素（元字符-Metacharacters）" class="headerlink" title="2. 核心组成元素（元字符 Metacharacters）"></a>2. 核心组成元素（元字符 Metacharacters）</h3><p>正则表达式的威力来自于它的特殊字符——元字符。普通字符（如 <code>a</code>, <code>b</code>, <code>1</code>, <code>2</code>）在正则中就是匹配它们自身，而元字符则有特殊的含义。</p><h4 id="2-1-基础字符与预定义字符集"><a href="#2-1-基础字符与预定义字符集" class="headerlink" title="2.1 基础字符与预定义字符集"></a>2.1 基础字符与预定义字符集</h4><table><thead><tr><th align="left">元字符</th><th align="left">描述</th><th align="left">示例</th></tr></thead><tbody><tr><td align="left"><code>.</code></td><td align="left">匹配除换行符 <code>\n</code> 之外的任意单个字符</td><td align="left"><code>a.c</code> 匹配 “abc”, “a_c”, “a2c”</td></tr><tr><td align="left"><code>\d</code></td><td align="left">匹配任意一个数字（等价于 <code>[0-9]</code>）</td><td align="left"><code>\d{3}</code> 匹配 “123”</td></tr><tr><td align="left"><code>\D</code></td><td align="left">匹配任意一个<strong>非</strong>数字字符</td><td align="left"><code>\D</code> 匹配 “a”, “!”, “ “</td></tr><tr><td align="left"><code>\w</code></td><td align="left">匹配任意一个字母、数字或下划线（等价于 <code>[a-zA-Z0-9_]</code>）</td><td align="left"><code>\w+</code> 匹配 “hello_123”</td></tr><tr><td align="left"><code>\W</code></td><td align="left">匹配任意一个<strong>非</strong>字母、数字或下划线</td><td align="left"><code>\W</code> 匹配 “ “, “!”, “?”</td></tr><tr><td align="left"><code>\s</code></td><td align="left">匹配任意一个空白字符（包括空格、制表符<code>\t</code>、换行符<code>\n</code>等）</td><td align="left"><code>hello\sworld</code> 匹配 “hello world”</td></tr><tr><td align="left"><code>\S</code></td><td align="left">匹配任意一个<strong>非</strong>空白字符</td><td align="left"><code>\S+</code> 匹配 “non-space”</td></tr></tbody></table><h4 id="2-2-量词（Quantifiers）"><a href="#2-2-量词（Quantifiers）" class="headerlink" title="2.2 量词（Quantifiers）"></a>2.2 量词（Quantifiers）</h4><p>量词用来指定一个模式需要重复出现的次数。</p><table><thead><tr><th align="left">元字符</th><th align="left">描述</th><th align="left">示例</th></tr></thead><tbody><tr><td align="left"><code>*</code></td><td align="left">匹配前面的元素 0 次或多次（任意次数）</td><td align="left"><code>go*gle</code> 匹配 “ggle”, “google”, “goooogle”</td></tr><tr><td align="left"><code>+</code></td><td align="left">匹配前面的元素 1 次或多次（至少一次）</td><td align="left"><code>go+gle</code> 匹配 “google”, “goooogle”, 但不匹配 “ggle”</td></tr><tr><td align="left"><code>?</code></td><td align="left">匹配前面的元素 0 次或 1 次（最多一次）</td><td align="left"><code>colou?r</code> 匹配 “color” 和 “colour”</td></tr><tr><td align="left"><code>{n}</code></td><td align="left">匹配前面的元素恰好 n 次</td><td align="left"><code>\d{5}</code> 匹配一个五位数的邮编 “10086”</td></tr><tr><td align="left"><code>{n,}</code></td><td align="left">匹配前面的元素至少 n 次</td><td align="left"><code>\d{5,}</code> 匹配五位或更长的数字</td></tr><tr><td align="left"><code>{n,m}</code></td><td align="left">匹配前面的元素 n 到 m 次</td><td align="left"><code>\d{5,8}</code> 匹配五到八位的数字</td></tr></tbody></table><p><strong>贪婪模式 vs. 懒惰模式</strong></p><p>默认情况下，量词是<strong>贪婪的（Greedy）</strong>，即尽可能多地匹配字符。在量词后面加上一个 <code>?</code> 可以使其变为<strong>懒惰的（Lazy）</strong>，即尽可能少地匹配字符。</p><ul><li><strong>示例</strong>：对于字符串 <code>&quot;&lt;h1&gt;Title&lt;/h1&gt;&quot;</code><ul><li>贪婪模式：<code>&lt;.*&gt;</code> 会匹配整个字符串 <code>&quot;&lt;h1&gt;Title&lt;/h1&gt;&quot;</code>。</li><li>懒惰模式：<code>&lt;.*?&gt;</code> 会先匹配到 <code>&quot;&lt;h1&gt;&quot;</code>，因为它找到了第一个 <code>&gt;</code> 就停止了，满足了“尽可能少”的原则。</li></ul></li></ul><h4 id="2-3-边界匹配（Anchors）"><a href="#2-3-边界匹配（Anchors）" class="headerlink" title="2.3 边界匹配（Anchors）"></a>2.3 边界匹配（Anchors）</h4><p>边界匹配符用于定位模式在字符串中的位置，它们不匹配任何字符，只匹配位置。</p><table><thead><tr><th align="left">元字符</th><th align="left">描述</th><th align="left">示例</th></tr></thead><tbody><tr><td align="left"><code>^</code></td><td align="left">匹配字符串的<strong>开始</strong>位置</td><td align="left"><code>^Hello</code> 匹配以 “Hello” 开头的字符串</td></tr><tr><td align="left"><code>$</code></td><td align="left">匹配字符串的<strong>结束</strong>位置</td><td align="left"><code>world$</code> 匹配以 “world” 结尾的字符串</td></tr><tr><td align="left"><code>\b</code></td><td align="left">匹配一个<strong>单词边界</strong>（单词的开始或结束位置）</td><td align="left"><code>\bcat\b</code> 匹配独立的单词 “cat”，但不匹配 “category” 中的 “cat”</td></tr><tr><td align="left"><code>\B</code></td><td align="left">匹配一个<strong>非</strong>单词边界</td><td align="left"><code>\Bcat\B</code> 匹配 “category” 中的 “cat”</td></tr></tbody></table><h4 id="2-4-分组与捕获（Grouping-and-Capturing）"><a href="#2-4-分组与捕获（Grouping-and-Capturing）" class="headerlink" title="2.4 分组与捕获（Grouping and Capturing）"></a>2.4 分组与捕获（Grouping and Capturing）</h4><table><thead><tr><th align="left">元字符</th><th align="left">描述</th><th align="left">示例</th></tr></thead><tbody><tr><td align="left"><code>(...)</code></td><td align="left">1. <strong>分组</strong>：将多个字符作为一个单元，可以对这个单元使用量词。<br>2. <strong>捕获</strong>：匹配的内容会被捕获，以便后续引用或提取。</td><td align="left"><code>(ab)+</code> 匹配 “ab”, “abab”, “ababab”<br><code>(\d{4})-(\d{2})-(\d{2})</code> 捕获年、月、日</td></tr><tr><td align="left"><code>(?:...)</code></td><td align="left"><strong>非捕获分组</strong>：只分组，不捕获匹配的内容。效率略高。</td><td align="left"><code>(?:https?://)</code> 匹配 “http:&#x2F;&#x2F;“ 或 “https:&#x2F;&#x2F;“ 但不捕获它</td></tr><tr><td align="left"><code>|</code></td><td align="left"><strong>或（OR）</strong>：匹配 &#96;</td><td align="left">&#96; 左边或右边的表达式。</td></tr><tr><td align="left"><code>[...]</code></td><td align="left"><strong>字符集</strong>：匹配方括号中的任意一个字符。</td><td align="left"><code>[aeiou]</code> 匹配任意一个元音字母</td></tr><tr><td align="left"><code>[^...]</code></td><td align="left"><strong>排除型字符集</strong>：匹配<strong>不</strong>在方括号中的任意一个字符。</td><td align="left"><code>[^0-9]</code> 匹配任意非数字字符</td></tr><tr><td align="left"><code>[a-z]</code></td><td align="left"><strong>范围</strong>：匹配指定范围内的任意一个字符。</td><td align="left"><code>[a-zA-Z0-9]</code> 匹配任意字母或数字</td></tr></tbody></table><h4 id="2-5-高级概念：断言（Lookaround）"><a href="#2-5-高级概念：断言（Lookaround）" class="headerlink" title="2.5 高级概念：断言（Lookaround）"></a>2.5 高级概念：断言（Lookaround）</h4><p>断言（也叫环视或零宽断言）是一种特殊的边界匹配，它只进行位置匹配，不消耗任何字符。</p><table><thead><tr><th align="left">元字符</th><th align="left">类型</th><th align="left">描述</th><th align="left">示例</th></tr></thead><tbody><tr><td align="left"><code>(?=...)</code></td><td align="left"><strong>正向先行断言</strong></td><td align="left">匹配…之前的位置，要求该位置后面能匹配…</td><td align="left">&#96;windows(?&#x3D;95</td></tr><tr><td align="left"><code>(?!...)</code></td><td align="left"><strong>负向先行断言</strong></td><td align="left">匹配…之前的位置，要求该位置后面<strong>不能</strong>匹配…</td><td align="left"><code>\d{3}(?!\d)</code> 匹配一个三位数，但前提是它后面没有跟着另一个数字</td></tr><tr><td align="left"><code>(?&lt;=...)</code></td><td align="left"><strong>正向后行断言</strong></td><td align="left">匹配…之后的位置，要求该位置前面能匹配…</td><td align="left"><code>(?&lt;=\$)\d+</code> 匹配一个数字，但仅当其前面是”$”符号时（如 “$100” 中的 “100”）</td></tr><tr><td align="left"><code>(?&lt;!...)</code></td><td align="left"><strong>负向后行断言</strong></td><td align="left">匹配…之后的位置，要求该位置前面<strong>不能</strong>匹配…</td><td align="left"><code>(?&lt;!-)\d+</code> 匹配一个数字，但仅当其前面不是连字符”-“时</td></tr></tbody></table><h4 id="2-6-转义字符"><a href="#2-6-转义字符" class="headerlink" title="2.6 转义字符"></a>2.6 转义字符</h4><p>如果你想匹配元字符本身（如 <code>.</code>、<code>*</code>、<code>(</code>），你需要在它前面加上反斜杠 <code>\</code> 进行转义。</p><ul><li><code>\.</code> 匹配一个真正的点号 <code>.</code>。</li><li><code>\*</code> 匹配一个真正的星号 <code>*</code>。</li><li><code>\\</code> 匹配一个真正的反斜杠 <code>\</code>。</li></ul><hr><h2 id="第二部分：Python-的-re-库用法"><a href="#第二部分：Python-的-re-库用法" class="headerlink" title="第二部分：Python 的 re 库用法"></a>第二部分：Python 的 <code>re</code> 库用法</h2><p>Python 通过内置的 <code>re</code> 模块来支持正则表达式。</p><h3 id="1-核心函数与方法"><a href="#1-核心函数与方法" class="headerlink" title="1. 核心函数与方法"></a>1. 核心函数与方法</h3><p>使用 <code>re</code> 库通常有两种方式：</p><ol><li><strong>函数式</strong>：直接调用 <code>re</code> 模块的函数，如 <code>re.search(pattern, string)</code>。适合一次性的操作。</li><li><strong>对象式</strong>：先用 <code>re.compile(pattern)</code> 将正则表达式编译成一个模式对象，然后调用该对象的方法，如 <code>pattern.search(string)</code>。<strong>推荐在需要多次使用同一个正则表达式时使用</strong>，因为编译可以节省时间，提高效率。</li></ol><h4 id="1-1-re-match-pattern-string-flags-0"><a href="#1-1-re-match-pattern-string-flags-0" class="headerlink" title="1.1 re.match(pattern, string, flags=0)"></a>1.1 <code>re.match(pattern, string, flags=0)</code></h4><ul><li><strong>功能</strong>：从字符串的<strong>起始位置</strong>开始匹配。如果起始位置不匹配，则返回 <code>None</code>。</li><li><strong>返回值</strong>：一个匹配对象（Match Object），或者 <code>None</code>。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">text = <span class="string">&quot;hello world&quot;</span></span><br><span class="line"><span class="comment"># 从开头匹配 &#x27;hello&#x27;</span></span><br><span class="line">match_obj = re.<span class="keyword">match</span>(<span class="string">r&quot;hello&quot;</span>, text)</span><br><span class="line"><span class="built_in">print</span>(match_obj)  <span class="comment"># &lt;re.Match object; span=(0, 5), match=&#x27;hello&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 尝试匹配 &#x27;world&#x27;，因为不在开头，所以失败</span></span><br><span class="line">match_obj = re.<span class="keyword">match</span>(<span class="string">r&quot;world&quot;</span>, text)</span><br><span class="line"><span class="built_in">print</span>(match_obj)  <span class="comment"># None</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：<code>r&quot;...&quot;</code> 是 Python 的原始字符串（raw string），它可以防止反斜杠被解释为转义字符，在写正则表达式时几乎是必需的。</p></blockquote><h4 id="1-2-re-search-pattern-string-flags-0"><a href="#1-2-re-search-pattern-string-flags-0" class="headerlink" title="1.2 re.search(pattern, string, flags=0)"></a>1.2 <code>re.search(pattern, string, flags=0)</code></h4><ul><li><strong>功能</strong>：扫描整个字符串，找到<strong>第一个</strong>匹配的子串。</li><li><strong>返回值</strong>：一个匹配对象（Match Object），或者 <code>None</code>。这是最常用的查找函数。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">text = <span class="string">&quot;hello world&quot;</span></span><br><span class="line"><span class="comment"># 可以在字符串的任何位置找到 &#x27;world&#x27;</span></span><br><span class="line">match_obj = re.search(<span class="string">r&quot;world&quot;</span>, text)</span><br><span class="line"><span class="built_in">print</span>(match_obj)  <span class="comment"># &lt;re.Match object; span=(6, 11), match=&#x27;world&#x27;&gt;</span></span><br></pre></td></tr></table></figure><h4 id="1-3-re-findall-pattern-string-flags-0"><a href="#1-3-re-findall-pattern-string-flags-0" class="headerlink" title="1.3 re.findall(pattern, string, flags=0)"></a>1.3 <code>re.findall(pattern, string, flags=0)</code></h4><ul><li><strong>功能</strong>：查找字符串中所有与模式匹配的<strong>非重叠</strong>子串。</li><li><strong>返回值</strong>：一个列表。<ul><li>如果模式中<strong>没有</strong>捕获组，返回所有匹配的字符串组成的列表。</li><li>如果模式中<strong>有</strong>捕获组，返回一个由元组组成的列表，每个元组包含各捕获组匹配的内容。</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">text = <span class="string">&quot;I have 2 apples and 3 bananas.&quot;</span></span><br><span class="line"><span class="comment"># 无捕获组</span></span><br><span class="line">numbers = re.findall(<span class="string">r&quot;\d+&quot;</span>, text)</span><br><span class="line"><span class="built_in">print</span>(numbers)  <span class="comment"># [&#x27;2&#x27;, &#x27;3&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 有捕获组</span></span><br><span class="line">items = re.findall(<span class="string">r&quot;(\d+) (\w+)&quot;</span>, text)</span><br><span class="line"><span class="built_in">print</span>(items)  <span class="comment"># [(&#x27;2&#x27;, &#x27;apples&#x27;), (&#x27;3&#x27;, &#x27;bananas&#x27;)]</span></span><br></pre></td></tr></table></figure><h4 id="1-4-re-finditer-pattern-string-flags-0"><a href="#1-4-re-finditer-pattern-string-flags-0" class="headerlink" title="1.4 re.finditer(pattern, string, flags=0)"></a>1.4 <code>re.finditer(pattern, string, flags=0)</code></h4><ul><li><strong>功能</strong>：与 <code>findall</code> 类似，但返回一个<strong>迭代器（iterator）</strong>，迭代器中的每个元素都是一个匹配对象。</li><li><strong>优点</strong>：当匹配结果非常多时，使用迭代器比一次性生成一个大列表更节省内存。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">text = <span class="string">&quot;Event at 2023-10-26, and another at 2024-01-01.&quot;</span></span><br><span class="line">iterator = re.finditer(<span class="string">r&quot;(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)&quot;</span>, text)</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">match</span> <span class="keyword">in</span> iterator:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Full match: <span class="subst">&#123;<span class="keyword">match</span>.group(<span class="number">0</span>)&#125;</span>, Year: <span class="subst">&#123;<span class="keyword">match</span>.group(<span class="number">1</span>)&#125;</span>, Month: <span class="subst">&#123;<span class="keyword">match</span>.group(<span class="number">2</span>)&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="1-5-re-sub-pattern-repl-string-count-0-flags-0"><a href="#1-5-re-sub-pattern-repl-string-count-0-flags-0" class="headerlink" title="1.5 re.sub(pattern, repl, string, count=0, flags=0)"></a>1.5 <code>re.sub(pattern, repl, string, count=0, flags=0)</code></h4><ul><li><strong>功能</strong>：替换（Substitute）。查找所有匹配的子串，并用 <code>repl</code> 替换它们。</li><li><code>repl</code> 可以是字符串，也可以是一个函数。</li><li><code>count</code> 指定最大替换次数。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">text = <span class="string">&quot;My phone is 123-456-7890.&quot;</span></span><br><span class="line"><span class="comment"># 简单的字符串替换</span></span><br><span class="line">hidden_phone = re.sub(<span class="string">r&quot;\d&quot;</span>, <span class="string">&quot;*&quot;</span>, text)</span><br><span class="line"><span class="built_in">print</span>(hidden_phone)  <span class="comment"># My phone is ***-***-****.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用捕获组进行高级替换 (\g&lt;name&gt; or \1)</span></span><br><span class="line">formatted_phone = re.sub(<span class="string">r&quot;(\d&#123;3&#125;)-(\d&#123;3&#125;)-(\d&#123;4&#125;)&quot;</span>, <span class="string">r&quot;(\1) \2-\3&quot;</span>, text)</span><br><span class="line"><span class="built_in">print</span>(formatted_phone) <span class="comment"># My phone is (123) 456-7890.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用函数进行替换</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_one</span>(<span class="params"><span class="keyword">match</span></span>):</span><br><span class="line">    number = <span class="built_in">int</span>(<span class="keyword">match</span>.group(<span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">str</span>(number + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">text = <span class="string">&quot;The score is 99.&quot;</span></span><br><span class="line">new_text = re.sub(<span class="string">r&quot;\d+&quot;</span>, add_one, text)</span><br><span class="line"><span class="built_in">print</span>(new_text)  <span class="comment"># The score is 100.</span></span><br></pre></td></tr></table></figure><h4 id="1-6-re-split-pattern-string-maxsplit-0-flags-0"><a href="#1-6-re-split-pattern-string-maxsplit-0-flags-0" class="headerlink" title="1.6 re.split(pattern, string, maxsplit=0, flags=0)"></a>1.6 <code>re.split(pattern, string, maxsplit=0, flags=0)</code></h4><ul><li><strong>功能</strong>：使用正则表达式作为分隔符来分割字符串。比 <code>str.split()</code> 更强大。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">text = <span class="string">&quot;apple, pear; orange|banana&quot;</span></span><br><span class="line"><span class="comment"># 可以用多种分隔符分割</span></span><br><span class="line">parts = re.split(<span class="string">r&quot;[,;|]\s*&quot;</span>, text)</span><br><span class="line"><span class="built_in">print</span>(parts)  <span class="comment"># [&#x27;apple&#x27;, &#x27;pear&#x27;, &#x27;orange&#x27;, &#x27;banana&#x27;]</span></span><br></pre></td></tr></table></figure><h4 id="1-7-re-compile-pattern-flags-0"><a href="#1-7-re-compile-pattern-flags-0" class="headerlink" title="1.7 re.compile(pattern, flags=0)"></a>1.7 <code>re.compile(pattern, flags=0)</code></h4><ul><li><strong>功能</strong>：将正则表达式字符串编译成一个模式对象，以便复用。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编译模式</span></span><br><span class="line">email_pattern = re.<span class="built_in">compile</span>(<span class="string">r&quot;[\w.-]+@[\w.-]+\.\w+&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用模式对象</span></span><br><span class="line">text1 = <span class="string">&quot;Contact me at test@example.com&quot;</span></span><br><span class="line">text2 = <span class="string">&quot;Invalid address: user@.com&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(email_pattern.search(text1)) <span class="comment"># &lt;re.Match object ...&gt;</span></span><br><span class="line"><span class="built_in">print</span>(email_pattern.search(text2)) <span class="comment"># None</span></span><br></pre></td></tr></table></figure><h4 id="1-8-re-fullmatch-pattern-string-flags-0"><a href="#1-8-re-fullmatch-pattern-string-flags-0" class="headerlink" title="1.8 re.fullmatch(pattern, string, flags=0)"></a>1.8 <code>re.fullmatch(pattern, string, flags=0)</code></h4><ul><li><strong>功能</strong>：<code>re.fullmatch</code> 会尝试将正则表达式模式应用到<strong>整个字符串</strong>上。只有当<strong>整个字符串</strong>从头到尾都能够与模式完全匹配时，它才会返回一个匹配对象（Match Object），否则返回 <code>None</code>。</li></ul><h5 id="1-8-1-与-re-match-和-re-search-的关键区别"><a href="#1-8-1-与-re-match-和-re-search-的关键区别" class="headerlink" title="1.8.1 与 re.match 和 re.search 的关键区别"></a>1.8.1 与 <code>re.match</code> 和 <code>re.search</code> 的关键区别</h5><table><thead><tr><th align="left">函数</th><th align="left">匹配行为</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>re.match()</code></td><td align="left"><strong>从字符串开头匹配</strong></td><td align="left">只要字符串的开头部分能匹配模式即可，不关心字符串的剩余部分。</td></tr><tr><td align="left"><code>re.search()</code></td><td align="left"><strong>在字符串中任意位置匹配</strong>（找到第一个）</td><td align="left">扫描整个字符串，只要找到任何一个子串能匹配模式就立即返回。</td></tr><tr><td align="left"><code>re.fullmatch()</code></td><td align="left"><strong>必须匹配整个字符串</strong></td><td align="left">整个字符串，从第一个字符到最后一个字符，都必须能匹配模式。</td></tr></tbody></table><p><strong>一个直观的类比：</strong></p><ul><li><code>re.match(pattern, string)</code> 相当于 <code>re.search(f&#39;^{pattern}&#39;, string)</code></li><li><code>re.fullmatch(pattern, string)</code> 相当于 <code>re.search(f&#39;^{pattern}$&#39;, string)</code> 或者 <code>re.match(f&#39;{pattern}$&#39;, string)</code></li></ul><p>这个类比清晰地展示了 <code>fullmatch</code> 的本质：它隐式地包含了开头 <code>^</code> 和结尾 <code>$</code> 的锚定效果。</p><h5 id="1-8-2-代码示例对比"><a href="#1-8-2-代码示例对比" class="headerlink" title="1.8.2 代码示例对比"></a>1.8.2 代码示例对比</h5><p>让我们用同一个字符串和不同的模式来感受它们的差异。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">text = <span class="string">&quot;user@example.com&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 模式 1: &#x27;user&#x27;</span></span><br><span class="line">pattern1 = <span class="string">r&quot;user&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Pattern: &#x27;<span class="subst">&#123;pattern1&#125;</span>&#x27;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;re.match():    &quot;</span>, re.<span class="keyword">match</span>(pattern1, text))      <span class="comment"># 成功，因为字符串以 &#x27;user&#x27; 开头</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;re.search():   &quot;</span>, re.search(pattern1, text))     <span class="comment"># 成功，因为字符串中包含 &#x27;user&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;re.fullmatch():&quot;</span>, re.fullmatch(pattern1, text))  <span class="comment"># 失败 (None)，因为 &#x27;user&#x27; 不等于整个字符串</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-&quot;</span> * <span class="number">30</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模式 2: 一个完整的邮箱模式</span></span><br><span class="line">pattern2 = <span class="string">r&quot;[\w.-]+@[\w.-]+\.\w+&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Pattern: &#x27;<span class="subst">&#123;pattern2&#125;</span>&#x27;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;re.match():    &quot;</span>, re.<span class="keyword">match</span>(pattern2, text))      <span class="comment"># 成功，因为整个字符串从头开始就是一个邮箱</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;re.search():   &quot;</span>, re.search(pattern2, text))     <span class="comment"># 成功，因为整个字符串就是一个邮箱</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;re.fullmatch():&quot;</span>, re.fullmatch(pattern2, text))  <span class="comment"># 成功，因为整个字符串完美匹配了邮箱模式</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-&quot;</span> * <span class="number">30</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 另一个例子，包含额外字符</span></span><br><span class="line">text2 = <span class="string">&quot;username: test&quot;</span></span><br><span class="line"></span><br><span class="line">pattern3 = <span class="string">r&quot;username&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Text: &#x27;<span class="subst">&#123;text2&#125;</span>&#x27;, Pattern: &#x27;<span class="subst">&#123;pattern3&#125;</span>&#x27;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;re.match():    &quot;</span>, re.<span class="keyword">match</span>(pattern3, text2))     <span class="comment"># 成功</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;re.fullmatch():&quot;</span>, re.fullmatch(pattern3, text2)) <span class="comment"># 失败 (None)，因为字符串末尾还有 &quot;: test&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>输出结果：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Pattern: &#x27;user&#x27;</span><br><span class="line">re.match():     &lt;re.Match object; span=(0, 4), match=&#x27;user&#x27;&gt;</span><br><span class="line">re.search():    &lt;re.Match object; span=(0, 4), match=&#x27;user&#x27;&gt;</span><br><span class="line">re.fullmatch(): None</span><br><span class="line">------------------------------</span><br><span class="line">Pattern: &#x27;[\w.-]+@[\w.-]+\.\w+&#x27;</span><br><span class="line">re.match():     &lt;re.Match object; span=(0, 16), match=&#x27;user@example.com&#x27;&gt;</span><br><span class="line">re.search():    &lt;re.Match object; span=(0, 16), match=&#x27;user@example.com&#x27;&gt;</span><br><span class="line">re.fullmatch(): &lt;re.Match object; span=(0, 16), match=&#x27;user@example.com&#x27;&gt;</span><br><span class="line">------------------------------</span><br><span class="line">Text: &#x27;username: test&#x27;, Pattern: &#x27;username&#x27;</span><br><span class="line">re.match():     &lt;re.Match object; span=(0, 8), match=&#x27;username&#x27;&gt;</span><br><span class="line">re.fullmatch(): None</span><br></pre></td></tr></table></figure><h5 id="1-8-3-主要应用场景"><a href="#1-8-3-主要应用场景" class="headerlink" title="1.8.3 主要应用场景"></a>1.8.3 主要应用场景</h5><p><code>re.fullmatch</code> 的主要用途是<strong>数据验证（Validation）</strong>。</p><p>当你需要确保一个输入（比如用户提交的表单字段、配置文件中的一行等）<strong>严格地、完整地</strong>符合特定格式，不多不少时，<code>re.fullmatch</code> 是最直接、最清晰的选择。</p><p><strong>常见用例：</strong></p><ul><li><p><strong>验证用户名</strong>：要求用户名只能是 6-12 位的字母和数字组合。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">username = <span class="string">&quot;my_user123&quot;</span></span><br><span class="line"><span class="keyword">if</span> re.fullmatch(<span class="string">r&quot;[a-zA-Z0-9]&#123;6,12&#125;&quot;</span>, username):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Username is valid.&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Username is invalid.&quot;</span>)</span><br></pre></td></tr></table></figure><p>如果用 <code>re.match</code>，<code>&quot;my_user123!!!&quot;</code> 也会被认为是合法的，因为它只检查了开头部分。</p></li><li><p><strong>验证手机号码</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">phone = <span class="string">&quot;18812345678&quot;</span></span><br><span class="line"><span class="keyword">if</span> re.fullmatch(<span class="string">r&quot;1[3-9]\d&#123;9&#125;&quot;</span>, phone):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Phone number is valid.&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Phone number is invalid.&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><p><strong>验证身份证号</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">id_card = <span class="string">&quot;44010119900101123X&quot;</span></span><br><span class="line"><span class="keyword">if</span> re.fullmatch(<span class="string">r&quot;\d&#123;17&#125;[\dXx]&quot;</span>, id_card):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;ID card format is valid.&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;ID card format is invalid.&quot;</span>)</span><br></pre></td></tr></table></figure></li></ul><p>在 <code>re.fullmatch</code> 出现之前，为了实现同样的效果，开发者通常需要手动在模式的开头和结尾加上 <code>^</code> 和 <code>$</code>，然后使用 <code>re.match</code>，例如 <code>re.match(r&quot;^{pattern}$&quot;, string)</code>。<code>re.fullmatch</code> 提供了更语义化、更易读的写法。</p><h3 id="2-匹配对象（Match-Object）"><a href="#2-匹配对象（Match-Object）" class="headerlink" title="2. 匹配对象（Match Object）"></a>2. 匹配对象（Match Object）</h3><p>当 <code>match()</code> 或 <code>search()</code> 成功时，它们返回一个匹配对象。这个对象包含了匹配的详细信息，非常有用。</p><ul><li><code>match.group(0)</code> 或 <code>match.group()</code>: 返回整个匹配的字符串。</li><li><code>match.group(n)</code>: 返回第 n 个捕获组匹配的字符串。</li><li><code>match.groups()</code>: 返回一个包含所有捕获组匹配内容的元组。</li><li><code>match.start()</code>: 返回匹配的开始位置索引。</li><li><code>match.end()</code>: 返回匹配的结束位置索引。</li><li><code>match.span()</code>: 返回一个包含 <code>(start, end)</code> 的元组。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">text = <span class="string">&quot;Date: 2023-10-26&quot;</span></span><br><span class="line"><span class="keyword">match</span> = re.search(<span class="string">r&quot;(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)&quot;</span>, text)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">match</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;整个匹配:&quot;</span>, <span class="keyword">match</span>.group(<span class="number">0</span>))       <span class="comment"># 2023-10-26</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;第一个捕获组 (年):&quot;</span>, <span class="keyword">match</span>.group(<span class="number">1</span>)) <span class="comment"># 2023</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;第二个捕获组 (月):&quot;</span>, <span class="keyword">match</span>.group(<span class="number">2</span>)) <span class="comment"># 10</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;所有捕获组:&quot;</span>, <span class="keyword">match</span>.groups())      <span class="comment"># (&#x27;2023&#x27;, &#x27;10&#x27;, &#x27;26&#x27;)</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;开始位置:&quot;</span>, <span class="keyword">match</span>.start())        <span class="comment"># 6</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;结束位置:&quot;</span>, <span class="keyword">match</span>.end())          <span class="comment"># 16</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;起止位置:&quot;</span>, <span class="keyword">match</span>.span())        <span class="comment"># (6, 16)</span></span><br></pre></td></tr></table></figure><h3 id="3-编译标志（Flags）"><a href="#3-编译标志（Flags）" class="headerlink" title="3. 编译标志（Flags）"></a>3. 编译标志（Flags）</h3><p>在调用 <code>re</code> 函数时，可以通过 <code>flags</code> 参数改变正则表达式的行为。</p><ul><li><code>re.IGNORECASE</code> 或 <code>re.I</code>: 忽略大小写匹配。</li><li><code>re.MULTILINE</code> 或 <code>re.M</code>: 多行模式。<code>^</code> 和 <code>$</code> 会匹配每一行的开头和结尾，而不仅仅是整个字符串的开头和结尾。</li><li><code>re.DOTALL</code> 或 <code>re.S</code>: 使 <code>.</code> 能够匹配包括换行符在内的所有字符。</li><li><code>re.VERBOSE</code> 或 <code>re.X</code>: 详细模式。允许你在正则表达式中添加空白和注释，使其更具可读性。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># VERBOSE 模式示例</span></span><br><span class="line">pattern = re.<span class="built_in">compile</span>(<span class="string">r&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    ^(\d&#123;4&#125;)    # 捕获年份</span></span><br><span class="line"><span class="string">    -           # 分隔符</span></span><br><span class="line"><span class="string">    (\d&#123;2&#125;)     # 捕获月份</span></span><br><span class="line"><span class="string">    -           # 分隔符</span></span><br><span class="line"><span class="string">    (\d&#123;2&#125;)     # 捕获日期</span></span><br><span class="line"><span class="string">    $</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>, re.VERBOSE)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(pattern.<span class="keyword">match</span>(<span class="string">&quot;2023-10-26&quot;</span>))</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li><strong>使用原始字符串</strong>：始终使用 <code>r&quot;...&quot;</code> 来定义你的正则表达式模式。</li><li><strong>编译你的模式</strong>：如果一个模式需要被多次使用，使用 <code>re.compile()</code> 来提高性能。</li><li><strong>善用工具</strong>：使用在线正则表达式测试工具（如 <a href="https://regex101.com/">regex101.com</a>, <a href="https://regexr.com/">regexr.com</a>）可以极大地帮助你调试和理解正则表达式。这些工具可以实时显示匹配结果，并对你的模式进行详细解释。</li><li><strong>理解贪婪与懒惰</strong>：这是许多正则表达式错误的根源。明确你想要的是“最多”匹配还是“最少”匹配。</li><li><strong>优先使用 <code>search</code></strong>：除非你确定你的模式必须从字符串的开头匹配，否则 <code>re.search()</code> 通常比 <code>re.match()</code> 更有用。</li></ol>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CPP学习笔记—依赖注入</title>
      <link href="/2025/10/09/CPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/"/>
      <url>/2025/10/09/CPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<p><strong>依赖注入 (Dependency Injection, DI)</strong>。这是一个在现代软件工程中至关重要的概念，尤其是在构建大型、可维护和可测试的系统中。</p><hr><h3 id="1-什么是依赖？什么是问题所在？"><a href="#1-什么是依赖？什么是问题所在？" class="headerlink" title="1. 什么是依赖？什么是问题所在？"></a>1. 什么是依赖？什么是问题所在？</h3><p>在面向对象编程中，一个类（或对象）通常需要依赖其他类（或对象）来完成其工作。这种“需要”就是<strong>依赖</strong>。</p><p><strong>问题代码（紧密耦合）</strong>：</p><p>让我们从一个没有使用依赖注入的例子开始。假设我们有一个 <code>Car</code> 类，它需要一个 <code>Engine</code> 和一个 <code>Logger</code> 来工作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 依赖 1: 具体的 V8 引擎</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">V8Engine</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;V8 Engine starts. Vroom Vroom!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 依赖 2: 具体的控制台日志记录器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConsoleLogger</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> std::string&amp; message)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;[LOG]: &quot;</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Car 类，自己创建并管理它的依赖</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    V8Engine engine_;</span><br><span class="line">    ConsoleLogger logger_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Car</span>() &#123;</span><br><span class="line">        <span class="comment">// Car 内部直接创建了它的依赖对象</span></span><br><span class="line">        <span class="comment">// 这就是紧密耦合！</span></span><br><span class="line">        <span class="comment">// engine_ = V8Engine();</span></span><br><span class="line">        <span class="comment">// logger_ = ConsoleLogger();</span></span><br><span class="line">        logger_.<span class="built_in">log</span>(<span class="string">&quot;Car has been created.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger_.<span class="built_in">log</span>(<span class="string">&quot;Attempting to start the car.&quot;</span>);</span><br><span class="line">        engine_.<span class="built_in">start</span>();</span><br><span class="line">        logger_.<span class="built_in">log</span>(<span class="string">&quot;Car started successfully.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Car myCar;</span><br><span class="line">    myCar.<span class="built_in">start</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码看起来很简单，而且能工作。但它存在几个严重的问题：</p><ol><li><strong>紧密耦合 (Tight Coupling)</strong>：<code>Car</code> 类<strong>直接</strong>依赖于 <code>V8Engine</code> 和 <code>ConsoleLogger</code> 这两个<strong>具体</strong>的类。<code>Car</code> 的代码写死了它必须使用 V8 引擎和控制台日志。</li><li><strong>难以测试 (Hard to Test)</strong>：如何对 <code>Car</code> 类进行单元测试？我们只想测试 <code>Car</code> 的 <code>start</code> 逻辑，但它会自动调用 <code>V8Engine::start</code> 和 <code>ConsoleLogger::log</code>。我们无法在测试中“模拟”（Mock）一个引擎的行为（比如，测试引擎启动失败的情况），也无法验证日志是否被正确调用，因为它们都是硬编码在 <code>Car</code> 内部的。</li><li><strong>缺乏灵活性和可扩展性 (Inflexible and Not Extensible)</strong>：如果我想给这辆车换一个 <code>ElectricEngine</code>（电动引擎）怎么办？或者，我希望日志不是输出到控制台，而是写入文件（<code>FileLogger</code>）？唯一的办法就是<strong>修改 <code>Car</code> 类的源代码</strong>。这违反了<strong>开闭原则</strong>（对扩展开放，对修改关闭）。</li></ol><hr><h3 id="2-核心思想：控制反转-Inversion-of-Control-IoC-与依赖注入-DI"><a href="#2-核心思想：控制反转-Inversion-of-Control-IoC-与依赖注入-DI" class="headerlink" title="2. 核心思想：控制反转 (Inversion of Control, IoC) 与依赖注入 (DI)"></a>2. 核心思想：控制反转 (Inversion of Control, IoC) 与依赖注入 (DI)</h3><p>为了解决上述问题，我们引入了<strong>控制反转 (Inversion of Control, IoC)</strong> 的概念。</p><ul><li><strong>传统控制流程</strong>：<code>Car</code> 类自己负责创建和管理它所依赖的 <code>Engine</code> 和 <code>Logger</code> 对象。<code>Car</code> 控制着一切。</li><li><strong>控制反转</strong>：<code>Car</code> 类<strong>不再</strong>自己创建依赖，而是<strong>被动地接收</strong>这些依赖。创建依赖的“控制权”从 <code>Car</code> 内部<strong>反转</strong>到了 <code>Car</code> 的外部。</li></ul><p><strong>依赖注入 (Dependency Injection, DI)</strong> 是实现控制反转最常见和最主要的方式。</p><p><strong>DI 的核心定义</strong>：不要在类内部创建依赖，而是通过外部（调用者）将依赖传递（注入）给它。</p><hr><h3 id="3-DI-的实现方式"><a href="#3-DI-的实现方式" class="headerlink" title="3. DI 的实现方式"></a>3. DI 的实现方式</h3><p>在 C++ 中，主要有三种实现依赖注入的方式。为了让 DI 发挥最大作用，我们通常会结合<strong>面向接口编程</strong>（即依赖于抽象而不是具体实现）。</p><p>首先，定义我们需要的抽象接口：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象接口 1: IEngine</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IEngine</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">IEngine</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">start</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象接口 2: ILogger</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ILogger</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">ILogger</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> std::string&amp; message)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后，我们提供这些接口的具体实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具体实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">V8Engine</span> : <span class="keyword">public</span> IEngine &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;V8 Engine starts. Vroom Vroom!&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ElectricEngine</span> : <span class="keyword">public</span> IEngine &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Electric Engine starts. Bzzzzzz!&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConsoleLogger</span> : <span class="keyword">public</span> ILogger &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> std::string&amp; message)</span> <span class="keyword">override</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;[CONSOLE LOG]: &quot;</span> &lt;&lt; message &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FileLogger</span> : <span class="keyword">public</span> ILogger &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string filePath_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">FileLogger</span>(std::string path) : <span class="built_in">filePath_</span>(std::<span class="built_in">move</span>(path)) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> std::string&amp; message)</span> <span class="keyword">override</span> </span>&#123; </span><br><span class="line">        <span class="comment">// 伪代码: 将 message 写入到 filePath_ 文件</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;[FILE LOG to &quot;</span> &lt;&lt; filePath_ &lt;&lt; <span class="string">&quot;]: &quot;</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在，我们重构 <code>Car</code> 类，使其依赖于 <code>IEngine</code> 和 <code>ILogger</code> 接口，并使用 DI 来接收具体的实现。</p><h4 id="方式一：构造函数注入-Constructor-Injection"><a href="#方式一：构造函数注入-Constructor-Injection" class="headerlink" title="方式一：构造函数注入 (Constructor Injection)"></a>方式一：构造函数注入 (Constructor Injection)</h4><p>这是最常用、也是最推荐的方式。依赖通过类的构造函数传入。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Car 类现在依赖于抽象接口，而不是具体类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unique_ptr&lt;IEngine&gt; engine_; <span class="comment">// 使用智能指针管理生命周期</span></span><br><span class="line">    std::shared_ptr&lt;ILogger&gt; logger_; <span class="comment">// Logger 可能被多处共享，用 shared_ptr</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 依赖通过构造函数注入</span></span><br><span class="line">    <span class="built_in">Car</span>(std::unique_ptr&lt;IEngine&gt; engine, std::shared_ptr&lt;ILogger&gt; logger)</span><br><span class="line">        : <span class="built_in">engine_</span>(std::<span class="built_in">move</span>(engine)), <span class="built_in">logger_</span>(std::<span class="built_in">move</span>(logger)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!engine_ || !logger_) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">invalid_argument</span>(<span class="string">&quot;Engine and Logger must not be null.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        logger_-&gt;<span class="built_in">log</span>(<span class="string">&quot;Car has been created with injected dependencies.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger_-&gt;<span class="built_in">log</span>(<span class="string">&quot;Attempting to start the car.&quot;</span>);</span><br><span class="line">        engine_-&gt;<span class="built_in">start</span>();</span><br><span class="line">        logger_-&gt;<span class="built_in">log</span>(<span class="string">&quot;Car started successfully.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --- 客户端代码 (main 函数) ---</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 外部负责创建具体的依赖对象</span></span><br><span class="line">    <span class="keyword">auto</span> logger = std::<span class="built_in">make_shared</span>&lt;ConsoleLogger&gt;();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;--- Building a Gas Car ---&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">auto</span> v8_engine = std::<span class="built_in">make_unique</span>&lt;V8Engine&gt;();</span><br><span class="line">    <span class="comment">// 将依赖注入到 Car 中</span></span><br><span class="line">    <span class="function">Car <span class="title">gasCar</span><span class="params">(std::move(v8_engine), logger)</span></span>;</span><br><span class="line">    gasCar.<span class="built_in">start</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n--- Building an Electric Car ---&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">auto</span> electric_engine = std::<span class="built_in">make_unique</span>&lt;ElectricEngine&gt;();</span><br><span class="line">    <span class="comment">// 注入不同的依赖，创建不同行为的对象，而 Car 类完全不用修改</span></span><br><span class="line">    <span class="function">Car <span class="title">electricCar</span><span class="params">(std::move(electric_engine), logger)</span></span>;</span><br><span class="line">    electricCar.<span class="built_in">start</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>优点</strong>：<ul><li><strong>依赖明确</strong>：构造函数清晰地声明了该类需要哪些依赖才能工作。</li><li><strong>保证有效状态</strong>：一旦对象被构造出来，它就处于一个完整的、可用的状态，因为所有必需的依赖都已提供。</li><li><strong>不变性</strong>：依赖一旦被注入，通常在对象的生命周期内是不可变的。</li></ul></li><li><strong>缺点</strong>：<ul><li>如果依赖项过多，构造函数会变得很长，很笨重。</li><li>不适用于有循环依赖的场景（A 依赖 B，B 依赖 A）。</li></ul></li></ul><h4 id="方式二：Setter-注入-Setter-Method-Injection"><a href="#方式二：Setter-注入-Setter-Method-Injection" class="headerlink" title="方式二：Setter 注入 (Setter&#x2F;Method Injection)"></a>方式二：Setter 注入 (Setter&#x2F;Method Injection)</h4><p>通过公有的 setter 方法来注入依赖。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unique_ptr&lt;IEngine&gt; engine_;</span><br><span class="line">    std::shared_ptr&lt;ILogger&gt; logger_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Car</span>() = <span class="keyword">default</span>; <span class="comment">// 允许创建一个 &quot;不完整&quot; 的对象</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setEngine</span><span class="params">(std::unique_ptr&lt;IEngine&gt; engine)</span> </span>&#123;</span><br><span class="line">        engine_ = std::<span class="built_in">move</span>(engine);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setLogger</span><span class="params">(std::shared_ptr&lt;ILogger&gt; logger)</span> </span>&#123;</span><br><span class="line">        logger_ = std::<span class="built_in">move</span>(logger);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (logger_) logger_-&gt;<span class="built_in">log</span>(<span class="string">&quot;Attempting to start the car.&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (engine_) &#123;</span><br><span class="line">            engine_-&gt;<span class="built_in">start</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger_) logger_-&gt;<span class="built_in">log</span>(<span class="string">&quot;Error: Engine not set!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (logger_) logger_-&gt;<span class="built_in">log</span>(<span class="string">&quot;Car start sequence finished.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --- 客户端代码 ---</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> logger = std::<span class="built_in">make_shared</span>&lt;FileLogger&gt;(<span class="string">&quot;car_log.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Car myCar; <span class="comment">// 创建时没有依赖</span></span><br><span class="line">    myCar.<span class="built_in">setLogger</span>(logger); <span class="comment">// 注入 Logger</span></span><br><span class="line">    myCar.<span class="built_in">setEngine</span>(std::<span class="built_in">make_unique</span>&lt;V8Engine&gt;()); <span class="comment">// 注入 Engine</span></span><br><span class="line">    </span><br><span class="line">    myCar.<span class="built_in">start</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>优点</strong>：<ul><li><strong>灵活性高</strong>：可以在对象的生命周期内随时更改依赖。</li><li><strong>适用于可选依赖</strong>：如果某个依赖不是必需的，Setter 注入是很好的选择。</li><li>可以解决循环依赖问题。</li></ul></li><li><strong>缺点</strong>：<ul><li><strong>状态不确定</strong>：对象在调用 setter 方法前，可能处于一个不完整的、不可用的状态。需要在使用前进行检查（如 <code>if (engine_)</code>）。</li><li><strong>依赖关系不明确</strong>：不查看代码，无法一眼看出这个类到底需要哪些依赖。</li></ul></li></ul><h4 id="方式三：接口注入-Interface-Injection"><a href="#方式三：接口注入-Interface-Injection" class="headerlink" title="方式三：接口注入 (Interface Injection)"></a>方式三：接口注入 (Interface Injection)</h4><p>定义一个注入接口，让需要被注入的类实现这个接口。这种方式在 C++ 中不太常用，在 Java 或 C# 等语言中更常见一些。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义注入接口</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IInjectable</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">IInjectable</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">inject</span><span class="params">(T dependency)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Car 实现注入接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> : <span class="keyword">public</span> IInjectable&lt;std::shared_ptr&lt;ILogger&gt;&gt;,</span><br><span class="line">            <span class="keyword">public</span> IInjectable&lt;std::unique_ptr&lt;IEngine&gt;&gt; &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unique_ptr&lt;IEngine&gt; engine_;</span><br><span class="line">    std::shared_ptr&lt;ILogger&gt; logger_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inject</span><span class="params">(std::unique_ptr&lt;IEngine&gt; engine)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        engine_ = std::<span class="built_in">move</span>(engine);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inject</span><span class="params">(std::shared_ptr&lt;ILogger&gt; logger)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        logger_ = std::<span class="built_in">move</span>(logger);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... start() 方法 ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>优点</strong>：可以精确地控制注入哪种类型的依赖。</li><li><strong>缺点</strong>：侵入性强，需要让类继承特定的注入接口，增加了代码的复杂度和耦合度。在 C++ 中很少使用。</li></ul><hr><h3 id="4-依赖注入的巨大优势"><a href="#4-依赖注入的巨大优势" class="headerlink" title="4. 依赖注入的巨大优势"></a>4. 依赖注入的巨大优势</h3><p>现在我们回头看，DI 到底解决了什么问题？</p><ol><li><p><strong>解耦 (Decoupling)</strong>：<code>Car</code> 类不再与 <code>V8Engine</code> 或 <code>ConsoleLogger</code> 耦合，而是与 <code>IEngine</code> 和 <code>ILogger</code> 接口耦合。这被称为<strong>依赖倒置原则 (Dependency Inversion Principle, DIP)</strong> - “高层模块不应该依赖于低层模块，两者都应该依赖于抽象”。</p></li><li><p><strong>极强的可测试性 (Superior Testability)</strong>：这是 DI 最重要的优点之一！我们可以轻松地为 <code>Car</code> 编写单元测试。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// --- 单元测试示例 (使用 Google Test 框架的伪代码) ---</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gtest/gtest.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gmock/gmock.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 创建 Mock 对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MockEngine</span> : <span class="keyword">public</span> IEngine &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MOCK_METHOD</span>(<span class="type">void</span>, start, (), (<span class="keyword">override</span>)); <span class="comment">// 使用 GMock 宏</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MockLogger</span> : <span class="keyword">public</span> ILogger &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MOCK_METHOD</span>(<span class="type">void</span>, log, (<span class="type">const</span> std::string&amp; message), (<span class="keyword">override</span>));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 编写测试用例</span></span><br><span class="line"><span class="built_in">TEST</span>(CarTest, Start_CallsEngineStartAndLogsCorrectly) &#123;</span><br><span class="line">    <span class="comment">// Arrange: 准备测试环境</span></span><br><span class="line">    <span class="keyword">auto</span> mockEngine = std::<span class="built_in">make_unique</span>&lt;MockEngine&gt;();</span><br><span class="line">    <span class="keyword">auto</span> mockLogger = std::<span class="built_in">make_shared</span>&lt;MockLogger&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 Mock 对象的预期行为</span></span><br><span class="line">    <span class="built_in">EXPECT_CALL</span>(*mockEngine, <span class="built_in">start</span>()).<span class="built_in">Times</span>(<span class="number">1</span>); <span class="comment">// 期望 start() 被调用一次</span></span><br><span class="line">    <span class="built_in">EXPECT_CALL</span>(*mockLogger, <span class="built_in">log</span>(testing::_)).<span class="built_in">Times</span>(testing::<span class="built_in">AtLeast</span>(<span class="number">1</span>)); <span class="comment">// 期望 log() 被调用至少一次</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Act: 执行被测试的操作</span></span><br><span class="line">    <span class="function">Car <span class="title">car</span><span class="params">(std::move(mockEngine), mockLogger)</span></span>;</span><br><span class="line">    car.<span class="built_in">start</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Assert: GTest 和 GMock 会自动验证 EXPECT_CALL 是否满足</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个测试中，我们完全控制了 <code>Car</code> 的依赖，可以验证 <code>Car</code> 是否正确地调用了它们，而不需要一个真正的引擎或日志系统。</p></li><li><p><strong>高度的灵活性和可重用性 (Flexibility &amp; Reusability)</strong>：如 <code>main</code> 函数所示，我们可以像搭积木一样，将不同的引擎和日志记录器组合起来，创建出不同行为的 <code>Car</code> 对象，而 <code>Car</code> 类本身一行代码都不用改。</p></li></ol><hr><h3 id="5-应用场合"><a href="#5-应用场合" class="headerlink" title="5. 应用场合"></a>5. 应用场合</h3><p>依赖注入几乎适用于所有中大型项目，特别是当你希望代码是<strong>松耦合、可维护、可测试</strong>的时候。</p><ol><li><strong>单元测试</strong>：如上所示，这是 DI 的“杀手级应用”。如果你想对一个类进行隔离测试，DI 是必经之路。</li><li><strong>跨平台&#x2F;环境开发</strong>：你的应用可能需要运行在不同环境下。例如，一个数据访问层，在生产环境可能使用 <code>PostgreSQLDatabase</code>，但在测试环境使用 <code>InMemoryDatabase</code>。通过 DI，你可以在程序启动时根据配置注入不同的数据库实现。</li><li><strong>策略模式的实现</strong>：当你需要动态地切换算法或策略时。例如，一个 <code>PaymentProcessor</code> 类，可以根据用户选择，注入 <code>CreditCardPaymentStrategy</code> 或 <code>PayPalPaymentStrategy</code>。</li><li><strong>处理横切关注点 (Cross-Cutting Concerns)</strong>：像日志、缓存、事务管理、权限验证等功能，它们通常散布在系统的各个角落。通过 DI，你可以很容易地将一个 <code>ILogger</code> 或 <code>ICacheProvider</code> 注入到任何需要它的服务中。</li><li><strong>插件式或模块化架构</strong>：主应用程序定义接口，各个插件模块实现这些接口。主程序通过 DI 来加载和使用这些插件，而无需知道插件的具体实现。</li></ol><hr><h3 id="6-DI-容器-DI-Containers"><a href="#6-DI-容器-DI-Containers" class="headerlink" title="6. DI 容器 (DI Containers)"></a>6. DI 容器 (DI Containers)</h3><p>在大型项目中，手动创建和注入所有依赖会变得非常繁琐和复杂，这个过程被称为<strong>组合根 (Composition Root)</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在一个大型应用的 main 函数中，可能会是这样：</span></span><br><span class="line"><span class="keyword">auto</span> dbConfig = <span class="built_in">loadConfig</span>(<span class="string">&quot;db.json&quot;</span>);</span><br><span class="line"><span class="keyword">auto</span> dbConnection = std::<span class="built_in">make_shared</span>&lt;PostgreSQLConnection&gt;(dbConfig);</span><br><span class="line"><span class="keyword">auto</span> userRepository = std::<span class="built_in">make_shared</span>&lt;UserRepository&gt;(dbConnection);</span><br><span class="line"><span class="keyword">auto</span> logger = std::<span class="built_in">make_shared</span>&lt;FileLogger&gt;(<span class="string">&quot;app.log&quot;</span>);</span><br><span class="line"><span class="keyword">auto</span> authService = std::<span class="built_in">make_shared</span>&lt;AuthService&gt;(userRepository, logger);</span><br><span class="line"><span class="keyword">auto</span> app = <span class="built_in">Application</span>(authService, logger);</span><br><span class="line">app.<span class="built_in">run</span>();</span><br></pre></td></tr></table></figure><p>当依赖关系图变得复杂时，手动管理变得困难。这时<strong>DI 容器</strong>（也叫 IoC 容器）就派上用场了。</p><p>DI 容器是一个框架，它可以自动地管理对象的创建和依赖注入。你只需要告诉容器：</p><ol><li>“当我需要一个 <code>ILogger</code> 时，请给我一个 <code>FileLogger</code> 的实例。”（服务注册）</li><li>“请给我创建一个 <code>Application</code> 的实例。”（服务解析）</li></ol><p>容器会自动分析 <code>Application</code> 的构造函数，发现它需要 <code>IAuthService</code> 和 <code>ILogger</code>，然后它会去创建这些依赖（并递归地创建依赖的依赖），最后将它们全部组装好并返回给你。</p><p>C++ 中虽然没有像 Java Spring 或 .NET Core 那样内置的 DI 容器，但有很多优秀的第三方库，例如：</p><ul><li><strong>Boost.DI</strong></li><li><strong>Google Fruit</strong></li></ul><p>使用 DI 容器的代码（以 Boost.DI 为例的伪代码）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/di.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> di = boost::di;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... (接口和类定义) ...</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 创建和配置注射器 (injector)</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> injector = di::<span class="built_in">make_injector</span>(</span><br><span class="line">        di::<span class="built_in">bind</span>&lt;ILogger&gt;().<span class="built_in">to</span>&lt;FileLogger&gt;(), <span class="comment">// 绑定接口到具体实现</span></span><br><span class="line">        di::<span class="built_in">bind</span>&lt;IEngine&gt;().<span class="built_in">to</span>&lt;V8Engine&gt;(),</span><br><span class="line">        di::<span class="built_in">bind</span>&lt;std::string&gt;().<span class="built_in">named</span>(<span class="string">&quot;log_path&quot;</span>).<span class="built_in">to</span>(<span class="string">&quot;app.log&quot;</span>) <span class="comment">// 注入配置参数</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 从容器中创建对象</span></span><br><span class="line">    <span class="comment">// 容器会自动解决 Car 的所有依赖</span></span><br><span class="line">    <span class="keyword">auto</span> car = injector.<span class="built_in">create</span>&lt;Car&gt;(); </span><br><span class="line">    car.<span class="built_in">start</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>依赖注入是一种设计模式，更是一种编程思想。它的核心是<strong>将依赖的创建和管理的控制权从类内部移到外部</strong>。通过这种方式，我们可以构建出<strong>松耦合、高内聚、易于测试和维护</strong>的健壮系统。在现代 C++ 开发中，熟练掌握并使用 DI 是编写高质量代码的关键技能之一。</p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CPP学习笔记—工厂模式</title>
      <link href="/2025/10/09/CPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
      <url>/2025/10/09/CPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="1-什么是工厂模式？为什么需要它？"><a href="#1-什么是工厂模式？为什么需要它？" class="headerlink" title="1. 什么是工厂模式？为什么需要它？"></a>1. 什么是工厂模式？为什么需要它？</h3><p><strong>核心思想</strong>：工厂模式是一种创建型设计模式，其核心思想是<strong>将对象的创建过程封装起来</strong>。客户端（使用对象的代码）不再直接使用 <code>new</code> 关键字来创建具体类的实例，而是向一个“工厂”请求一个对象，由工厂来决定到底创建哪个具体类的实例。</p><p><strong>解决的问题</strong>：<br>想象一下，如果没有工厂模式，你的代码可能会是这样的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端代码</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">some_function</span><span class="params">(<span class="type">const</span> std::string&amp; shapeType)</span> </span>&#123;</span><br><span class="line">    Shape* shape = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (shapeType == <span class="string">&quot;Circle&quot;</span>) &#123;</span><br><span class="line">        shape = <span class="keyword">new</span> <span class="built_in">Circle</span>(); <span class="comment">// 直接依赖具体类 Circle</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shapeType == <span class="string">&quot;Square&quot;</span>) &#123;</span><br><span class="line">        shape = <span class="keyword">new</span> <span class="built_in">Square</span>(); <span class="comment">// 直接依赖具体类 Square</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shapeType == <span class="string">&quot;Triangle&quot;</span>) &#123;</span><br><span class="line">        shape = <span class="keyword">new</span> <span class="built_in">Triangle</span>(); <span class="comment">// 直接依赖具体类 Triangle</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (shape) &#123;</span><br><span class="line">        shape-&gt;<span class="built_in">draw</span>();</span><br><span class="line">        <span class="keyword">delete</span> shape; <span class="comment">// 还需要手动管理内存</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码有几个严重的问题：</p><ol><li><strong>紧密耦合</strong>：客户端代码 <code>some_function</code> 与具体的 <code>Circle</code>, <code>Square</code>, <code>Triangle</code> 类紧密地耦合在一起。如果未来要增加一个新的形状，比如 <code>Rectangle</code>，你必须修改 <code>some_function</code> 函数，在 <code>if-else</code> 链中增加一个分支。这违反了<strong>开闭原则</strong>（对扩展开放，对修改关闭）。</li><li><strong>创建逻辑重复</strong>：如果系统中有多个地方需要根据类型创建形状，那么这段 <code>if-else</code> 逻辑就会在各处重复出现，难以维护。</li><li><strong>创建过程复杂</strong>：如果创建某个对象的过程非常复杂（例如，需要读取配置文件、进行复杂的初始化等），这些复杂的逻辑会散布在客户端代码中，使其变得混乱。</li></ol><p><strong>工厂模式的目标</strong>就是将这种对象的创建逻辑从客户端代码中分离出来，集中到一个地方进行管理，从而实现<strong>解耦</strong>、<strong>封装</strong>和<strong>可维护性</strong>。</p><hr><h3 id="2-工厂模式的分类"><a href="#2-工厂模式的分类" class="headerlink" title="2. 工厂模式的分类"></a>2. 工厂模式的分类</h3><p>通常，我们将工厂模式分为三种类型，它们在复杂度和灵活性上层层递进：</p><ol><li><strong>简单工厂模式 (Simple Factory Pattern)</strong> - 最简单，但不属于 GoF（《设计模式》）的 23 种标准设计模式之一，但非常常用。</li><li><strong>工厂方法模式 (Factory Method Pattern)</strong> - GoF 标准模式之一，解决了简单工厂的扩展性问题。</li><li><strong>抽象工厂模式 (Abstract Factory Pattern)</strong> - GoF 标准模式之一，用于创建一系列相关的对象（产品族）。</li></ol><p>下面我们逐一详细讲解。</p><hr><h3 id="3-简单工厂模式-Simple-Factory-Pattern"><a href="#3-简单工厂模式-Simple-Factory-Pattern" class="headerlink" title="3. 简单工厂模式 (Simple Factory Pattern)"></a>3. 简单工厂模式 (Simple Factory Pattern)</h3><p><strong>定义</strong>：定义一个工厂类，它可以根据传入的参数来动态决定应该创建哪一个产品类的实例。</p><p><strong>结构</strong>：</p><ul><li><strong>Factory (工厂类)</strong>：负责实现创建所有实例的内部逻辑。</li><li><strong>Product (抽象产品)</strong>：定义了所有具体产品需要实现的接口（在 C++ 中通常是抽象基类）。</li><li><strong>ConcreteProduct (具体产品)</strong>：实现了 Product 接口的具体类，是工厂创建的目标。</li></ul><p><strong>C++ 示例</strong>：</p><p>我们用一个制作不同类型咖啡的例子来说明。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 抽象产品 (Product)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Coffee</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Coffee</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 具体产品 (ConcreteProduct)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Americano</span> : <span class="keyword">public</span> Coffee &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;一杯美式咖啡&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Latte</span> : <span class="keyword">public</span> Coffee &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;一杯拿铁咖啡&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 工厂类 (Factory)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CoffeeFactory</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 使用 C++11 的智能指针 std::unique_ptr 来管理内存</span></span><br><span class="line">    <span class="function"><span class="type">static</span> std::unique_ptr&lt;Coffee&gt; <span class="title">createCoffee</span><span class="params">(<span class="type">const</span> std::string&amp; type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="string">&quot;Americano&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;Americano&gt;();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="string">&quot;Latte&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;Latte&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果没有匹配的类型，可以返回 nullptr 或抛出异常</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端代码</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 客户不需要知道 Americano 和 Latte 的具体实现</span></span><br><span class="line">    <span class="comment">// 只需要通过工厂和类型字符串来获取对象</span></span><br><span class="line">    <span class="keyword">auto</span> americano = CoffeeFactory::<span class="built_in">createCoffee</span>(<span class="string">&quot;Americano&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (americano) &#123;</span><br><span class="line">        americano-&gt;<span class="built_in">show</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> latte = CoffeeFactory::<span class="built_in">createCoffee</span>(<span class="string">&quot;Latte&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (latte) &#123;</span><br><span class="line">        latte-&gt;<span class="built_in">show</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优点</strong>：</p><ul><li><strong>封装</strong>：将对象的创建逻辑封装在工厂类中，客户端代码只与工厂和抽象产品接口打交道，实现了客户端与具体产品的解耦。</li><li><strong>简单直观</strong>：结构简单，易于理解和实现。</li></ul><p><strong>缺点</strong>：</p><ul><li><strong>违反开闭原则</strong>：当需要增加一种新的咖啡类型时（例如 Cappuccino），必须修改 <code>CoffeeFactory</code> 类的 <code>createCoffee</code> 方法，在 <code>if-else</code> 中增加一个新的分支。这不符合“对修改关闭”的原则。</li><li><strong>职责过重</strong>：所有的产品创建逻辑都集中在一个工厂类中，如果产品种类非常多，这个工厂类会变得非常庞大和臃肿。</li></ul><p><strong>应用场合</strong>：</p><ul><li>当需要创建的对象较少，且不经常增加新产品时。</li><li>客户端不关心对象的创建过程，只关心如何使用。</li></ul><hr><h3 id="4-工厂方法模式-Factory-Method-Pattern"><a href="#4-工厂方法模式-Factory-Method-Pattern" class="headerlink" title="4. 工厂方法模式 (Factory Method Pattern)"></a>4. 工厂方法模式 (Factory Method Pattern)</h3><p><strong>定义</strong>：定义一个用于创建对象的接口（工厂方法），但让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。</p><p><strong>结构</strong>：</p><ul><li><strong>Product (抽象产品)</strong>：与简单工厂中的定义相同。</li><li><strong>ConcreteProduct (具体产品)</strong>：与简单工厂中的定义相同。</li><li><strong>Creator (抽象工厂)</strong>：声明一个 <code>FactoryMethod</code>，该方法返回一个 Product 类型的对象。</li><li><strong>ConcreteCreator (具体工厂)</strong>：实现 <code>FactoryMethod</code>，负责创建并返回具体的 ConcreteProduct 实例。</li></ul><p><strong>C++ 示例</strong>：</p><p>这次，我们让每个咖啡店（具体工厂）自己决定制作哪种咖啡。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 抽象产品 (Product) - 和上面一样</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Coffee</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Coffee</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 具体产品 (ConcreteProduct) - 和上面一样</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Americano</span> : <span class="keyword">public</span> Coffee &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;一杯美式咖啡&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Latte</span> : <span class="keyword">public</span> Coffee &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;一杯拿铁咖啡&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 抽象工厂 (Creator)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CoffeeFactory</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">CoffeeFactory</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="comment">// 这是工厂方法，它是一个纯虚函数，由子类实现</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::unique_ptr&lt;Coffee&gt; <span class="title">createCoffee</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">serveCoffee</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> coffee = <span class="built_in">createCoffee</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;为您准备好了: &quot;</span>;</span><br><span class="line">        coffee-&gt;<span class="built_in">show</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 具体工厂 (ConcreteCreator)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AmericanoFactory</span> : <span class="keyword">public</span> CoffeeFactory &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::unique_ptr&lt;Coffee&gt; <span class="title">createCoffee</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;Americano&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LatteFactory</span> : <span class="keyword">public</span> CoffeeFactory &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::unique_ptr&lt;Coffee&gt; <span class="title">createCoffee</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;Latte&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端代码</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 想要美式咖啡，就找美式咖啡工厂</span></span><br><span class="line">    <span class="keyword">auto</span> americano_factory = std::<span class="built_in">make_unique</span>&lt;AmericanoFactory&gt;();</span><br><span class="line">    americano_factory-&gt;<span class="built_in">serveCoffee</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 想要拿铁，就找拿铁工厂</span></span><br><span class="line">    <span class="keyword">auto</span> latte_factory = std::<span class="built_in">make_unique</span>&lt;LatteFactory&gt;();</span><br><span class="line">    latte_factory-&gt;<span class="built_in">serveCoffee</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ======== 扩展性展示 ========</span></span><br><span class="line">    <span class="comment">// 如果要新增一种卡布奇诺咖啡</span></span><br><span class="line">    <span class="comment">// 1. 创建新产品 Cappuccino</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Cappuccino</span> : <span class="keyword">public</span> Coffee &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;一杯卡布奇诺&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 2. 创建新工厂 CappuccinoFactory</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">CappuccinoFactory</span> : <span class="keyword">public</span> CoffeeFactory &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function">std::unique_ptr&lt;Coffee&gt; <span class="title">createCoffee</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;Cappuccino&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 客户端代码完全不需要修改，只需要使用新的工厂即可</span></span><br><span class="line">    <span class="keyword">auto</span> cappuccino_factory = std::<span class="built_in">make_unique</span>&lt;CappuccinoFactory&gt;();</span><br><span class="line">    cappuccino_factory-&gt;<span class="built_in">serveCoffee</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优点</strong>：</p><ul><li><strong>遵循开闭原则</strong>：当需要添加新产品时，只需添加一个新的具体产品类和一个新的具体工厂类，而无需修改任何现有代码。这使得系统扩展性极佳。</li><li><strong>职责单一</strong>：每个具体工厂只负责创建一个具体产品，符合单一职责原则。</li><li><strong>解耦</strong>：客户端代码只依赖于抽象工厂和抽象产品，与具体实现无关。</li></ul><p><strong>缺点</strong>：</p><ul><li><strong>类的数量增加</strong>：每增加一个产品，就需要增加一个对应的具体工厂类，这会使得系统中的类数量成倍增加，增加了系统的复杂度和代码量。</li></ul><p><strong>应用场合</strong>：</p><ul><li>当一个类不知道它所需要的对象的具体类型时（例如，一个框架需要创建由其用户自定义的组件）。</li><li>当一个类希望由它的子类来指定它所创建的对象时。</li><li>当你想为用户提供一个创建对象的接口，但又不希望暴露创建对象的具体细节时（例如，在库或框架开发中）。</li></ul><hr><h3 id="5-抽象工厂模式-Abstract-Factory-Pattern"><a href="#5-抽象工厂模式-Abstract-Factory-Pattern" class="headerlink" title="5. 抽象工厂模式 (Abstract Factory Pattern)"></a>5. 抽象工厂模式 (Abstract Factory Pattern)</h3><p><strong>定义</strong>：提供一个接口，用于创建<strong>一系列相关或相互依赖的对象</strong>（产品族），而无需指定它们具体的类。</p><p><strong>核心区别</strong>：工厂方法模式关注的是<strong>一个产品</strong>的创建，而抽象工厂模式关注的是<strong>一个产品族</strong>（多个不同类型但相互关联的产品）的创建。</p><p><strong>结构</strong>：</p><ul><li><strong>AbstractFactory (抽象工厂)</strong>：声明一组用于创建抽象产品的接口（例如 <code>createProductA()</code>, <code>createProductB()</code>）。</li><li><strong>ConcreteFactory (具体工厂)</strong>：实现 AbstractFactory 的接口，负责创建一组具体的产品。</li><li><strong>AbstractProduct (抽象产品)</strong>：为一类产品对象声明一个接口（例如 <code>ProductA</code>, <code>ProductB</code>）。</li><li><strong>ConcreteProduct (具体产品)</strong>：定义了由相应的具体工厂创建的具体产品对象。</li></ul><p><strong>C++ 示例</strong>：</p><p>假设我们要创建一个跨平台的 GUI 库，它需要提供按钮（Button）和复选框（Checkbox）。我们希望它能同时支持 Windows 和 macOS 风格。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ---- 抽象产品 ----</span></span><br><span class="line"><span class="comment">// 1. 抽象产品 A: Button</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Button</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Button</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">paint</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 抽象产品 B: Checkbox</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Checkbox</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Checkbox</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">check</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---- Windows 产品族 ----</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WindowsButton</span> : <span class="keyword">public</span> Button &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">paint</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;渲染一个 Windows 风格的按钮&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WindowsCheckbox</span> : <span class="keyword">public</span> Checkbox &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">check</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;勾选一个 Windows 风格的复选框&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---- macOS 产品族 ----</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MacOSButton</span> : <span class="keyword">public</span> Button &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">paint</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;渲染一个 macOS 风格的按钮&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MacOSCheckbox</span> : <span class="keyword">public</span> Checkbox &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">check</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;勾选一个 macOS 风格的复选框&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---- 抽象工厂 ----</span></span><br><span class="line"><span class="comment">// 定义了创建一族产品 (Button 和 Checkbox) 的接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GUIFactory</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">GUIFactory</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::unique_ptr&lt;Button&gt; <span class="title">createButton</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::unique_ptr&lt;Checkbox&gt; <span class="title">createCheckbox</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---- 具体工厂 ----</span></span><br><span class="line"><span class="comment">// 1. Windows 工厂，负责创建所有 Windows 风格的组件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WindowsFactory</span> : <span class="keyword">public</span> GUIFactory &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::unique_ptr&lt;Button&gt; <span class="title">createButton</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;WindowsButton&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;Checkbox&gt; <span class="title">createCheckbox</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;WindowsCheckbox&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. macOS 工厂，负责创建所有 macOS 风格的组件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MacOSFactory</span> : <span class="keyword">public</span> GUIFactory &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::unique_ptr&lt;Button&gt; <span class="title">createButton</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;MacOSButton&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;Checkbox&gt; <span class="title">createCheckbox</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;MacOSCheckbox&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端代码</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unique_ptr&lt;GUIFactory&gt; factory;</span><br><span class="line">    std::unique_ptr&lt;Button&gt; button;</span><br><span class="line">    std::unique_ptr&lt;Checkbox&gt; checkbox;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Application</span><span class="params">(std::unique_ptr&lt;GUIFactory&gt; f)</span> : factory(std::move(f)) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">createUI</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        button = factory-&gt;<span class="built_in">createButton</span>();</span><br><span class="line">        checkbox = factory-&gt;<span class="built_in">createCheckbox</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        button-&gt;<span class="built_in">paint</span>();</span><br><span class="line">        checkbox-&gt;<span class="built_in">check</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根据当前环境选择一个工厂</span></span><br><span class="line">    <span class="comment">// 假设我们在 Windows 环境</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;在 Windows 环境下运行:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">auto</span> win_factory = std::<span class="built_in">make_unique</span>&lt;WindowsFactory&gt;();</span><br><span class="line">    <span class="function">Application <span class="title">app_win</span><span class="params">(std::move(win_factory))</span></span>;</span><br><span class="line">    app_win.<span class="built_in">createUI</span>();</span><br><span class="line">    app_win.<span class="built_in">run</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n切换到 macOS 环境运行:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 假设切换到了 macOS 环境</span></span><br><span class="line">    <span class="keyword">auto</span> mac_factory = std::<span class="built_in">make_unique</span>&lt;MacOSFactory&gt;();</span><br><span class="line">    <span class="function">Application <span class="title">app_mac</span><span class="params">(std::move(mac_factory))</span></span>;</span><br><span class="line">    app_mac.<span class="built_in">createUI</span>();</span><br><span class="line">    app_mac.<span class="built_in">run</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优点</strong>：</p><ul><li><strong>隔离具体类</strong>：客户端代码完全与具体产品实现分离，只依赖于抽象工厂和抽象产品接口。</li><li><strong>易于切换产品族</strong>：只需要改变具体工厂的实例，就可以轻松地切换整个产品族。在上面的例子中，从 Windows 风格切换到 macOS 风格只需要更换工厂对象。</li><li><strong>保证产品兼容性</strong>：由于一个具体工厂只创建属于同一产品族的产品，因此可以保证这些产品之间是相互兼容的。</li></ul><p><strong>缺点</strong>：</p><ul><li><strong>难以扩展新的产品类型</strong>：如果要在产品族中增加一个新的产品（例如，增加一个 <code>TextField</code>），那么需要修改抽象工厂 <code>GUIFactory</code> 的接口，这会导致所有具体工厂子类都需要进行修改，违反了开闭原则。</li></ul><p><strong>应用场合</strong>：</p><ul><li>当一个系统需要与多个产品系列中的一个系列进行配置时。</li><li>当系统要独立于其产品的创建、组合和表示时。</li><li>当你需要提供一个产品类库，而只想暴露它们的接口而不是实现时。</li><li>例如：更换数据库访问层（一个工厂用于 SQL Server，一个用于 Oracle），更换UI主题，支持不同的操作系统等。</li></ul><hr><h3 id="6-总结与对比"><a href="#6-总结与对比" class="headerlink" title="6. 总结与对比"></a>6. 总结与对比</h3><table><thead><tr><th align="left">特性</th><th align="left">简单工厂模式</th><th align="left">工厂方法模式</th><th align="left">抽象工厂模式</th></tr></thead><tbody><tr><td align="left"><strong>目的</strong></td><td align="left">封装单一产品的创建</td><td align="left">封装单一产品的创建，但将决策延迟到子类</td><td align="left">封装一个产品族的创建</td></tr><tr><td align="left"><strong>复杂度</strong></td><td align="left">低</td><td align="left">中</td><td align="left">高</td></tr><tr><td align="left"><strong>开闭原则</strong></td><td align="left">违反 (修改工厂类)</td><td align="left">遵守 (添加新工厂)</td><td align="left">遵守 (添加新产品族)，违反 (添加新产品类型)</td></tr><tr><td align="left"><strong>代码结构</strong></td><td align="left">一个工厂类，多个产品类</td><td align="left">抽象工厂+具体工厂，抽象产品+具体产品</td><td align="left">抽象工厂+具体工厂，多组抽象产品+具体产品</td></tr><tr><td align="left"><strong>关注点</strong></td><td align="left">如何创建<strong>一个</strong>产品</td><td align="left">如何创建<strong>一个</strong>产品</td><td align="left">如何创建<strong>一组</strong>产品</td></tr></tbody></table><h3 id="7-C-特有的考量"><a href="#7-C-特有的考量" class="headerlink" title="7. C++ 特有的考量"></a>7. C++ 特有的考量</h3><ul><li><strong>智能指针</strong>：在 C++11 及以后的版本中，工厂方法返回对象时应优先使用智能指针（<code>std::unique_ptr</code> 或 <code>std::shared_ptr</code>）来管理对象的生命周期，避免内存泄漏。<code>std::unique_ptr</code> 通常是首选，因为它表达了所有权的唯一性，开销也更低。</li><li><strong>模板元编程</strong>：对于某些场景，可以使用模板来实现更泛化的工厂，减少手写具体工厂类的需要，但这会增加编译期复杂性。</li></ul>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CPP学习笔记—单例模式</title>
      <link href="/2025/10/09/CPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2025/10/09/CPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="1-什么是单例模式？"><a href="#1-什么是单例模式？" class="headerlink" title="1. 什么是单例模式？"></a>1. 什么是单例模式？</h3><p>单例模式是一种创建型设计模式，其核心思想是<strong>确保一个类在任何情况下都只有一个实例，并提供一个全局访问点来获取这个唯一的实例</strong>。</p><p>可以把它想象成一个国家的总统或者一个学校的校长，在整个系统运行期间，这个角色只能有一个人担任。无论你从哪个部门、哪个流程去“找校长”，最终找到的都是同一个人。</p><p>为了在 C++ 中实现这一点，通常需要满足三个关键条件：</p><ol><li><strong>私有的构造函数</strong>：为了防止外部代码通过 <code>new</code> 操作符随意创建类的实例。</li><li><strong>一个私有的、静态的、指向本类实例的指针或对象</strong>：这是存放那个唯一实例的地方。</li><li><strong>一个公有的、静态的、用于获取实例的方法</strong>：这是全局唯一的访问点，负责创建并返回那个唯一的实例。</li></ol><hr><h3 id="2-为什么需要单例模式？"><a href="#2-为什么需要单例模式？" class="headerlink" title="2. 为什么需要单例模式？"></a>2. 为什么需要单例模式？</h3><p>单例模式主要用于解决那些“全局唯一”且需要被频繁共享访问的资源或服务。常见的应用场景包括：</p><ul><li><strong>日志记录器（Logger）</strong>：整个应用程序通常只需要一个日志记录器，所有模块都通过它来写入日志文件。</li><li><strong>配置管理器（Configuration Manager）</strong>：读取和管理应用的配置信息（如数据库连接字符串、API 密钥等），这些信息在整个应用中是共享的。</li><li><strong>数据库连接池（Database Connection Pool）</strong>：管理数据库连接，避免频繁地创建和销毁连接，整个应用共享一个连接池。</li><li><strong>硬件接口访问</strong>：比如访问打印机、串口等，通常需要一个统一的管理器来避免冲突。</li></ul><p>使用单例模式可以带来以下好处：</p><ul><li><strong>资源节约</strong>：避免了重复创建重量级对象带来的开销。</li><li><strong>数据一致性</strong>：确保所有部分访问的是同一份数据或状态。</li><li><strong>全局访问</strong>：提供了一个方便的全局访问点，简化了代码。</li></ul><hr><h3 id="3-如何实现单例模式？（C-实现的演进）"><a href="#3-如何实现单例模式？（C-实现的演进）" class="headerlink" title="3. 如何实现单例模式？（C++ 实现的演进）"></a>3. 如何实现单例模式？（C++ 实现的演进）</h3><p>在 C++ 中，单例的实现有多种方式，并且随着 C++ 标准的演进，最佳实践也在发生变化。下面我们来看一下这个演进过程。</p><h4 id="版本一：懒汉式（Lazy-Singleton）-基础但线程不安全"><a href="#版本一：懒汉式（Lazy-Singleton）-基础但线程不安全" class="headerlink" title="版本一：懒汉式（Lazy Singleton）- 基础但线程不安全"></a>版本一：懒汉式（Lazy Singleton）- 基础但线程不安全</h4><p>“懒汉”指的是只有在第一次被请求时，实例才会被创建，而不是在程序启动时就创建。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// version_1_lazy.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 1. 私有构造函数</span></span><br><span class="line">    <span class="built_in">Singleton</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Singleton instance created.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 私有静态实例指针</span></span><br><span class="line">    <span class="type">static</span> Singleton* instance_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 3. 公有静态获取实例的方法</span></span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 只有当 instance_ 为空时才创建</span></span><br><span class="line">        <span class="keyword">if</span> (instance_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            instance_ = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为了防止拷贝和赋值</span></span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Hello from Singleton!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在类外初始化静态成员</span></span><br><span class="line">Singleton* Singleton::instance_ = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Singleton* s1 = Singleton::<span class="built_in">getInstance</span>();</span><br><span class="line">    Singleton* s2 = Singleton::<span class="built_in">getInstance</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s1 == s2) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;s1 and s2 are the same instance.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s1-&gt;<span class="built_in">showMessage</span>();</span><br><span class="line">    <span class="comment">// 注意：这个版本需要手动释放内存，非常不推荐</span></span><br><span class="line">    <span class="comment">// delete s1; // 谁来释放？何时释放？这是一个问题</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>问题</strong>：<ol><li><strong>线程不安全</strong>：在多线程环境下，如果两个线程同时进入 <code>if (instance_ == nullptr)</code> 判断，并且都判断为 <code>true</code>，那么它们都会创建一个实例，这就破坏了单例的原则。这被称为<strong>竞态条件（Race Condition）</strong>。</li><li><strong>内存泄漏</strong>：<code>new</code> 出来的实例没有被 <code>delete</code>，会导致内存泄漏。虽然可以设计一个 <code>destroy</code> 方法或者使用智能指针，但这会增加复杂性。</li></ol></li></ul><h4 id="版本二：懒汉式-锁（Thread-Safe-Lazy-Singleton）"><a href="#版本二：懒汉式-锁（Thread-Safe-Lazy-Singleton）" class="headerlink" title="版本二：懒汉式 + 锁（Thread-Safe Lazy Singleton）"></a>版本二：懒汉式 + 锁（Thread-Safe Lazy Singleton）</h4><p>为了解决线程安全问题，最直接的方法就是加锁。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// version_2_lazy_with_lock.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span> <span class="comment">// 引入互斥锁</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Singleton instance created.&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="type">static</span> Singleton* instance_;</span><br><span class="line">    <span class="type">static</span> std::mutex mutex_; <span class="comment">// 增加一个互斥锁</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>; <span class="comment">// 进入前加锁</span></span><br><span class="line">        <span class="keyword">if</span> (instance_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            instance_ = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance_;</span><br><span class="line">        <span class="comment">// lock_guard 会在作用域结束时自动解锁</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton* Singleton::instance_ = <span class="literal">nullptr</span>;</span><br><span class="line">std::mutex Singleton::mutex_;</span><br></pre></td></tr></table></figure><ul><li><strong>优点</strong>：通过 <code>std::mutex</code> 保证了线程安全。</li><li><strong>问题</strong>：<ol><li><strong>性能开销</strong>：每次调用 <code>getInstance()</code> 都需要加锁和解锁，即使实例已经被创建。当实例创建后，这个锁其实是多余的，会影响高并发场景下的性能。</li><li><strong>内存泄漏问题</strong>依然存在。</li></ol></li></ul><h4 id="版本三：双重检查锁定（Double-Checked-Locking-Pattern-DCLP）"><a href="#版本三：双重检查锁定（Double-Checked-Locking-Pattern-DCLP）" class="headerlink" title="版本三：双重检查锁定（Double-Checked Locking Pattern, DCLP）"></a>版本三：双重检查锁定（Double-Checked Locking Pattern, DCLP）</h4><p>为了解决版本二的性能问题，人们想出了 DCLP。其思想是：先检查一次实例是否存在，如果不存在再加锁，加锁后再检查一次（防止其他线程在等待锁期间已经创建了实例）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// version_3_dclp.cpp</span></span><br><span class="line"><span class="comment">// !! 注意：这是一个有历史问题的模式，现代 C++ 中不推荐 !!</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span> <span class="comment">// 需要原子操作来保证可见性</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Singleton instance created.&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="type">static</span> std::atomic&lt;Singleton*&gt; instance_; <span class="comment">// 使用 atomic</span></span><br><span class="line">    <span class="type">static</span> std::mutex mutex_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Singleton* tmp = instance_.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">        <span class="keyword">if</span> (tmp == <span class="literal">nullptr</span>) &#123; <span class="comment">// 第一次检查</span></span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">            tmp = instance_.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">            <span class="keyword">if</span> (tmp == <span class="literal">nullptr</span>) &#123; <span class="comment">// 第二次检查</span></span><br><span class="line">                tmp = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">                instance_.<span class="built_in">store</span>(tmp, std::memory_order_release);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::atomic&lt;Singleton*&gt; Singleton::instance_&#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">std::mutex Singleton::mutex_;</span><br></pre></td></tr></table></figure><ul><li><strong>问题</strong>：DCLP 的实现在 C++11 之前是不可靠的，因为存在<strong>指令重排（Memory Reordering）<strong>问题，可能导致一个线程拿到一个尚未完全构造好的对象。在 C++11 及以后，通过 <code>std::atomic</code> 和正确的内存序（memory order）可以正确实现，但它</strong>非常复杂、难以理解且容易出错</strong>。我们有更好的选择。</li></ul><h4 id="版本四：Meyers’-Singleton（C-11-最佳实践）"><a href="#版本四：Meyers’-Singleton（C-11-最佳实践）" class="headerlink" title="版本四：Meyers’ Singleton（C++11 最佳实践）"></a>版本四：Meyers’ Singleton（C++11 最佳实践）</h4><p>这是 C++ 之父 Scott Meyers 提出的方法，利用了 C++11 标准中对 <strong>静态局部变量（Static Local Variable）</strong> 初始化的保证。</p><blockquote><p>C++11 标准规定：在一个函数或块内部的 <code>static</code> 变量的初始化是线程安全的。它只会被初始化一次。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// version_4_meyers_singleton.cpp (推荐!)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Singleton instance created.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 删除拷贝构造和赋值操作</span></span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton&amp; <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// C++11 保证了静态局部变量的初始化是线程安全的</span></span><br><span class="line">        <span class="type">static</span> Singleton instance;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Hello from Singleton! Address: &quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Singleton&amp; s1 = Singleton::<span class="built_in">getInstance</span>();</span><br><span class="line">    Singleton&amp; s2 = Singleton::<span class="built_in">getInstance</span>();</span><br><span class="line"></span><br><span class="line">    s<span class="number">1.</span><span class="built_in">showMessage</span>();</span><br><span class="line">    s<span class="number">2.</span><span class="built_in">showMessage</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (&amp;s1 == &amp;s2) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;s1 and s2 are the same instance.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 无需手动释放，程序结束时会自动销毁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>优点</strong>：<ol><li><strong>线程安全</strong>：C++11 标准保证了 <code>static Singleton instance;</code> 这行代码的执行是线程安全的。</li><li><strong>简洁优雅</strong>：代码量最少，逻辑最清晰。</li><li><strong>无内存泄漏</strong>：<code>instance</code> 是一个栈上的静态对象，其生命周期由程序管理，程序结束时会自动析构，无需手动 <code>delete</code>。</li><li><strong>懒汉式加载</strong>：只有在第一次调用 <code>getInstance()</code> 时才会创建实例。</li></ol></li></ul><p><strong>这是现代 C++ 中实现单例模式的首选方案。</strong></p><h4 id="版本五：饿汉式（Eager-Singleton）"><a href="#版本五：饿汉式（Eager-Singleton）" class="headerlink" title="版本五：饿汉式（Eager Singleton）"></a>版本五：饿汉式（Eager Singleton）</h4><p>“饿汉”指的是在程序启动时（main 函数执行前），实例就已经被创建好了，不管你用不用它。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// version_5_eager.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Singleton instance created at startup.&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在程序启动时就初始化</span></span><br><span class="line">    <span class="type">static</span> Singleton instance_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton&amp; <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance_;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在类外定义并初始化静态成员</span></span><br><span class="line">Singleton Singleton::instance_;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Main function started.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    Singleton&amp; s1 = Singleton::<span class="built_in">getInstance</span>();</span><br><span class="line">    Singleton&amp; s2 = Singleton::<span class="built_in">getInstance</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (&amp;s1 == &amp;s2) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;s1 and s2 are the same instance.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>优点</strong>：<ol><li><strong>天然线程安全</strong>：因为实例在多线程代码开始执行之前就已经创建好了，不存在竞态条件。</li><li><strong>实现简单</strong>。</li></ol></li><li><strong>缺点</strong>：<ol><li><strong>启动耗时</strong>：如果单例的构造函数非常耗时，会拖慢程序的启动速度。</li><li><strong>资源浪费</strong>：如果程序从头到尾都没有使用这个单例，那么它的创建就成了一种资源浪费。</li></ol></li></ul><hr><h3 id="4-单例模式的优缺点"><a href="#4-单例模式的优缺点" class="headerlink" title="4. 单例模式的优缺点"></a>4. 单例模式的优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li><strong>保证唯一实例</strong>：核心价值，确保了某些类只有一个对象。</li><li><strong>全局访问点</strong>：提供了一个方便的全局访问点，简化了对象间的调用。</li><li><strong>延迟初始化</strong>：懒汉式实现可以做到只在需要时才创建实例，节约资源。</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li><strong>违反单一职责原则（SRP）</strong>：一个类既要负责其核心业务逻辑，又要负责管理自己的生命周期（创建、销毁），职责过重。</li><li><strong>引入全局状态</strong>：单例本质上是全局变量的变种，会引入全局状态，使得代码的依赖关系变得不清晰。一个函数依赖了某个单例，但从函数签名上看不出来。</li><li><strong>难以进行单元测试</strong>：由于全局状态和紧耦合，对依赖单例的模块进行单元测试变得非常困难。很难用一个模拟的（Mock）对象来替换单例。</li><li><strong>扩展性差</strong>：如果未来需要这个类有多个实例，修改会非常困难。</li></ul><hr><h3 id="5-一个完整的现代-C-示例-Logger"><a href="#5-一个完整的现代-C-示例-Logger" class="headerlink" title="5. 一个完整的现代 C++ 示例 (Logger)"></a>5. 一个完整的现代 C++ 示例 (Logger)</h3><p>下面我们使用 Meyers’ Singleton 实现一个简单的日志记录器。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// complete_logger_example.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 获取单例实例的公共静态方法</span></span><br><span class="line">    <span class="function"><span class="type">static</span> Logger&amp; <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">static</span> Logger instance;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁止拷贝和赋值</span></span><br><span class="line">    <span class="built_in">Logger</span>(<span class="type">const</span> Logger&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Logger&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Logger&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 日志记录方法</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> std::string&amp; message)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用锁来保证多线程写入文件的安全</span></span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取当前时间</span></span><br><span class="line">        <span class="keyword">auto</span> now = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">        <span class="keyword">auto</span> <span class="type">in_time_t</span> = std::chrono::system_clock::<span class="built_in">to_time_t</span>(now);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 写入日志文件</span></span><br><span class="line">        log_file_ &lt;&lt; std::<span class="built_in">put_time</span>(std::<span class="built_in">localtime</span>(&amp;<span class="type">in_time_t</span>), <span class="string">&quot;%Y-%m-%d %X&quot;</span>)</span><br><span class="line">                  &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 私有构造函数，在其中打开日志文件</span></span><br><span class="line">    <span class="built_in">Logger</span>() &#123;</span><br><span class="line">        log_file_.<span class="built_in">open</span>(<span class="string">&quot;application.log&quot;</span>, std::ios::out | std::ios::app);</span><br><span class="line">        <span class="keyword">if</span> (!log_file_.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;Error: Could not open log file!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">log</span>(<span class="string">&quot;Logger instance created.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有析构函数，在其中关闭日志文件</span></span><br><span class="line">    ~<span class="built_in">Logger</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (log_file_.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">            <span class="built_in">log</span>(<span class="string">&quot;Logger instance destroyed.&quot;</span>);</span><br><span class="line">            log_file_.<span class="built_in">close</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::ofstream log_file_;</span><br><span class="line">    std::mutex mutex_; <span class="comment">// 用于保护文件写入操作</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟多线程环境</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">worker_thread</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">    Logger::<span class="built_in">getInstance</span>().<span class="built_in">log</span>(<span class="string">&quot;Thread &quot;</span> + std::<span class="built_in">to_string</span>(id) + <span class="string">&quot; started.&quot;</span>);</span><br><span class="line">    <span class="comment">// ... do some work ...</span></span><br><span class="line">    Logger::<span class="built_in">getInstance</span>().<span class="built_in">log</span>(<span class="string">&quot;Thread &quot;</span> + std::<span class="built_in">to_string</span>(id) + <span class="string">&quot; finished.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Logger::<span class="built_in">getInstance</span>().<span class="built_in">log</span>(<span class="string">&quot;Main function started.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(worker_thread, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(worker_thread, <span class="number">2</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    Logger::<span class="built_in">getInstance</span>().<span class="built_in">log</span>(<span class="string">&quot;Main function finished.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行这段代码后，你会看到一个 <code>application.log</code> 文件，里面的日志记录了主函数和两个线程的活动，并且所有日志都是通过同一个 <code>Logger</code> 实例写入的。</p><hr><h3 id="6-总结与建议"><a href="#6-总结与建议" class="headerlink" title="6. 总结与建议"></a>6. 总结与建议</h3><ul><li><strong>单例模式是一个强大但需要谨慎使用的工具。</strong> 它能有效解决全局唯一资源的管理问题。</li><li><strong>在现代 C++ (C++11及以后) 中，强烈推荐使用 Meyers’ Singleton</strong>（基于静态局部变量的实现），因为它最简洁、安全、高效。</li><li><strong>在使用单例模式前，请三思</strong>：是否真的需要一个全局唯一的实例？有没有其他方式可以替代，比如<strong>依赖注入（Dependency Injection）</strong>？依赖注入通常能提供更好的可测试性和更松的耦合。</li><li>如果决定使用，请确保你的单例类是<strong>线程安全的</strong>，尤其是在其成员函数会修改内部状态时（如上面的 <code>log</code> 方法）。</li></ul>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CPP学习笔记—初始化方式</title>
      <link href="/2025/10/03/CPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E5%BC%8F/"/>
      <url>/2025/10/03/CPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>C++ 的初始化是一个庞大而精细的主题，从 C 语言的简单赋值风格，到 C++11 引入的统一初始化，其发展历程旨在解决二义性、提高类型安全性和代码一致性。</p><h3 id="为什么初始化如此重要？"><a href="#为什么初始化如此重要？" class="headerlink" title="为什么初始化如此重要？"></a>为什么初始化如此重要？</h3><p>在 C++ 中，一个未经初始化的变量（非静态局部变量）拥有一个<strong>不确定的值</strong>。读取这个值会导致<strong>未定义行为 (Undefined Behavior, UB)</strong>，这是 C++ 中最危险的陷阱之一，可能导致程序崩溃、数据损坏或看似正常运行但结果错误。</p><hr><h3 id="C-初始化方式的演变与分类"><a href="#C-初始化方式的演变与分类" class="headerlink" title="C++ 初始化方式的演变与分类"></a>C++ 初始化方式的演变与分类</h3><p>我们可以大致将初始化方式分为两大类：<strong>C++11 之前</strong>的传统方式和 <strong>C++11 及其之后</strong>引入的统一初始化（大括号初始化）。</p><h3 id="第一部分：C-11-之前的传统初始化方式"><a href="#第一部分：C-11-之前的传统初始化方式" class="headerlink" title="第一部分：C++11 之前的传统初始化方式"></a>第一部分：C++11 之前的传统初始化方式</h3><p>在 C++11 之前，主要有以下几种初始化方式，它们的语法不统一，有时会带来困惑。</p><h4 id="1-默认初始化-Default-Initialization"><a href="#1-默认初始化-Default-Initialization" class="headerlink" title="1. 默认初始化 (Default Initialization)"></a>1. 默认初始化 (Default Initialization)</h4><p>当一个变量在定义时没有提供显式的初始值时，就会发生默认初始化。</p><p><strong>语法</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T object_name;</span><br></pre></td></tr></table></figure><p><strong>行为</strong>：</p><ul><li><strong>对于局部变量（在函数内定义）</strong>：如果 <code>T</code> 是内置类型（如 <code>int</code>, <code>double</code>, <code>char*</code>），其值是<strong>不确定的</strong>（包含垃圾值）。如果 <code>T</code> 是类类型，则会调用其<strong>默认构造函数</strong>。如果类没有默认构造函数，则编译错误。</li><li><strong>对于静态或全局变量</strong>：所有静态存储期的变量（全局变量、<code>static</code> 局部变量、<code>static</code> 类成员）会被<strong>零初始化 (Zero Initialization)</strong>。这意味着内置类型被设为 0，指针被设为 <code>nullptr</code>，类类型会调用其默认构造函数。</li></ul><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x; <span class="comment">// 默认初始化，值不确定！(危险)</span></span><br><span class="line">    std::string s; <span class="comment">// 默认初始化，调用 std::string 的默认构造函数，s 为空字符串 &quot;&quot;</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; x &lt;&lt; std::endl; // 读取 x 的值是未定义行为！</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;s is: &#x27;&quot;</span> &lt;&lt; s &lt;&lt; <span class="string">&quot;&#x27;&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-拷贝初始化-Copy-Initialization"><a href="#2-拷贝初始化-Copy-Initialization" class="headerlink" title="2. 拷贝初始化 (Copy Initialization)"></a>2. 拷贝初始化 (Copy Initialization)</h4><p>使用等号 <code>=</code> 进行初始化。它的语义是“拷贝”一个值到新创建的对象中。</p><p><strong>语法</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T object_name = other_value;</span><br></pre></td></tr></table></figure><p><strong>行为</strong>：<br>编译器会尝试将 <code>other_value</code> 转换（隐式转换）为 <code>T</code> 类型，然后用于初始化 <code>object_name</code>。这通常会调用拷贝构造函数或移动构造函数。虽然看起来像赋值，但它<strong>是初始化，不是赋值</strong>。</p><p><strong>注意</strong>：</p><ul><li><strong>拷贝省略 (Copy Elision)</strong>：现代编译器通常会优化掉这里的拷贝过程，直接在 <code>object_name</code> 的内存上构造对象，但从语法和类型检查的角度，它仍然需要一个可访问的拷贝&#x2F;移动构造函数。</li><li><strong><code>explicit</code> 关键字</strong>：如果类的构造函数被标记为 <code>explicit</code>，那么它不能用于隐式类型转换，因此不能用于拷贝初始化。</li></ul><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>; <span class="comment">// 拷贝初始化</span></span><br><span class="line">std::string s = <span class="string">&quot;hello&quot;</span>; <span class="comment">// 拷贝初始化，&quot;hello&quot; (const char*) 隐式转换为 std::string</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; <span class="comment">// C++11 中的拷贝列表初始化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Widget</span><span class="params">(<span class="type">int</span>)</span> </span>&#123;&#125; <span class="comment">// explicit 构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Widget w1 = <span class="number">10</span>; <span class="comment">// 编译错误！因为 Widget(int) 是 explicit 的，不能用于隐式转换</span></span><br><span class="line"><span class="comment">// Widget w1 = &#123;10&#125;; // C++11 中同样编译错误</span></span><br><span class="line"><span class="function">Widget <span class="title">w2</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">// 正确，这是直接初始化</span></span><br></pre></td></tr></table></figure><h4 id="3-直接初始化-Direct-Initialization"><a href="#3-直接初始化-Direct-Initialization" class="headerlink" title="3. 直接初始化 (Direct Initialization)"></a>3. 直接初始化 (Direct Initialization)</h4><p>使用圆括号 <code>()</code> 进行初始化。</p><p><strong>语法</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">T <span class="title">object_name</span><span class="params">(arg1, arg2, ...)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>行为</strong>：<br>直接调用与参数列表 <code>(arg1, arg2, ...)</code> 相匹配的构造函数来初始化 <code>object_name</code>。它允许使用 <code>explicit</code> 构造函数。</p><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">x</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">std::string <span class="title">s</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">10</span>, <span class="number">5</span>)</span></span>; <span class="comment">// 创建一个包含 10 个值为 5 的元素的 vector</span></span><br><span class="line"></span><br><span class="line"><span class="function">Widget <span class="title">w</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">// 正确，即使构造函数是 explicit 的</span></span><br></pre></td></tr></table></figure><p><strong>直接初始化的一个著名陷阱：最令人头疼的解析 (Most Vexing Parse)</strong></p><p>如果一个语法可以被解释为一个函数声明，也可以被解释为一个对象定义，C++ 标准规定编译器<strong>优先将其解释为函数声明</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 程序员的意图：定义一个名为 my_timer 的 Timer 对象，使用默认构造函数初始化</span></span><br><span class="line"><span class="function">Timer <span class="title">my_timer</span><span class="params">()</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译器的解释：声明一个名为 my_timer 的函数，</span></span><br><span class="line"><span class="comment">// 该函数不接受参数，返回一个 Timer 对象。</span></span><br><span class="line"><span class="comment">// 这不是一个对象定义！</span></span><br></pre></td></tr></table></figure><p>这是一个巨大的坑，也是 C++11 引入统一初始化的重要原因之一。</p><h4 id="4-聚合初始化-Aggregate-Initialization"><a href="#4-聚合初始化-Aggregate-Initialization" class="headerlink" title="4. 聚合初始化 (Aggregate Initialization)"></a>4. 聚合初始化 (Aggregate Initialization)</h4><p>用于初始化聚合类型（没有用户提供的构造函数、没有私有或保护的非静态数据成员、没有基类、没有虚函数的 C 风格 <code>struct</code> 或数组）。</p><p><strong>语法</strong>：<br>使用花括号 <code>{}</code> 提供初始值列表。</p><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C 风格 struct</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> arr[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; <span class="comment">// 初始化数组</span></span><br><span class="line">Point p = &#123;<span class="number">10</span>, <span class="number">20</span>&#125;;     <span class="comment">// 初始化 struct</span></span><br></pre></td></tr></table></figure><p>这种方式在 C++11 中被极大地扩展了。</p><hr><h3 id="第二部分：C-11-的统一初始化-Uniform-Initialization"><a href="#第二部分：C-11-的统一初始化-Uniform-Initialization" class="headerlink" title="第二部分：C++11 的统一初始化 (Uniform Initialization)"></a>第二部分：C++11 的统一初始化 (Uniform Initialization)</h3><p>C++11 引入了使用花括号 <code>{}</code> 的初始化方式，也称为<strong>列表初始化 (List Initialization)</strong> 或<strong>大括号初始化 (Brace Initialization)</strong>。其目标是提供一种统一、无歧义、更安全的初始化语法。</p><p><strong>语法</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">T object_name &#123;arg1, arg2, ...&#125;;   <span class="comment">// 直接列表初始化</span></span><br><span class="line">T object_name = &#123;arg1, arg2, ...&#125;; <span class="comment">// 拷贝列表初始化</span></span><br></pre></td></tr></table></figure><h4 id="统一初始化的三大优势"><a href="#统一初始化的三大优势" class="headerlink" title="统一初始化的三大优势"></a>统一初始化的三大优势</h4><ol><li><p><strong>统一性与无歧义</strong>：<br>它解决了“最令人头疼的解析”问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Timer <span class="title">my_timer</span><span class="params">()</span></span>;  <span class="comment">// 函数声明</span></span><br><span class="line">Timer my_timer&#123;&#125;;  <span class="comment">// 明确的对象定义，调用默认构造函数</span></span><br></pre></td></tr></table></figure><p>它可以用在几乎所有初始化场景，包括变量定义、函数返回值、类成员初始化等，语法非常一致。</p></li><li><p><strong>防止窄化转换 (Narrowing Conversion)</strong>：<br>这是大括号初始化的一个<strong>核心安全特性</strong>。它禁止在初始化时发生可能导致数据丢失的类型转换。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">3.14</span>;    <span class="comment">// 合法，但有警告。x 的值为 3 (数据丢失)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">y</span><span class="params">(<span class="number">3.14</span>)</span></span>;     <span class="comment">// 合法，但有警告。y 的值为 3 (数据丢失)</span></span><br><span class="line"><span class="comment">// int z&#123;3.14&#125;;  // 编译错误！大括号初始化禁止从 double 到 int 的窄化转换</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> c1 = <span class="number">300</span>;   <span class="comment">// 合法，但行为是实现定义的（溢出）</span></span><br><span class="line"><span class="comment">// char c2&#123;300&#125;; // 编译错误！300 超出 char 的表示范围，是窄化转换</span></span><br></pre></td></tr></table></figure></li><li><p><strong>对 <code>std::initializer_list</code> 的原生支持</strong>：<br>这是大括号初始化最特殊、也最需要注意的一点。如果一个类有一个接受 <code>std::initializer_list</code> 的构造函数，那么使用大括号初始化时，编译器会<strong>强烈优先</strong>选择这个构造函数。</p><p><strong>示例</strong>：<br><code>std::vector</code> 同时有 <code>vector(size_type count, const T&amp; value)</code> 和 <code>vector(std::initializer_list&lt;T&gt;)</code> 两种构造函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">v1</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>; <span class="comment">// 直接初始化：调用构造函数 vector(size, value)</span></span><br><span class="line">                             <span class="comment">// v1 包含 10 个元素，每个都是 20</span></span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; v2&#123;<span class="number">10</span>, <span class="number">20</span>&#125;; <span class="comment">// 列表初始化：优先匹配 initializer_list 构造函数</span></span><br><span class="line">                             <span class="comment">// v2 包含 2 个元素：10 和 20</span></span><br></pre></td></tr></table></figure><p>这个特性非常强大，但也可能与你的直觉相悖，是使用大括号初始化时唯一需要小心的地方。</p></li></ol><h4 id="空大括号-的特殊含义：值初始化"><a href="#空大括号-的特殊含义：值初始化" class="headerlink" title="空大括号 {} 的特殊含义：值初始化"></a>空大括号 <code>{}</code> 的特殊含义：值初始化</h4><p>使用空的大括号 <code>{}</code> 会对对象进行<strong>值初始化 (Value Initialization)</strong>。</p><p><strong>语法</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">T object_name&#123;&#125;;</span><br><span class="line">T* ptr = <span class="keyword">new</span> T&#123;&#125;;</span><br></pre></td></tr></table></figure><p><strong>行为</strong>：</p><ul><li>对于内置类型，保证被<strong>零初始化</strong>。</li><li>对于类类型，调用其<strong>默认构造函数</strong>。</li></ul><p>这是一种非常安全和推荐的做法，可以确保所有变量都有一个良好定义的初始状态。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x&#123;&#125;;      <span class="comment">// x 被初始化为 0</span></span><br><span class="line"><span class="type">double</span> d&#123;&#125;;   <span class="comment">// d 被初始化为 0.0</span></span><br><span class="line"><span class="type">int</span>* p&#123;&#125;;     <span class="comment">// p 被初始化为 nullptr</span></span><br><span class="line">std::string s&#123;&#125;; <span class="comment">// s 为空字符串 &quot;&quot;</span></span><br></pre></td></tr></table></figure><hr><h3 id="第三部分：特殊的初始化场景"><a href="#第三部分：特殊的初始化场景" class="headerlink" title="第三部分：特殊的初始化场景"></a>第三部分：特殊的初始化场景</h3><h4 id="1-类成员初始化"><a href="#1-类成员初始化" class="headerlink" title="1. 类成员初始化"></a>1. 类成员初始化</h4><h5 id="a-构造函数成员初始化列表-Member-Initializer-List"><a href="#a-构造函数成员初始化列表-Member-Initializer-List" class="headerlink" title="a. 构造函数成员初始化列表 (Member Initializer List)"></a>a. 构造函数成员初始化列表 (Member Initializer List)</h5><p>这是在构造函数体执行<strong>之前</strong>初始化成员变量的唯一正确方式。</p><p><strong>语法</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> a, <span class="type">const</span> std::string&amp; b)</span><br><span class="line">        : <span class="built_in">member_a_</span>(a),       <span class="comment">// 直接初始化成员</span></span><br><span class="line">          <span class="built_in">member_b_</span>(b),       <span class="comment">// 拷贝初始化成员</span></span><br><span class="line">          <span class="built_in">const_member_</span>(<span class="number">100</span>), <span class="comment">// 初始化 const 成员</span></span><br><span class="line">          <span class="built_in">ref_member_</span>(a)      <span class="comment">// 初始化引用成员</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 构造函数体，此时所有成员都已初始化完毕</span></span><br><span class="line">        <span class="comment">// 这里执行的是赋值，而不是初始化</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> member_a_;</span><br><span class="line">    std::string member_b_;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> const_member_; <span class="comment">// const 成员</span></span><br><span class="line">    <span class="type">int</span>&amp; ref_member_;        <span class="comment">// 引用成员</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>为什么必须使用它？</strong></p><ul><li><strong>效率</strong>：对于类类型成员，使用初始化列表是直接调用构造函数进行初始化。如果在构造函数体内赋值，则会先调用该成员的默认构造函数（默认初始化），然后再调用赋值操作符，多了一步操作。</li><li><strong>正确性</strong>：<code>const</code> 成员和引用成员<strong>必须</strong>在成员初始化列表中进行初始化，因为它们一旦创建就不能被重新赋值。</li></ul><h5 id="b-类内成员初始化-In-class-Member-Initializers-C-11"><a href="#b-类内成员初始化-In-class-Member-Initializers-C-11" class="headerlink" title="b. 类内成员初始化 (In-class Member Initializers) (C++11)"></a>b. 类内成员初始化 (In-class Member Initializers) (C++11)</h5><p>C++11 允许在类定义中直接为非静态成员变量提供默认初始值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value_ = <span class="number">42</span>; <span class="comment">// C++11 类内初始化</span></span><br><span class="line">    std::string name_ = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; data_&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这极大地简化了构造函数。如果构造函数没有在成员初始化列表中为这些成员提供不同的初始值，它们就会使用这个默认值。这使得代码更简洁，并减少了因忘记在多个构造函数中初始化某个成员而导致的错误。</p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table><thead><tr><th align="left">初始化方式</th><th align="left">语法</th><th align="left">示例</th><th align="left">优点</th><th align="left">缺点&#x2F;注意事项</th></tr></thead><tbody><tr><td align="left"><strong>默认初始化</strong></td><td align="left"><code>T obj;</code></td><td align="left"><code>int x;</code></td><td align="left">简单</td><td align="left">对局部内置类型导致未定义行为。</td></tr><tr><td align="left"><strong>拷贝初始化</strong></td><td align="left"><code>T obj = val;</code></td><td align="left"><code>int x = 5;</code></td><td align="left">语法自然，符合直觉</td><td align="left">不支持 <code>explicit</code> 构造函数；可能存在隐式类型转换问题。</td></tr><tr><td align="left"><strong>直接初始化</strong></td><td align="left"><code>T obj(args);</code></td><td align="left"><code>int x(5);</code></td><td align="left">支持 <code>explicit</code> 构造函数；功能强大</td><td align="left">存在“最令人头疼的解析”问题；语法不统一。</td></tr><tr><td align="left"><strong>列表初始化 (统一初始化)</strong></td><td align="left"><code>T obj{args};</code> <code>T obj = {args};</code></td><td align="left"><code>int x{5};</code> <code>std::vector&lt;int&gt; v{1,2};</code></td><td align="left"><strong>统一语法</strong>，<strong>无歧义</strong>，<strong>防止窄化转换</strong>，<strong>保证值初始化</strong> (<code>{}</code>)</td><td align="left"><strong>会优先匹配 <code>std::initializer_list</code> 构造函数</strong>，可能不符合直觉。</td></tr><tr><td align="left"><strong>成员初始化列表</strong></td><td align="left"><code>Ctor() : mem(v) {}</code></td><td align="left"><code>MyClass() : x_(10) {}</code></td><td align="left"><strong>高效</strong>，初始化 <code>const</code>&#x2F;引用成员的<strong>唯一方式</strong></td><td align="left">只能在构造函数中使用。</td></tr><tr><td align="left"><strong>类内成员初始化</strong></td><td align="left"><code>class T { int m=5; };</code></td><td align="left"><code>int value_ = 42;</code></td><td align="left">简化构造函数，提供默认值，避免重复代码</td><td align="left">C++11 及以上版本才支持。</td></tr></tbody></table><h4 id="现代-C-C-11-及以后-的推荐实践："><a href="#现代-C-C-11-及以后-的推荐实践：" class="headerlink" title="现代 C++ (C++11 及以后) 的推荐实践："></a>现代 C++ (C++11 及以后) 的推荐实践：</h4><ol><li><p><strong>首选大括号统一初始化 <code>{}</code></strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x&#123;&#125;; <span class="comment">// 保证为 0</span></span><br><span class="line">Widget w&#123;&#125;; <span class="comment">// 调用默认构造函数</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure><p>它的安全性（防止窄化）和一致性使其成为绝大多数情况下的最佳选择。</p></li><li><p><strong>警惕 <code>std::initializer_list</code> 的“陷阱”</strong>。<br>当你需要调用一个非 <code>initializer_list</code> 的构造函数，而恰好又存在一个 <code>initializer_list</code> 构造函数时，请明确使用圆括号 <code>()</code> 进行直接初始化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 意图：创建一个包含 10 个 20 的 vector</span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>; <span class="comment">// 正确，使用 ()</span></span><br><span class="line"><span class="comment">// std::vector&lt;int&gt; v&#123;10, 20&#125;; // 错误，这会创建一个包含 &#123;10, 20&#125; 的 vector</span></span><br></pre></td></tr></table></figure></li><li><p><strong>总是使用成员初始化列表</strong>来初始化构造函数中的成员，或使用 <strong>C++11 的类内成员初始化</strong>来提供默认值。避免在构造函数体内进行赋值。</p></li><li><p><strong>养成随手初始化的习惯</strong>。绝不留下未初始化的变量。对于不确定初始值的变量，使用值初始化 (<code>{}</code>) 将其清零。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CPP学习笔记—priority_queue</title>
      <link href="/2025/09/19/CPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94priority-queue/"/>
      <url>/2025/09/19/CPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94priority-queue/</url>
      
        <content type="html"><![CDATA[<h3 id="1-priority-queue-是什么？"><a href="#1-priority-queue-是什么？" class="headerlink" title="1. priority_queue 是什么？"></a>1. <code>priority_queue</code> 是什么？</h3><p><code>std::priority_queue</code> 是 C++ 标准模板库（STL）中的一个容器适配器，它提供了一种特殊的队列：<strong>优先级队列</strong>。</p><h4 id="核心概念：优先出队"><a href="#核心概念：优先出队" class="headerlink" title="核心概念：优先出队"></a>核心概念：优先出队</h4><p>与普通的队列（<code>std::queue</code>）遵循“先进先出”（FIFO）的原则不同，优先级队列中的元素并非根据其进入队列的顺序出队，而是根据其<strong>优先级</strong>。每次从队列中取出的元素（通过 <code>top()</code> 访问，<code>pop()</code> 移除），都是当前队列中优先级最高的那个。</p><p>默认情况下，对于数字，“大”的元素优先级更高；对于其他类型，使用 <code>std::less</code> 作为比较函数，即通过 <code>operator&lt;</code> 来判断优先级。</p><h4 id="底层数据结构：堆-Heap"><a href="#底层数据结构：堆-Heap" class="headerlink" title="底层数据结构：堆 (Heap)"></a>底层数据结构：堆 (Heap)</h4><p><code>priority_queue</code> 的高效实现得益于其底层的<strong>堆</strong>数据结构。通常是<strong>最大堆 (Max-Heap)</strong>。</p><ul><li><strong>堆</strong>：一个特殊的完全二叉树，满足“堆属性”：父节点的值总是大于或等于（最大堆）或小于或等于（最小堆）其所有子节点的值。</li><li><strong>最大堆 (Max-Heap)</strong>：根节点是整个堆中最大的元素。<code>std::priority_queue</code> 默认就是最大堆。</li><li><strong>最小堆 (Min-Heap)</strong>：根节点是整个堆中最小的元素。</li></ul><p>由于这个特性，访问优先级最高的元素（即堆顶元素）的操作非常快。</p><h4 id="与-std-queue-的区别"><a href="#与-std-queue-的区别" class="headerlink" title="与 std::queue 的区别"></a>与 <code>std::queue</code> 的区别</h4><table><thead><tr><th align="left">特性</th><th align="left"><code>std::priority_queue</code></th><th align="left"><code>std::queue</code></th></tr></thead><tbody><tr><td align="left"><strong>出队规则</strong></td><td align="left">优先级最高（默认最大）的元素先出</td><td align="left">先进来的元素先出 (FIFO)</td></tr><tr><td align="left"><strong>访问队首</strong></td><td align="left"><code>top()</code></td><td align="left"><code>front()</code></td></tr><tr><td align="left"><strong>底层实现</strong></td><td align="left">堆 (通常是 <code>std::vector</code>)</td><td align="left">双端队列 (通常是 <code>std::deque</code>)</td></tr><tr><td align="left"><strong>元素顺序</strong></td><td align="left">内部维持堆有序，非完全排序</td><td align="left">保持插入顺序</td></tr></tbody></table><h4 id="容器适配器-Container-Adapter"><a href="#容器适配器-Container-Adapter" class="headerlink" title="容器适配器 (Container Adapter)"></a>容器适配器 (Container Adapter)</h4><p><code>priority_queue</code> 本身不是一个独立的容器，它是一个<strong>容器适配器</strong>。它包装了另一个序列容器（如 <code>std::vector</code> 或 <code>std::deque</code>），并利用该容器来存储元素，同时对外提供优先级队列的接口。默认情况下，它使用 <code>std::vector</code> 作为其底层容器。</p><hr><h3 id="2-何时使用-priority-queue？"><a href="#2-何时使用-priority-queue？" class="headerlink" title="2. 何时使用 priority_queue？"></a>2. 何时使用 <code>priority_queue</code>？</h3><p>当你需要处理一个集合，并且总是需要快速访问和移除其中“最重要”的元素时，就应该使用 <code>priority_queue</code>。常见应用场景包括：</p><ul><li><strong>Top K 问题</strong>：从大量数据中找出最大或最小的 K 个元素。</li><li><strong>图算法</strong>：<ul><li>Dijkstra 算法中用于找到下一个距离最短的未访问顶点。</li><li>Prim 算法中用于找到连接到当前树的最小权重的边。</li></ul></li><li><strong>任务调度</strong>：操作系统中，用于管理待处理的任务，总是先执行优先级最高的任务。</li><li><strong>事件驱动模拟</strong>：按时间顺序处理事件队列，时间最早的事件优先级最高。</li><li><strong>合并 K 个有序列表</strong>。</li></ul><hr><h3 id="3-基本用法"><a href="#3-基本用法" class="headerlink" title="3. 基本用法"></a>3. 基本用法</h3><h4 id="包含头文件和声明"><a href="#包含头文件和声明" class="headerlink" title="包含头文件和声明"></a>包含头文件和声明</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span> <span class="comment">// priority_queue 在 &lt;queue&gt; 头文件中</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个存储 int 的默认优先级队列（最大堆）</span></span><br><span class="line">std::priority_queue&lt;<span class="type">int</span>&gt; pq;</span><br></pre></td></tr></table></figure><h4 id="核心操作-push-pop-top"><a href="#核心操作-push-pop-top" class="headerlink" title="核心操作 (push, pop, top)"></a>核心操作 (<code>push</code>, <code>pop</code>, <code>top</code>)</h4><ul><li><strong><code>push(const T&amp; value)</code></strong>: 将元素 <code>value</code> 压入队列，并保持堆的属性。</li><li><strong><code>top() const</code></strong>: 返回对队首（优先级最高）元素的<strong>常量引用</strong>。注意，它只返回，不移除。</li><li><strong><code>pop()</code></strong>: 移除队首元素。注意，它没有返回值。</li></ul><p><strong>重要</strong>：获取并移除队首元素的标准操作是两步：</p><ol><li>用 <code>top()</code> 获取元素值。</li><li>用 <code>pop()</code> 将其从队列中移除。</li></ol><h4 id="辅助操作-size-empty"><a href="#辅助操作-size-empty" class="headerlink" title="辅助操作 (size, empty)"></a>辅助操作 (<code>size</code>, <code>empty</code>)</h4><ul><li><strong><code>size() const</code></strong>: 返回队列中元素的数量。</li><li><strong><code>empty() const</code></strong>: 检查队列是否为空。</li></ul><h4 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 默认是最大堆</span></span><br><span class="line">    std::priority_queue&lt;<span class="type">int</span>&gt; max_heap;</span><br><span class="line"></span><br><span class="line">    max_heap.<span class="built_in">push</span>(<span class="number">30</span>);</span><br><span class="line">    max_heap.<span class="built_in">push</span>(<span class="number">100</span>);</span><br><span class="line">    max_heap.<span class="built_in">push</span>(<span class="number">25</span>);</span><br><span class="line">    max_heap.<span class="built_in">push</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Max-heap contents (from highest to lowest priority):&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">while</span> (!max_heap.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; max_heap.<span class="built_in">top</span>() &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 访问最高优先级的元素</span></span><br><span class="line">        max_heap.<span class="built_in">pop</span>();                     <span class="comment">// 移除最高优先级的元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Max-heap contents (from highest to lowest priority):</span><br><span class="line">100 40 30 25 </span><br></pre></td></tr></table></figure><hr><h3 id="4-定制-priority-queue"><a href="#4-定制-priority-queue" class="headerlink" title="4. 定制 priority_queue"></a>4. 定制 <code>priority_queue</code></h3><h4 id="模板参数详解"><a href="#模板参数详解" class="headerlink" title="模板参数详解"></a>模板参数详解</h4><p><code>priority_queue</code> 的完整模板声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">T</span>,</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Container</span> = std::vector&lt;T&gt;,</span><br><span class="line">    <span class="keyword">class</span> Compare = std::less&lt;<span class="keyword">typename</span> Container::value_type&gt;</span><br><span class="line">&gt; <span class="keyword">class</span> priority_queue;</span><br></pre></td></tr></table></figure><ol><li><strong><code>T</code></strong>: 存储的元素类型。</li><li><strong><code>Container</code></strong>: 用于存储元素的底层容器。必须是支持 <code>front()</code>, <code>push_back()</code>, <code>pop_back()</code> 等操作的序列容器。<code>std::vector</code> (默认) 和 <code>std::deque</code> 是常用选择。</li><li><strong><code>Compare</code></strong>: 一个比较函数对象（Functor），用于确定元素的优先级。它必须提供一个 <code>bool operator()(const T&amp; a, const T&amp; b)</code>。如果 <code>operator()(a, b)</code> 返回 <code>true</code>，则认为 <code>b</code> 的优先级比 <code>a</code> 高。<ul><li>默认的 <code>std::less&lt;T&gt;</code> 使用 <code>operator&lt;</code>，<code>a &lt; b</code> 为 <code>true</code> 时 <code>b</code> 优先，这构成了<strong>最大堆</strong>。</li><li>要实现<strong>最小堆</strong>，我们需要一个比较器，当 <code>a &gt; b</code> 为 <code>true</code> 时 <code>b</code> 优先，这就是 <code>std::greater&lt;T&gt;</code>。</li></ul></li></ol><h4 id="如何实现最小堆-Min-Heap"><a href="#如何实现最小堆-Min-Heap" class="headerlink" title="如何实现最小堆 (Min-Heap)"></a>如何实现最小堆 (Min-Heap)</h4><p>只需在声明时提供后两个模板参数即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span> <span class="comment">// for std::greater</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 声明一个最小堆</span></span><br><span class="line">    std::priority_queue&lt;<span class="type">int</span>, std::vector&lt;<span class="type">int</span>&gt;, std::greater&lt;<span class="type">int</span>&gt;&gt; min_heap;</span><br><span class="line"></span><br><span class="line">    min_heap.<span class="built_in">push</span>(<span class="number">30</span>);</span><br><span class="line">    min_heap.<span class="built_in">push</span>(<span class="number">100</span>);</span><br><span class="line">    min_heap.<span class="built_in">push</span>(<span class="number">25</span>);</span><br><span class="line">    min_heap.<span class="built_in">push</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Min-heap contents (from lowest to highest priority):&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">while</span> (!min_heap.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; min_heap.<span class="built_in">top</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        min_heap.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Min-heap contents (from lowest to highest priority):</span><br><span class="line">25 30 40 100 </span><br></pre></td></tr></table></figure><h4 id="如何用于自定义数据类型-Custom-Data-Types"><a href="#如何用于自定义数据类型-Custom-Data-Types" class="headerlink" title="如何用于自定义数据类型 (Custom Data Types)"></a>如何用于自定义数据类型 (Custom Data Types)</h4><p>假设我们有一个 <code>Task</code> 结构，我们希望优先级高的 <code>Task</code> 先被处理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Task</span> &#123;</span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="type">int</span> priority;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>有三种主流方法可以实现：</p><p><strong>方法一：重载 <code>operator&lt;</code> (最简单)</strong><br>这是最直接的方法。因为默认比较器 <code>std::less</code> 使用 <code>operator&lt;</code>，我们只需为 <code>Task</code> 重载它即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Task</span> &#123;</span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="type">int</span> priority;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载 &lt; 操作符，priority 小的反而 &quot;小于&quot;（优先级更高）</span></span><br><span class="line">    <span class="comment">// 为了构建一个以 priority 值为标准的最大堆</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Task&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="comment">// 如果 this-&gt;priority &lt; other.priority，返回 true</span></span><br><span class="line">        <span class="comment">// 这意味着 other 的优先级更高，符合最大堆的定义</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;priority &lt; other.priority;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::priority_queue&lt;Task&gt; task_queue; <span class="comment">// 使用默认模板参数</span></span><br><span class="line"></span><br><span class="line">    task_queue.<span class="built_in">push</span>(&#123;<span class="string">&quot;Fix bug&quot;</span>, <span class="number">100</span>&#125;);</span><br><span class="line">    task_queue.<span class="built_in">push</span>(&#123;<span class="string">&quot;Write documentation&quot;</span>, <span class="number">20</span>&#125;);</span><br><span class="line">    task_queue.<span class="built_in">push</span>(&#123;<span class="string">&quot;Release new version&quot;</span>, <span class="number">999</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!task_queue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; task_queue.<span class="built_in">top</span>().name &lt;&lt; <span class="string">&quot; (Priority: &quot;</span> &lt;&lt; task_queue.<span class="built_in">top</span>().priority &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        task_queue.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出 (priority 最高的先出):</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Release new version (Priority: 999)</span><br><span class="line">Fix bug (Priority: 100)</span><br><span class="line">Write documentation (Priority: 20)</span><br></pre></td></tr></table></figure><p><strong>方法二：提供自定义比较器 (Functor) (最灵活)</strong><br>当你不能或不想修改 <code>Task</code> 结构体，或者需要根据不同场景使用不同的排序规则时，此方法是最佳选择。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Task</span> &#123;</span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="type">int</span> priority;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义比较器结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CompareTask</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Task&amp; a, <span class="type">const</span> Task&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 返回 true 表示 a 的优先级比 b 低</span></span><br><span class="line">        <span class="comment">// 我们希望 priority 大的优先级高，所以当 a.priority &lt; b.priority 时返回 true</span></span><br><span class="line">        <span class="keyword">return</span> a.priority &lt; b.priority;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::priority_queue&lt;Task, std::vector&lt;Task&gt;, CompareTask&gt; task_queue;</span><br><span class="line"></span><br><span class="line">    task_queue.<span class="built_in">push</span>(&#123;<span class="string">&quot;Fix bug&quot;</span>, <span class="number">100</span>&#125;);</span><br><span class="line">    task_queue.<span class="built_in">push</span>(&#123;<span class="string">&quot;Write documentation&quot;</span>, <span class="number">20</span>&#125;);</span><br><span class="line">    task_queue.<span class="built_in">push</span>(&#123;<span class="string">&quot;Release new version&quot;</span>, <span class="number">999</span>&#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... (输出同上)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你想要一个<strong>最小堆</strong>（priority 值最小的优先级最高），只需改变比较器的逻辑：<br><code>return a.priority &gt; b.priority;</code></p><p><strong>方法三：使用 Lambda 表达式 (C++11)</strong><br>这是一种现代且简洁的方式，尤其适用于局部定义的比较逻辑。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Task</span> &#123;</span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="type">int</span> priority;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> compare = [](<span class="type">const</span> Task&amp; a, <span class="type">const</span> Task&amp; b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a.priority &lt; b.priority;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 decltype 获取 lambda 的类型</span></span><br><span class="line">    std::priority_queue&lt;Task, std::vector&lt;Task&gt;, <span class="keyword">decltype</span>(compare)&gt; <span class="built_in">task_queue</span>(compare);</span><br><span class="line"></span><br><span class="line">    task_queue.<span class="built_in">push</span>(&#123;<span class="string">&quot;Fix bug&quot;</span>, <span class="number">100</span>&#125;);</span><br><span class="line">    task_queue.<span class="built_in">push</span>(&#123;<span class="string">&quot;Write documentation&quot;</span>, <span class="number">20</span>&#125;);</span><br><span class="line">    task_queue.<span class="built_in">push</span>(&#123;<span class="string">&quot;Release new version&quot;</span>, <span class="number">999</span>&#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... (输出同上)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：使用 Lambda 时，通常需要将 Lambda 对象实例传递给 <code>priority_queue</code> 的构造函数。</p><hr><h3 id="5-性能分析"><a href="#5-性能分析" class="headerlink" title="5. 性能分析"></a>5. 性能分析</h3><p><code>priority_queue</code> 的性能非常出色，这得益于其底层的堆结构。</p><table><thead><tr><th align="left">操作</th><th align="left">时间复杂度</th></tr></thead><tbody><tr><td align="left"><strong><code>push()</code></strong></td><td align="left"><strong>O(log N)</strong></td></tr><tr><td align="left"><strong><code>pop()</code></strong></td><td align="left"><strong>O(log N)</strong></td></tr><tr><td align="left"><strong><code>top()</code></strong></td><td align="left"><strong>O(1)</strong></td></tr></tbody></table><p>其中 N 是队列中元素的数量。</p><ul><li><code>push()</code>：插入新元素到末尾，然后向上调整以维持堆属性，路径长度为 O(log N)。</li><li><code>pop()</code>：将末尾元素移到堆顶，然后向下调整以恢复堆属性，路径长度为 O(log N)。</li><li><code>top()</code>：访问堆顶元素是常数时间操作。</li></ul><hr><h3 id="6-综合示例：解决-Top-K-问题"><a href="#6-综合示例：解决-Top-K-问题" class="headerlink" title="6. 综合示例：解决 Top K 问题"></a>6. 综合示例：解决 Top K 问题</h3><p><strong>问题</strong>：在一个非常大的整数数组中，找到 K 个最大的元素。</p><p>如果对整个数组排序，时间复杂度是 O(N log N)。使用 <code>priority_queue</code> 可以更高效地解决，时间复杂度为 O(N log K)。</p><p><strong>思路</strong>：</p><ol><li>维护一个大小为 K 的<strong>最小堆</strong>。</li><li>遍历数组，依次处理每个元素：<ul><li>如果堆的大小小于 K，直接将元素压入堆。</li><li>如果堆的大小等于 K，将当前元素与堆顶元素（即堆中最小的元素）比较。</li><li>如果当前元素比堆顶元素大，则弹出堆顶，并将当前元素压入。</li></ul></li><li>遍历结束后，堆中剩下的 K 个元素就是整个数组中最大的 K 个元素。</li></ol><p><strong>代码实现：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">findTopK</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k &lt;= <span class="number">0</span> || k &gt; nums.<span class="built_in">size</span>()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    std::priority_queue&lt;<span class="type">int</span>, std::vector&lt;<span class="type">int</span>&gt;, std::greater&lt;<span class="type">int</span>&gt;&gt; min_heap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (min_heap.<span class="built_in">size</span>() &lt; k) &#123;</span><br><span class="line">            min_heap.<span class="built_in">push</span>(num);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num &gt; min_heap.<span class="built_in">top</span>()) &#123;</span><br><span class="line">            min_heap.<span class="built_in">pop</span>();</span><br><span class="line">            min_heap.<span class="built_in">push</span>(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">    <span class="keyword">while</span> (!min_heap.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        result.<span class="built_in">push_back</span>(min_heap.<span class="built_in">top</span>());</span><br><span class="line">        min_heap.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 结果默认从小到大，如果需要从大到小，可以反转</span></span><br><span class="line">    std::<span class="built_in">reverse</span>(result.<span class="built_in">begin</span>(), result.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; data = &#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">3</span>;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; topK = <span class="built_in">findTopK</span>(data, k);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The &quot;</span> &lt;&lt; k &lt;&lt; <span class="string">&quot; largest elements are: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> n : topK) &#123;</span><br><span class="line">        std::cout &lt;&lt; n &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The 3 largest elements are: 9 8 7 </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CPP学习笔记—unordered_map</title>
      <link href="/2025/09/19/CPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94unordered-map/"/>
      <url>/2025/09/19/CPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94unordered-map/</url>
      
        <content type="html"><![CDATA[<h3 id="1-unordered-map-是什么？"><a href="#1-unordered-map-是什么？" class="headerlink" title="1. unordered_map 是什么？"></a>1. <code>unordered_map</code> 是什么？</h3><p><code>std::unordered_map</code> 是 C++ 标准模板库（STL）中的一个关联容器，它存储了由“键（Key）”和“值（Value）”组成的元素对（<code>std::pair&lt;const Key, Value&gt;</code>）。它的核心特点是：</p><ul><li><strong>无序性</strong>：元素在容器内的存储顺序是无序的，遍历 <code>unordered_map</code> 时，得到的元素顺序与插入顺序无关，并且在不同编译环境下可能不同。</li><li><strong>基于哈希表</strong>：其内部实现是一个哈希表（Hash Table）。</li><li><strong>高效查询</strong>：由于使用了哈希表，它提供了非常快的平均时间复杂度的操作：<ul><li>插入、删除、查找：<strong>平均 O(1)</strong></li><li>最坏情况：<strong>O(N)</strong>，其中 N 是容器中元素的数量（当发生严重的哈希冲突时）。</li></ul></li></ul><h4 id="核心概念：哈希表"><a href="#核心概念：哈希表" class="headerlink" title="核心概念：哈希表"></a>核心概念：哈希表</h4><p>为了理解 <code>unordered_map</code>，需要了解哈希表的工作原理：</p><ol><li><strong>哈希函数 (Hash Function)</strong>：当插入一个键值对时，<code>unordered_map</code> 会使用一个哈希函数将“键”转换成一个整数，这个整数被称为哈希值（Hash Code）。</li><li><strong>桶 (Bucket)</strong>：<code>unordered_map</code> 内部维护一个数组，这个数组被称为“桶”。哈希值经过处理后会映射到其中一个桶的索引上。</li><li><strong>存储</strong>：该键值对就被存放在这个索引对应的桶中。</li><li><strong>哈希冲突 (Collision)</strong>：如果两个不同的键经过哈希函数计算后得到了相同的桶索引，就发生了“哈希冲突”。<code>unordered_map</code> 通常使用<strong>拉链法 (Chaining)</strong> 解决冲突，即在每个桶中维护一个链表（或其他数据结构），所有映射到该桶的元素都存储在这个链表中。</li></ol><h4 id="与-std-map-的关键区别"><a href="#与-std-map-的关键区别" class="headerlink" title="与 std::map 的关键区别"></a>与 <code>std::map</code> 的关键区别</h4><table><thead><tr><th align="left">特性</th><th align="left"><code>std::unordered_map</code></th><th align="left"><code>std::map</code></th></tr></thead><tbody><tr><td align="left"><strong>底层实现</strong></td><td align="left">哈希表 (Hash Table)</td><td align="left">红黑树 (Red-Black Tree)</td></tr><tr><td align="left"><strong>元素顺序</strong></td><td align="left">无序</td><td align="left">按键自动排序 (升序)</td></tr><tr><td align="left"><strong>查找复杂度</strong></td><td align="left">平均 O(1)，最坏 O(N)</td><td align="left">严格 O(log N)</td></tr><tr><td align="left"><strong>插入&#x2F;删除复杂度</strong></td><td align="left">平均 O(1)，最坏 O(N)</td><td align="left">严格 O(log N)</td></tr><tr><td align="left"><strong>对键的要求</strong></td><td align="left">必须可哈希 (提供 <code>std::hash</code>) 且可比较相等 (<code>operator==</code>)</td><td align="left">必须可比较大小 (<code>operator&lt;</code>)</td></tr><tr><td align="left"><strong>内存开销</strong></td><td align="left">通常更高，因为需要维护桶数组</td><td align="left">相对较低</td></tr><tr><td align="left"><strong>适用场景</strong></td><td align="left">追求极致的查找、插入、删除性能，且不关心元素顺序</td><td align="left">需要按键排序或进行范围查找 (如查找所有大于某个值的键)</td></tr></tbody></table><hr><h3 id="2-何时使用-unordered-map？"><a href="#2-何时使用-unordered-map？" class="headerlink" title="2. 何时使用 unordered_map？"></a>2. 何时使用 <code>unordered_map</code>？</h3><p><strong>优先选择 <code>unordered_map</code></strong>，除非有以下需求：</p><ul><li>需要对键进行排序。</li><li>需要根据键进行范围查找（例如，找到所有在 ‘a’ 和 ‘f’ 之间的键）。</li><li>性能瓶颈在于最坏情况，无法接受偶尔 O(N) 的操作延迟（例如在硬实时系统中）。</li></ul><p>在绝大多数场景下，<code>unordered_map</code> 的平均 O(1) 性能使其成为构建字典、缓存、频率计数等功能的首选。</p><hr><h3 id="3-基本用法"><a href="#3-基本用法" class="headerlink" title="3. 基本用法"></a>3. 基本用法</h3><h4 id="包含头文件和声明"><a href="#包含头文件和声明" class="headerlink" title="包含头文件和声明"></a>包含头文件和声明</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个键为 string，值为 int 的 unordered_map</span></span><br><span class="line">std::unordered_map&lt;std::string, <span class="type">int</span>&gt; word_counts;</span><br></pre></td></tr></table></figure><h4 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h4><p>有多种插入方式：</p><p><strong>1. 使用 <code>operator[]</code></strong><br>这是最简单直观的方式。如果键已存在，则更新其值；如果不存在，则创建新元素并进行值初始化（对于 <code>int</code> 就是 0），然后再赋新值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">word_counts[<span class="string">&quot;apple&quot;</span>] = <span class="number">5</span>;      <span class="comment">// 插入或更新</span></span><br><span class="line">word_counts[<span class="string">&quot;banana&quot;</span>] = <span class="number">2</span>;</span><br><span class="line">std::cout &lt;&lt; word_counts[<span class="string">&quot;cherry&quot;</span>] &lt;&lt; std::endl; <span class="comment">// &quot;cherry&quot; 不存在，会先创建 word_counts[&quot;cherry&quot;]=0，然后输出 0</span></span><br></pre></td></tr></table></figure><p><strong>2. 使用 <code>insert()</code></strong><br><code>insert()</code> 更为灵活，它返回一个 <code>std::pair&lt;iterator, bool&gt;</code>。<code>bool</code> 值为 <code>true</code> 表示插入成功（键之前不存在），为 <code>false</code> 表示插入失败（键已存在）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 std::make_pair</span></span><br><span class="line"><span class="keyword">auto</span> result1 = word_counts.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(<span class="string">&quot;apple&quot;</span>, <span class="number">10</span>));</span><br><span class="line"><span class="keyword">if</span> (!result<span class="number">1.</span>second) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;&#x27;apple&#x27; already exists. Value: &quot;</span> &lt;&lt; result<span class="number">1.f</span>irst-&gt;second &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 C++11 的列表初始化</span></span><br><span class="line"><span class="keyword">auto</span> result2 = word_counts.<span class="built_in">insert</span>(&#123;<span class="string">&quot;orange&quot;</span>, <span class="number">3</span>&#125;);</span><br><span class="line"><span class="keyword">if</span> (result<span class="number">2.</span>second) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;&#x27;orange&#x27; inserted successfully.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3. 使用 <code>emplace()</code> (C++11, 推荐)</strong><br><code>emplace()</code> 可以就地构造元素，避免了创建临时对象，效率更高。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接在容器内用 &quot;grape&quot; 和 7 构造键值对</span></span><br><span class="line">word_counts.<span class="built_in">emplace</span>(<span class="string">&quot;grape&quot;</span>, <span class="number">7</span>);</span><br></pre></td></tr></table></figure><h4 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h4><p><strong>1. 使用 <code>operator[]</code></strong><br>简单直接，但有风险：如果键不存在，它会自动插入一个默认构造的值！这可能不是想要的行为。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; <span class="string">&quot;Apples: &quot;</span> &lt;&lt; word_counts[<span class="string">&quot;apple&quot;</span>] &lt;&lt; std::endl; <span class="comment">// OK</span></span><br><span class="line"><span class="comment">// std::cout &lt;&lt; word_counts[&quot;pear&quot;] &lt;&lt; std::endl; // 危险！如果 &quot;pear&quot; 不存在，会创建一个新条目 word_counts[&quot;pear&quot;] = 0</span></span><br></pre></td></tr></table></figure><p><strong>2. 使用 <code>at()</code></strong><br>更安全的方式。如果键存在，返回其值的引用；如果不存在，会抛出 <code>std::out_of_range</code> 异常。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Bananas: &quot;</span> &lt;&lt; word_counts.<span class="built_in">at</span>(<span class="string">&quot;banana&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Pears: &quot;</span> &lt;&lt; word_counts.<span class="built_in">at</span>(<span class="string">&quot;pear&quot;</span>) &lt;&lt; std::endl; <span class="comment">// 这行会抛出异常</span></span><br><span class="line">&#125; <span class="built_in">catch</span> (<span class="type">const</span> std::out_of_range&amp; e) &#123;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;Error: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3. 使用 <code>find()</code> (最常用)</strong><br>这是最标准的“检查并访问”模式。<code>find()</code> 返回一个指向元素的迭代器，如果键不存在，则返回 <code>end()</code> 迭代器。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> it = word_counts.<span class="built_in">find</span>(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (it != word_counts.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="comment">// 找到了</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Found &#x27;apple&#x27; with value: &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// it-&gt;first 是键 &quot;apple&quot;, it-&gt;second 是值 5</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 没找到</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;&#x27;apple&#x27; not found.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h4><p><strong>1. 按键删除 <code>erase(key)</code></strong><br>返回被删除元素的数量（对于 <code>unordered_map</code> 总是 0 或 1）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> num_erased = word_counts.<span class="built_in">erase</span>(<span class="string">&quot;banana&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (num_erased &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;&#x27;banana&#x27; was erased.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. 按迭代器删除 <code>erase(iterator)</code></strong><br>如果已经有了一个有效的迭代器（例如从 <code>find()</code> 返回的），用它来删除效率更高。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> it_grape = word_counts.<span class="built_in">find</span>(<span class="string">&quot;grape&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (it_grape != word_counts.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    word_counts.<span class="built_in">erase</span>(it_grape);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;&#x27;grape&#x27; was erased using an iterator.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="检查存在性"><a href="#检查存在性" class="headerlink" title="检查存在性"></a>检查存在性</h4><p><strong>1. <code>find()</code> !&#x3D; <code>end()</code> (通用)</strong><br>这是最传统、最通用的方法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (word_counts.<span class="built_in">find</span>(<span class="string">&quot;orange&quot;</span>) != word_counts.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="comment">// 存在</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. <code>count(key)</code></strong><br>由于 <code>unordered_map</code> 的键是唯一的，<code>count()</code> 只会返回 0 或 1，可以直观地用于判断。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (word_counts.<span class="built_in">count</span>(<span class="string">&quot;orange&quot;</span>)) &#123; <span class="comment">// count(&quot;orange&quot;) 返回 1，等效于 true</span></span><br><span class="line">    <span class="comment">// 存在</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3. <code>contains(key)</code> (C++20)</strong><br>C++20 引入了 <code>contains()</code> 成员函数，代码更简洁、意图更明确。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果编译器支持 C++20</span></span><br><span class="line"><span class="keyword">if</span> (word_counts.<span class="built_in">contains</span>(<span class="string">&quot;orange&quot;</span>)) &#123;</span><br><span class="line">    <span class="comment">// 存在</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><p><strong>1. 使用 C++11 范围 <code>for</code> 循环 (推荐)</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; <span class="string">&quot;\n--- Current Map Contents ---&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pair : word_counts) &#123;</span><br><span class="line">    std::cout &lt;&lt; pair.first &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; pair.second &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 注意：输出顺序是不确定的！</span></span><br></pre></td></tr></table></figure><p><strong>2. 使用迭代器</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = word_counts.<span class="built_in">begin</span>(); it != word_counts.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">    std::cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="获取大小和清空"><a href="#获取大小和清空" class="headerlink" title="获取大小和清空"></a>获取大小和清空</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; <span class="string">&quot;Map size: &quot;</span> &lt;&lt; word_counts.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">if</span> (!word_counts.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    word_counts.<span class="built_in">clear</span>(); <span class="comment">// 删除所有元素</span></span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Map size after clear: &quot;</span> &lt;&lt; word_counts.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><hr><h3 id="4-高级主题：自定义类型作为键-Key"><a href="#4-高级主题：自定义类型作为键-Key" class="headerlink" title="4. 高级主题：自定义类型作为键 (Key)"></a>4. 高级主题：自定义类型作为键 (Key)</h3><p>如果想用自定义的 <code>struct</code> 或 <code>class</code> 作为键，必须告诉 <code>unordered_map</code> 两件事：</p><ol><li><strong>如何判断两个键相等？</strong> -&gt; 通过重载 <code>operator==</code>。</li><li><strong>如何为键生成哈希值？</strong> -&gt; 通过特化 <code>std::hash</code> 模板。</li></ol><p><strong>示例：使用 <code>struct Student</code> 作为键</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    std::string first_name;</span><br><span class="line">    std::string last_name;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 重载 operator==</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Student&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> first_name == other.first_name &amp;&amp;</span><br><span class="line">               last_name == other.last_name &amp;&amp;</span><br><span class="line">               id == other.id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 特化 std::hash</span></span><br><span class="line"><span class="comment">// 必须在 std 命名空间内</span></span><br><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;&gt;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">hash</span>&lt;Student&gt; &#123;</span><br><span class="line">        <span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Student&amp; s)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 使用标准库为 string 和 int 提供的哈希函数</span></span><br><span class="line">            <span class="comment">// 将多个哈希值组合起来，一种常见的简单方法是使用异或(^)</span></span><br><span class="line">            <span class="type">size_t</span> h1 = std::hash&lt;std::string&gt;&#123;&#125;(s.first_name);</span><br><span class="line">            <span class="type">size_t</span> h2 = std::hash&lt;std::string&gt;&#123;&#125;(s.last_name);</span><br><span class="line">            <span class="type">size_t</span> h3 = std::hash&lt;<span class="type">int</span>&gt;&#123;&#125;(s.id);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 简单的组合方式，更复杂的组合可以减少冲突</span></span><br><span class="line">            <span class="keyword">return</span> h1 ^ (h2 &lt;&lt; <span class="number">1</span>) ^ (h3 &lt;&lt; <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::unordered_map&lt;Student, <span class="type">double</span>&gt; student_grades;</span><br><span class="line"></span><br><span class="line">    Student alice = &#123;<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Wonderland&quot;</span>, <span class="number">101</span>&#125;;</span><br><span class="line">    student_grades[alice] = <span class="number">95.5</span>;</span><br><span class="line"></span><br><span class="line">    Student bob = &#123;<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Builder&quot;</span>, <span class="number">102</span>&#125;;</span><br><span class="line">    student_grades.<span class="built_in">emplace</span>(bob, <span class="number">88.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找 Alice</span></span><br><span class="line">    <span class="keyword">auto</span> it = student_grades.<span class="built_in">find</span>(alice);</span><br><span class="line">    <span class="keyword">if</span> (it != student_grades.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; it-&gt;first.first_name &lt;&lt; <span class="string">&quot;&#x27;s grade: &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>关键点</strong>：当 <code>find</code> 或 <code>insert</code> 一个 <code>Student</code> 对象时，<code>unordered_map</code> 首先调用 <code>std::hash&lt;Student&gt;</code> 计算其哈希值，找到对应的桶。如果桶中有多个元素（发生冲突），它会再使用 <code>operator==</code> 来精确匹配提供的 <code>Student</code> 对象。</p><hr><h3 id="5-性能考量与调优"><a href="#5-性能考量与调优" class="headerlink" title="5. 性能考量与调优"></a>5. 性能考量与调优</h3><h4 id="负载因子-Load-Factor"><a href="#负载因子-Load-Factor" class="headerlink" title="负载因子 (Load Factor)"></a>负载因子 (Load Factor)</h4><ul><li><strong>定义</strong>：<code>负载因子 = 容器中的元素数 / 桶数</code> (<code>size() / bucket_count()</code>)。</li><li><strong>意义</strong>：它衡量了哈希表的“拥挤”程度。负载因子越高，哈希冲突的概率越大，性能越可能下降。</li><li><strong>自动调整</strong>：当负载因子超过一个阈值（默认为 1.0），<code>unordered_map</code> 会自动进行<strong>重哈希 (rehash)</strong>：它会创建一个更大的桶数组，并把所有现有元素重新计算哈希值并放入新桶中。这是一个非常耗时的 O(N) 操作。</li></ul><p>可以通过以下函数来管理它：</p><ul><li><code>load_factor()</code>: 获取当前负载因子。</li><li><code>max_load_factor()</code>: 获取或设置触发重哈希的负载因子阈值。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将阈值设为 0.75，减少冲突，但会更频繁地重哈希</span></span><br><span class="line">word_counts.<span class="built_in">max_load_factor</span>(<span class="number">0.75f</span>);</span><br></pre></td></tr></table></figure><h4 id="哈希冲突-Hash-Collision"><a href="#哈希冲突-Hash-Collision" class="headerlink" title="哈希冲突 (Hash Collision)"></a>哈希冲突 (Hash Collision)</h4><p>选择一个好的哈希函数至关重要。一个好的哈希函数应该让键尽可能均匀地分布到所有桶中，以减少冲突。对于自定义类型，组合哈希值时要避免简单的加法，因为像 <code>{a, b}</code> 和 <code>{b, a}</code> 这样的组合会产生相同的哈希值。使用位移和异或是更稳妥的方式。</p><h4 id="桶-Bucket-接口"><a href="#桶-Bucket-接口" class="headerlink" title="桶 (Bucket) 接口"></a>桶 (Bucket) 接口</h4><p><code>unordered_map</code> 提供了一些接口用来观察其内部状态：</p><ul><li><code>bucket_count()</code>: 获取桶的总数。</li><li><code>bucket_size(n)</code>: 获取第 <code>n</code> 个桶中的元素数量。</li><li><code>bucket(key)</code>: 获取某个键所在的桶的索引。</li></ul><p>这些接口主要用于调试和性能分析。</p><h4 id="预分配空间-reserve"><a href="#预分配空间-reserve" class="headerlink" title="预分配空间 (reserve)"></a>预分配空间 (<code>reserve</code>)</h4><p>如果预先知道大概要存储多少个元素，使用 <code>reserve()</code> 可以避免多次耗时的自动重哈希过程。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设我们知道要存储约 1000 个单词</span></span><br><span class="line">std::unordered_map&lt;std::string, <span class="type">int</span>&gt; large_word_counts;</span><br><span class="line">large_word_counts.<span class="built_in">reserve</span>(<span class="number">1000</span>); <span class="comment">// 分配足够容纳 1000 个元素的桶</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i) &#123;</span><br><span class="line">    <span class="comment">// 插入操作将不会触发重哈希</span></span><br><span class="line">    large_word_counts.<span class="built_in">emplace</span>(<span class="string">&quot;word&quot;</span> + std::<span class="built_in">to_string</span>(i), i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="6-完整的综合示例"><a href="#6-完整的综合示例" class="headerlink" title="6. 完整的综合示例"></a>6. 完整的综合示例</h3><p><strong>任务：统计一篇文章中每个单词出现的次数。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span> <span class="comment">// for std::transform</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span>    <span class="comment">// for ::tolower</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string text = <span class="string">&quot;Hello world! This is a test. Hello again, world.&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 预处理：转为小写，移除标点</span></span><br><span class="line">    std::<span class="built_in">transform</span>(text.<span class="built_in">begin</span>(), text.<span class="built_in">end</span>(), text.<span class="built_in">begin</span>(), ::tolower);</span><br><span class="line">    std::string punctuation = <span class="string">&quot;!,.?&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : punctuation) &#123;</span><br><span class="line">        text.<span class="built_in">erase</span>(std::<span class="built_in">remove</span>(text.<span class="built_in">begin</span>(), text.<span class="built_in">end</span>(), c), text.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::unordered_map&lt;std::string, <span class="type">int</span>&gt; word_freq;</span><br><span class="line">    <span class="function">std::stringstream <span class="title">ss</span><span class="params">(text)</span></span>;</span><br><span class="line">    std::string word;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 operator[] 方便地进行计数</span></span><br><span class="line">    <span class="keyword">while</span> (ss &gt;&gt; word) &#123;</span><br><span class="line">        word_freq[word]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印结果</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Word Frequency Report:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pair : word_freq) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;&#x27;&quot;</span> &lt;&lt; pair.first &lt;&lt; <span class="string">&quot;&#x27;: &quot;</span> &lt;&lt; pair.second &lt;&lt; <span class="string">&quot; times&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查特定单词</span></span><br><span class="line">    std::string search_word = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (word_freq.<span class="built_in">count</span>(search_word)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;\nThe word &#x27;&quot;</span> &lt;&lt; search_word &lt;&lt; <span class="string">&quot;&#x27; appeared &quot;</span> &lt;&lt; word_freq.<span class="built_in">at</span>(search_word) &lt;&lt; <span class="string">&quot; times.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Word Frequency Report:</span><br><span class="line">&#x27;world&#x27;: 2 times</span><br><span class="line">&#x27;again&#x27;: 1 times</span><br><span class="line">&#x27;test&#x27;: 1 times</span><br><span class="line">&#x27;a&#x27;: 1 times</span><br><span class="line">&#x27;is&#x27;: 1 times</span><br><span class="line">&#x27;this&#x27;: 1 times</span><br><span class="line">&#x27;hello&#x27;: 2 times</span><br><span class="line"></span><br><span class="line">The word &#x27;hello&#x27; appeared 2 times.</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法模板</title>
      <link href="/2025/09/15/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"/>
      <url>/2025/09/15/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 返回有向无环图（DAG）的其中一个拓扑序</span></span><br><span class="line"><span class="comment"># 如果图中有环，返回空列表</span></span><br><span class="line"><span class="comment"># 节点编号从 0 到 n-1</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">topologicalSort</span>(<span class="params">n: <span class="built_in">int</span>, edges: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">    g = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    in_deg = [<span class="number">0</span>] * n</span><br><span class="line">    <span class="keyword">for</span> x, y <span class="keyword">in</span> edges:</span><br><span class="line">        g[x].append(y)</span><br><span class="line">        in_deg[y] += <span class="number">1</span>  <span class="comment"># 统计 y 的先修课数量</span></span><br><span class="line"></span><br><span class="line">    topo_order = []</span><br><span class="line">    q = deque(i <span class="keyword">for</span> i, d <span class="keyword">in</span> <span class="built_in">enumerate</span>(in_deg) <span class="keyword">if</span> d == <span class="number">0</span>)  <span class="comment"># 没有先修课，可以直接上</span></span><br><span class="line">    <span class="keyword">while</span> q:</span><br><span class="line">        x = q.popleft()</span><br><span class="line">        topo_order.append(x)</span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> g[x]:</span><br><span class="line">            in_deg[y] -= <span class="number">1</span>  <span class="comment"># 修完 x 后，y 的先修课数量减一</span></span><br><span class="line">            <span class="keyword">if</span> in_deg[y] == <span class="number">0</span>:  <span class="comment"># y 的先修课全部上完</span></span><br><span class="line">                q.append(y)  <span class="comment"># 加入学习队列</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(topo_order) &lt; n:  <span class="comment"># 图中有环</span></span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    <span class="keyword">return</span> topo_order</span><br></pre></td></tr></table></figure><h2 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 返回从起点 start 到每个点的最短路长度 dis，如果节点 x 不可达，则 dis[x] = math.inf</span></span><br><span class="line"><span class="comment"># 要求：没有负数边权</span></span><br><span class="line"><span class="comment"># 时间复杂度 O(n + mlogm)，其中 m 是 edges 的长度。注意堆中有 O(m) 个元素</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Dijkstra</span>(<span class="params">n: <span class="built_in">int</span>, edges: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], start: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">    <span class="comment"># 注：如果节点编号从 1 开始（而不是从 0 开始），可以把 n 加一</span></span><br><span class="line">    g = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]  <span class="comment"># 邻接表</span></span><br><span class="line">    <span class="keyword">for</span> x, y, wt <span class="keyword">in</span> edges:</span><br><span class="line">        g[x].append((y, wt))</span><br><span class="line">        <span class="comment"># g[y].append((x, wt))  # 无向图加上这行</span></span><br><span class="line"></span><br><span class="line">    dis = [inf] * n</span><br><span class="line">    dis[start] = <span class="number">0</span>  <span class="comment"># 起点到自己的距离是 0</span></span><br><span class="line">    parent = [-<span class="number">1</span>] * n</span><br><span class="line">    h = [(<span class="number">0</span>, start)]  <span class="comment"># 堆中保存 (起点到节点 x 的最短路长度，节点 x)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> h:</span><br><span class="line">        dis_x, x = heappop(h)</span><br><span class="line">        <span class="keyword">if</span> dis_x &gt; dis[x]:  <span class="comment"># x 之前出堆过</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">for</span> y, wt <span class="keyword">in</span> g[x]:</span><br><span class="line">            new_dis_y = dis_x + wt</span><br><span class="line">            <span class="keyword">if</span> new_dis_y &lt; dis[y]:</span><br><span class="line">                dis[y] = new_dis_y  <span class="comment"># 更新 x 的邻居的最短路</span></span><br><span class="line">                parent[y] = x</span><br><span class="line">                <span class="comment"># 懒更新堆：只插入数据，不更新堆中数据</span></span><br><span class="line">                <span class="comment"># 相同节点可能有多个不同的 new_dis_y，除了最小的 new_dis_y，其余值都会触发上面的 continue</span></span><br><span class="line">                heappush(h, (new_dis_y, y))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dis, parent</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_path</span>(<span class="params">parent: <span class="type">List</span>[<span class="built_in">int</span>], start: <span class="built_in">int</span>, end: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">    <span class="keyword">if</span> parent[end] == -<span class="number">1</span> <span class="keyword">and</span> end != start: <span class="comment"># end 节点不可达</span></span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    path = []</span><br><span class="line">    curr = end</span><br><span class="line">    <span class="keyword">while</span> curr != -<span class="number">1</span>:</span><br><span class="line">        path.append(curr)</span><br><span class="line">        curr = parent[curr]</span><br><span class="line">    <span class="keyword">return</span> path[::-<span class="number">1</span>] <span class="comment"># 反转路径，得到从 start 到 end 的顺序</span></span><br></pre></td></tr></table></figure><h2 id="Floyed算法"><a href="#Floyed算法" class="headerlink" title="Floyed算法"></a>Floyed算法</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 返回一个二维列表，其中 (i,j) 这一项表示从 i 到 j 的最短路长度</span></span><br><span class="line"><span class="comment"># 如果无法从 i 到 j，则最短路长度为 math.inf</span></span><br><span class="line"><span class="comment"># 允许负数边权</span></span><br><span class="line"><span class="comment"># 如果计算完毕后，存在 i，使得从 i 到 i 的最短路长度小于 0，说明图中有负环</span></span><br><span class="line"><span class="comment"># 节点编号从 0 到 n-1</span></span><br><span class="line"><span class="comment"># 时间复杂度 O(n^3 + m)，其中 m 是 edges 的长度</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Floyd</span>(<span class="params">self, n: <span class="built_in">int</span>, edges: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">    f = [[inf] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    <span class="comment"># path[i][j] 记录从 i 到 j 最短路径上，i 的下一个节点</span></span><br><span class="line">    path = [[-<span class="number">1</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建邻接矩阵</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        f[i][i] = <span class="number">0</span></span><br><span class="line">        path[i][i] = i</span><br><span class="line">    <span class="keyword">for</span> x, y, wt <span class="keyword">in</span> edges:</span><br><span class="line">        f[x][y] = <span class="built_in">min</span>(f[x][y], wt)  <span class="comment"># 如果有重边，取边权最小值</span></span><br><span class="line">        path[x][y] = y</span><br><span class="line">        f[y][x] = <span class="built_in">min</span>(f[y][x], wt)  <span class="comment"># 无向图</span></span><br><span class="line">        path[y][x] = x</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> f[i][k] == inf:  <span class="comment"># 针对稀疏图的优化</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                f[i][j] = <span class="built_in">min</span>(f[i][j], f[i][k] + f[k][j])</span><br><span class="line">                path[i][j] = path[i][k]</span><br><span class="line">    <span class="keyword">return</span> f, path</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_path</span>(<span class="params">path: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], start: <span class="built_in">int</span>, end: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">    <span class="keyword">if</span> path[start][end] == -<span class="number">1</span>: <span class="comment"># 路径不存在</span></span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    </span><br><span class="line">    result_path = [start]</span><br><span class="line">    curr = start</span><br><span class="line">    <span class="keyword">while</span> curr != end:</span><br><span class="line">        curr = path[curr][end]</span><br><span class="line">        result_path.append(curr)</span><br><span class="line">    <span class="keyword">return</span> result_path</span><br></pre></td></tr></table></figure><h2 id="Bellman-Ford算法"><a href="#Bellman-Ford算法" class="headerlink" title="Bellman-Ford算法"></a>Bellman-Ford算法</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 返回从起点 start 到每个点的最短路长度 dis，以及记录最短路径前驱节点的 parent 数组</span></span><br><span class="line"><span class="comment"># 同时返回一个布尔值 has_negative_cycle，表示图中是否存在从 start 可达的负权环</span></span><br><span class="line"><span class="comment"># 如果节点 x 不可达，则 dis[x] = math.inf</span></span><br><span class="line"><span class="comment"># 要求：图中可以有负数边权，但不能有从 start 可达的负权环（若有，最短路无意义）</span></span><br><span class="line"><span class="comment"># 时间复杂度 O(n*m)，其中 m 是 edges 的长度</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">BellmanFord</span>(<span class="params">n: <span class="built_in">int</span>, edges: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], start: <span class="built_in">int</span></span>) -&gt; <span class="built_in">tuple</span>[<span class="type">List</span>[<span class="built_in">int</span>], <span class="type">List</span>[<span class="built_in">int</span>], <span class="built_in">bool</span>]:</span><br><span class="line">    dis = [inf] * n</span><br><span class="line">    dis[start] = <span class="number">0</span></span><br><span class="line">    parent = [-<span class="number">1</span>] * n</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 进行 n-1 轮松弛操作（假设有 n 个节点，节点编号从 0 到 n - 1）</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> u, v, w <span class="keyword">in</span> edges:</span><br><span class="line">            <span class="keyword">if</span> dis[u] != inf <span class="keyword">and</span> dis[u] + w &lt; dis[v]:</span><br><span class="line">                dis[v] = dis[u] + w</span><br><span class="line">                parent[v] = u</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 第 n 轮松弛，用于检测负权环</span></span><br><span class="line">    has_negative_cycle = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">for</span> u, v, w <span class="keyword">in</span> edges:</span><br><span class="line">        <span class="keyword">if</span> dis[u] != inf <span class="keyword">and</span> dis[u] + w &lt; dis[v]:</span><br><span class="line">            has_negative_cycle = <span class="literal">True</span></span><br><span class="line">            <span class="comment"># 在实际应用中，可以标记受负权环影响的节点</span></span><br><span class="line">            <span class="comment"># 例如，将它们的 dis 设为 -inf</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">            </span><br><span class="line">    <span class="keyword">return</span> dis, parent, has_negative_cycle</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据 parent 数组回溯从 start 到 end 的最短路径 (与 Dijkstra 版本相同)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_path</span>(<span class="params">parent: <span class="type">List</span>[<span class="built_in">int</span>], start: <span class="built_in">int</span>, end: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">    <span class="keyword">if</span> parent[end] == -<span class="number">1</span> <span class="keyword">and</span> end != start: <span class="comment"># end 节点不可达</span></span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    path = []</span><br><span class="line">    curr = end</span><br><span class="line">    <span class="keyword">while</span> curr != -<span class="number">1</span>:</span><br><span class="line">        path.append(curr)</span><br><span class="line">        curr = parent[curr]</span><br><span class="line">    <span class="keyword">return</span> path[::-<span class="number">1</span>] <span class="comment"># 反转路径，得到从 start 到 end 的顺序</span></span><br></pre></td></tr></table></figure><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFind</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, n: <span class="built_in">int</span></span>):</span><br><span class="line">        <span class="comment"># 一开始有 n 个集合 &#123;0&#125;, &#123;1&#125;, ..., &#123;n-1&#125;</span></span><br><span class="line">        <span class="comment"># 集合 i 的代表元是自己，大小为 1</span></span><br><span class="line">        <span class="variable language_">self</span>._fa = <span class="built_in">list</span>(<span class="built_in">range</span>(n))  <span class="comment"># 代表元</span></span><br><span class="line">        <span class="variable language_">self</span>._size = [<span class="number">1</span>] * n  <span class="comment"># 集合大小</span></span><br><span class="line">        <span class="variable language_">self</span>.cc = n  <span class="comment"># 连通块个数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 返回 x 所在集合的代表元</span></span><br><span class="line">    <span class="comment"># 同时做路径压缩，也就是把 x 所在集合中的所有元素的 fa 都改成代表元</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 如果 fa[x] == x，则表示 x 是代表元</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>._fa[x] != x:</span><br><span class="line">            <span class="variable language_">self</span>._fa[x] = <span class="variable language_">self</span>.find(<span class="variable language_">self</span>._fa[x])  <span class="comment"># fa 改成代表元</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>._fa[x]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 判断 x 和 y 是否在同一个集合</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_same</span>(<span class="params">self, x: <span class="built_in">int</span>, y: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># 如果 x 的代表元和 y 的代表元相同，那么 x 和 y 就在同一个集合</span></span><br><span class="line">        <span class="comment"># 这就是代表元的作用：用来快速判断两个元素是否在同一个集合</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.find(x) == <span class="variable language_">self</span>.find(y)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 把 from 所在集合合并到 to 所在集合中</span></span><br><span class="line">    <span class="comment"># 返回是否合并成功</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">self, from_: <span class="built_in">int</span>, to: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        x, y = <span class="variable language_">self</span>.find(from_), <span class="variable language_">self</span>.find(to)</span><br><span class="line">        <span class="keyword">if</span> x == y:  <span class="comment"># from 和 to 在同一个集合，不做合并</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="variable language_">self</span>._fa[x] = y  <span class="comment"># 合并集合。修改后就可以认为 from 和 to 在同一个集合了</span></span><br><span class="line">        <span class="variable language_">self</span>._size[y] += <span class="variable language_">self</span>._size[x]  <span class="comment"># 更新集合大小（注意集合大小保存在代表元上）</span></span><br><span class="line">        <span class="comment"># 无需更新 _size[x]，因为我们不用 _size[x] 而是用 _size[find(x)] 获取集合大小，但 find(x) == y，我们不会再访问 _size[x]</span></span><br><span class="line">        <span class="variable language_">self</span>.cc -= <span class="number">1</span>  <span class="comment"># 成功合并，连通块个数减一</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 返回 x 所在集合的大小</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_size</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>._size[<span class="variable language_">self</span>.find(x)]  <span class="comment"># 集合大小保存在代表元上</span></span><br></pre></td></tr></table></figure><h2 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FenwickTree</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    树状数组 (Fenwick Tree / Binary Indexed Tree)</span></span><br><span class="line"><span class="string">    支持单点更新和前缀和查询，时间复杂度均为 O(log n)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, size</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        初始化一个大小为 size 的树状数组。</span></span><br><span class="line"><span class="string">        通常 size 为原数组长度 n。内部数组大小为 n+1，使用 1-based 索引。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.size = size</span><br><span class="line">        <span class="variable language_">self</span>.tree = [<span class="number">0</span>] * (size + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_lowbit</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;返回 x 的二进制表示中最低位的 1 所代表的值&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> x &amp; (-x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">self, index, delta</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        在原数组的 index 位置上增加 delta。</span></span><br><span class="line"><span class="string">        index 是 1-based。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">while</span> index &lt;= <span class="variable language_">self</span>.size:</span><br><span class="line">            <span class="variable language_">self</span>.tree[index] += delta</span><br><span class="line">            index += <span class="variable language_">self</span>._lowbit(index)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">query</span>(<span class="params">self, index</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        查询原数组前缀 [1, index] 的和。</span></span><br><span class="line"><span class="string">        index 是 1-based。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> index &gt; <span class="number">0</span>:</span><br><span class="line">            result += <span class="variable language_">self</span>.tree[index]</span><br><span class="line">            index -= <span class="variable language_">self</span>._lowbit(index)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">query_range</span>(<span class="params">self, left, right</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        查询原数组区间 [left, right] 的和。</span></span><br><span class="line"><span class="string">        left 和 right 都是 1-based。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> left &gt; right:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.query(right) - <span class="variable language_">self</span>.query(left - <span class="number">1</span>)</span><br></pre></td></tr></table></figure><h2 id="C-中实现动态多态"><a href="#C-中实现动态多态" class="headerlink" title="C++中实现动态多态"></a>C++中实现动态多态</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 定义基类 (接口)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 声明一个虚函数以实现多态</span></span><br><span class="line">    <span class="comment">// &quot;= 0&quot; 使其成为纯虚函数，从而使 Shape 成为一个抽象基类</span></span><br><span class="line">    <span class="comment">// 这意味着 Shape 类的实例无法被创建</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明一个虚析构函数,</span></span><br><span class="line">    <span class="comment">// 这能确保通过基类指针删除派生类对象时，</span></span><br><span class="line">    <span class="comment">// 能够正确调用派生类的析构函数</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Shape</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Shape destructor called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 定义派生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing a Rectangle.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Rectangle</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Rectangle destructor called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing a Circle.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Circle</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Circle destructor called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Triangle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing a Triangle.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Triangle</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Triangle destructor called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 动态多态</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个用于存放不同形状的容器</span></span><br><span class="line">    <span class="comment">// 使用智能指针 (std::unique_ptr) 是现代C++的推荐做法，</span></span><br><span class="line">    <span class="comment">// 它可以自动管理内存</span></span><br><span class="line">    std::vector&lt;std::unique_ptr&lt;Shape&gt;&gt; shapes;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建不同形状的对象并将其添加到容器中</span></span><br><span class="line">    shapes.<span class="built_in">push_back</span>(std::<span class="built_in">make_unique</span>&lt;Rectangle&gt;());</span><br><span class="line">    shapes.<span class="built_in">push_back</span>(std::<span class="built_in">make_unique</span>&lt;Circle&gt;());</span><br><span class="line">    shapes.<span class="built_in">push_back</span>(std::<span class="built_in">make_unique</span>&lt;Triangle&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历容器并通过基类指针调用 draw() 方法</span></span><br><span class="line">    <span class="comment">// 在运行时，将根据对象的实际类型调用相应的 draw() 方法</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;--- Calling draw() on different shapes ---&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; shape : shapes) &#123;</span><br><span class="line">        shape-&gt;<span class="built_in">draw</span>(); <span class="comment">// 此处展示了动态多态</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n--- Destructors will be called automatically ---&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 当 main 函数结束时，智能指针会自动释放内存，</span></span><br><span class="line">    <span class="comment">// 并且由于基类的析构函数是虚函数，会正确调用每个派生类的析构函数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-多线程"><a href="#C-多线程" class="headerlink" title="C++多线程"></a>C++多线程</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span> <span class="comment">// 用于 std::chrono::milliseconds</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟共享数据缓冲区</span></span><br><span class="line">std::queue&lt;<span class="type">int</span>&gt; g_dataQueue;</span><br><span class="line"><span class="comment">// 用于保护共享数据的互斥锁</span></span><br><span class="line">std::mutex g_mutex;</span><br><span class="line"><span class="comment">// 用于线程间同步的条件变量</span></span><br><span class="line">std::condition_variable g_conditionVariable;</span><br><span class="line"><span class="comment">// 标志，用于通知消费者没有更多数据了</span></span><br><span class="line"><span class="type">bool</span> g_finished = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者线程函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer</span><span class="params">(<span class="type">int</span> numItems)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numItems; ++i) &#123;</span><br><span class="line">        <span class="comment">// 模拟生产一个数据项需要一些时间</span></span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>));</span><br><span class="line">        </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 使用 std::lock_guard 自动管理互斥锁的加锁与解锁</span></span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(g_mutex)</span></span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 将生产的数据放入队列</span></span><br><span class="line">            <span class="type">int</span> item = i + <span class="number">1</span>;</span><br><span class="line">            g_dataQueue.<span class="built_in">push</span>(item);</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Producer produced: &quot;</span> &lt;&lt; item &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="comment">// lock_guard 在此处超出作用域，自动释放锁</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 通知一个等待的消费者线程数据已准备好</span></span><br><span class="line">        g_conditionVariable.<span class="built_in">notify_one</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生产完成后，设置标志并通知所有消费者</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(g_mutex)</span></span>;</span><br><span class="line">        g_finished = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    g_conditionVariable.<span class="built_in">notify_all</span>(); <span class="comment">// 唤醒所有可能在等待的消费者</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者线程函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="type">int</span> item;</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 使用 std::unique_lock，因为它能与条件变量更好地配合</span></span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(g_mutex)</span></span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 等待，直到队列不为空或生产已结束</span></span><br><span class="line">            <span class="comment">// wait方法会自动释放锁，并让线程休眠。</span></span><br><span class="line">            <span class="comment">// 当被唤醒时，它会重新获取锁并检查lambda表达式（第二个参数）的条件。</span></span><br><span class="line">            <span class="comment">// 如果条件为false，它会再次释放锁并继续休眠。</span></span><br><span class="line">            <span class="comment">// 这种方式可以避免“虚假唤醒”（spurious wakeups）。</span></span><br><span class="line">            g_conditionVariable.<span class="built_in">wait</span>(lock, []&#123;</span><br><span class="line">                <span class="keyword">return</span> !g_dataQueue.<span class="built_in">empty</span>() || g_finished;</span><br><span class="line">            &#125;);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果队列为空且生产已经结束，则消费者可以退出</span></span><br><span class="line">            <span class="keyword">if</span> (g_dataQueue.<span class="built_in">empty</span>() &amp;&amp; g_finished) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 从队列中取出数据</span></span><br><span class="line">            item = g_dataQueue.<span class="built_in">front</span>();</span><br><span class="line">            g_dataQueue.<span class="built_in">pop</span>();</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="comment">// unique_lock 在此处超出作用域，自动释放锁</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理数据（在解锁后进行，以减少锁的持有时间）</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Consumer consumed: &quot;</span> &lt;&lt; item &lt;&lt; std::endl;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">150</span>)); <span class="comment">// 模拟消费</span></span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Consumer finished.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义生产者将要生产的数据量</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> itemsToProduce = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建并启动生产者线程</span></span><br><span class="line">    <span class="function">std::thread <span class="title">producerThread</span><span class="params">(producer, itemsToProduce)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建并启动两个消费者线程</span></span><br><span class="line">    <span class="function">std::thread <span class="title">consumerThread1</span><span class="params">(consumer)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">consumerThread2</span><span class="params">(consumer)</span></span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Main thread: Starting producer and consumers.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待所有线程执行完毕</span></span><br><span class="line">    <span class="comment">// join() 会阻塞主线程，直到目标线程执行结束</span></span><br><span class="line">    producerThread.<span class="built_in">join</span>();</span><br><span class="line">    consumerThread<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    consumerThread<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Main thread: All threads have finished.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-多线程死锁"><a href="#C-多线程死锁" class="headerlink" title="C++多线程死锁"></a>C++多线程死锁</h2><p>死锁（Deadlock）是指两个或多个线程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法继续执行。</p><p>这个例子将创建两个线程和两个互斥锁（mutex）。每个线程都需要获取这两个锁才能完成工作，但它们会以相反的顺序来尝试获取锁，从而导致死锁。</p><ul><li>线程1: 尝试先锁定 mutex1，再锁定 mutex2。</li><li>线程2: 尝试先锁定 mutex2，再锁定 mutex1。</li></ul><p>当线程1锁定了 mutex1 并准备锁定 mutex2 的同时，线程2可能已经锁定了 mutex2 并正在准备锁定 mutex1。这时，两个线程都会无限期地等待对方释放自己需要的锁，从而形成死锁。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建两个全局互斥锁</span></span><br><span class="line">std::mutex mutex1;</span><br><span class="line">std::mutex mutex2;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程1的执行函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">worker1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Worker 1 started.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 锁定第一个互斥锁</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Worker 1 trying to lock mutex1...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock1</span><span class="params">(mutex1)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Worker 1 acquired mutex1.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 人为地增加一个小的延时，以确保另一个线程有时间运行并锁定mutex2</span></span><br><span class="line">    <span class="comment">// 这使得死锁的发生更加稳定和可复现</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">50</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 尝试锁定第二个互斥锁</span></span><br><span class="line">    <span class="comment">// 此时，worker2可能已经持有了mutex2，导致此行代码阻塞</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Worker 1 trying to lock mutex2...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock2</span><span class="params">(mutex2)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Worker 1 acquired mutex2.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下代码将永远不会被执行</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Worker 1 finished its work.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程2的执行函数（注意锁的顺序与worker1相反）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">worker2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Worker 2 started.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 锁定第一个互斥锁 (与worker1的顺序相反)</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Worker 2 trying to lock mutex2...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock2</span><span class="params">(mutex2)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Worker 2 acquired mutex2.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 同样增加延时，以增加死锁发生的机会</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">50</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 尝试锁定第二个互斥锁</span></span><br><span class="line">    <span class="comment">// 此时，worker1可能已经持有了mutex1，导致此行代码阻塞</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Worker 2 trying to lock mutex1...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock1</span><span class="params">(mutex1)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Worker 2 acquired mutex1.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下代码将永远不会被执行</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Worker 2 finished its work.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Starting deadlock demonstration...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建并启动两个线程</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(worker1)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(worker2)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待两个线程结束。</span></span><br><span class="line">    <span class="comment">// 由于死锁，它们永远不会结束，所以主线程会在这里永久阻塞。</span></span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这行代码将永远不会被执行</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Program finished.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法—树状数组</title>
      <link href="/2025/09/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
      <url>/2025/09/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h3 id="1-树状数组是什么？为什么需要它？"><a href="#1-树状数组是什么？为什么需要它？" class="headerlink" title="1. 树状数组是什么？为什么需要它？"></a>1. 树状数组是什么？为什么需要它？</h3><p>想象一个场景：你有一个数组 <code>a</code>，需要频繁地做两件事：</p><ol><li>修改数组中某个元素的值。</li><li>查询数组中任意一个区间的和（例如，从索引 <code>l</code> 到 <code>r</code> 的所有元素之和）。</li></ol><p>我们可以用一些朴素的方法来解决：</p><ul><li><strong>普通数组</strong>：<ul><li>修改元素：<code>O(1)</code>，非常快。</li><li>查询区间和：<code>O(n)</code>，需要遍历区间，如果查询次数很多，会非常慢。</li></ul></li><li><strong>前缀和数组</strong>：<ul><li>我们预处理一个 <code>preSum</code> 数组，<code>preSum[i] = a[1] + ... + a[i]</code>。</li><li>查询区间和 <code>[l, r]</code>：<code>O(1)</code>，只需计算 <code>preSum[r] - preSum[l-1]</code>，非常快。</li><li>修改元素 <code>a[i]</code>：<code>O(n)</code>，因为 <code>a[i]</code> 的改变会影响到 <code>preSum[i]</code> 及之后的所有元素，你需要更新 <code>preSum[i], preSum[i+1], ..., preSum[n]</code>，非常慢。</li></ul></li></ul><p>可以看到，这两种方法在“修改”和“查询”上都有一个操作是 <code>O(n)</code> 的，无法同时做到高效。</p><p><strong>树状数组 (Fenwick Tree)</strong> 就是为了解决这个问题而生的。它是一种巧妙的数据结构，可以在 <strong><code>O(log n)</code></strong> 的时间复杂度内完成 <strong>单点更新</strong> 和 <strong>前缀和查询</strong>。这使得它在需要频繁进行这两种操作的问题中非常高效。</p><hr><h3 id="2-核心思想与原理"><a href="#2-核心思想与原理" class="headerlink" title="2. 核心思想与原理"></a>2. 核心思想与原理</h3><p>树状数组的核心思想是：<strong>用一个辅助数组 <code>t</code>，让 <code>t[i]</code> 存储原数组 <code>a</code> 中一个特定区间的和</strong>。这个“特定区间”的划分非常精妙，它使得更新和查询都能以类似二分的方式沿着一条“树链”进行，从而保证了 <code>O(log n)</code> 的复杂度。</p><h4 id="lowbit-函数"><a href="#lowbit-函数" class="headerlink" title="lowbit 函数"></a><code>lowbit</code> 函数</h4><p><code>lowbit(x)</code> 是理解树状数组的关键。它的功能是<strong>获取 <code>x</code> 的二进制表示中，最低位的那个 ‘1’ 以及它后面的所有 ‘0’ 构成的数值</strong>。</p><p>例如：</p><ul><li><code>x = 6</code>，二进制是 <code>0110</code>。最低位的 ‘1’ 在第二位，所以 <code>lowbit(6)</code> 的结果是 <code>0010</code>，即十进制的 <code>2</code>。</li><li><code>x = 7</code>，二进制是 <code>0111</code>。最低位的 ‘1’ 在第一位，所以 <code>lowbit(7)</code> 的结果是 <code>0001</code>，即十进制的 <code>1</code>。</li><li><code>x = 8</code>，二进制是 <code>1000</code>。最低位的 ‘1’ 在第四位，所以 <code>lowbit(8)</code> 的结果是 <code>1000</code>，即十进制的 <code>8</code>。</li></ul><p><strong>如何计算 <code>lowbit(x)</code>？</strong><br>一个非常简洁的位运算技巧：<code>lowbit(x) = x &amp; (-x)</code>。<br>（在计算机中，负数以补码形式存储，<code>-x</code> 等于 <code>~x + 1</code>，这个位运算 <code>x &amp; (~x + 1)</code> 恰好能得到上述结果）。</p><h4 id="树状结构"><a href="#树状结构" class="headerlink" title="树状结构"></a>树状结构</h4><p><code>lowbit(x)</code> 定义了 <code>t[x]</code> 所管理的区间长度。具体来说，<strong><code>t[x]</code> 存储的是原数组 <code>a</code> 中 <code>(x - lowbit(x), x]</code> 这个长度为 <code>lowbit(x)</code> 的区间的和</strong>。</p><p>我们以一个大小为 8 的数组为例： </p><ul><li><code>t[1]</code>: <code>lowbit(1)=1</code>. 区间是 <code>(1-1, 1] = (0, 1]</code>. 存储 <code>a[1]</code>.</li><li><code>t[2]</code>: <code>lowbit(2)=2</code>. 区间是 <code>(2-2, 2] = (0, 2]</code>. 存储 <code>a[1] + a[2]</code>.</li><li><code>t[3]</code>: <code>lowbit(3)=1</code>. 区间是 <code>(3-1, 3] = (2, 3]</code>. 存储 <code>a[3]</code>.</li><li><code>t[4]</code>: <code>lowbit(4)=4</code>. 区间是 <code>(4-4, 4] = (0, 4]</code>. 存储 <code>a[1] + a[2] + a[3] + a[4]</code>.</li><li><code>t[5]</code>: <code>lowbit(5)=1</code>. 区间是 <code>(5-1, 5] = (4, 5]</code>. 存储 <code>a[5]</code>.</li><li><code>t[6]</code>: <code>lowbit(6)=2</code>. 区间是 <code>(6-2, 6] = (4, 6]</code>. 存储 <code>a[5] + a[6]</code>.</li><li><code>t[7]</code>: <code>lowbit(7)=1</code>. 区间是 <code>(7-1, 7] = (6, 7]</code>. 存储 <code>a[7]</code>.</li><li><code>t[8]</code>: <code>lowbit(8)=8</code>. 区间是 <code>(8-8, 8] = (0, 8]</code>. 存储 <code>a[1] + ... + a[8]</code>.</li></ul><p>我们可以画出这个结构图，它看起来像一棵树：</p><p><img src="/img_1/17.png" alt="树状数组结构图"></p><p>这张图清晰地展示了 <code>t[i]</code> 的依赖关系。</p><p>通过观察我们可以发现t[x]节点覆盖的长度就是lowbit(x)，并且t[x]节点的父节点为t[x + lowbit(x)]，整棵树的深度为logn + 1，n表示原数组的长度</p><h4 id="单点更新-update-index-delta"><a href="#单点更新-update-index-delta" class="headerlink" title="单点更新 (update(index, delta))"></a>单点更新 (<code>update(index, delta)</code>)</h4><p>当你修改原数组 <code>a[i]</code> 的值（增加 <code>delta</code>）时，你需要更新所有<strong>管辖范围包含 <code>a[i]</code></strong> 的 <code>t</code> 数组元素。</p><p>这些需要被更新的 <code>t</code> 元素形成了一条向上的路径。如何找到下一个要更新的节点（父节点）？<br>规律是：<code>i = i + lowbit(i)</code>。</p><p>例如，更新 <code>a[3]</code>：</p><ol><li>首先更新 <code>t[3]</code>。</li><li>下一个要更新的是 <code>3 + lowbit(3) = 3 + 1 = 4</code>，所以更新 <code>t[4]</code>。</li><li>再下一个是 <code>4 + lowbit(4) = 4 + 4 = 8</code>，所以更新 <code>t[8]</code>。</li><li>再下一个是 <code>8 + lowbit(8) = 8 + 8 = 16</code>，超出范围，停止。<br>所以，更新 <code>a[3]</code> 会影响到 <code>t[3], t[4], t[8]</code>。这个过程的长度是 <code>log n</code> 级别的。</li></ol><p><img src="/img_1/18.png" alt="单点更新操作"></p><h4 id="前缀和查询-query-index"><a href="#前缀和查询-query-index" class="headerlink" title="前缀和查询 (query(index))"></a>前缀和查询 (<code>query(index)</code>)</h4><p>当你查询前缀和 <code>Sum(1, i)</code> 时，你需要把<strong>能拼凑成 <code>[1, i]</code> 区间</strong>的所有 <code>t</code> 元素加起来。</p><p>这些需要被累加的 <code>t</code> 元素形成了一条向下的路径。如何找到下一个要累加的节点？<br>规律是：<code>i = i - lowbit(i)</code>。</p><p>例如，查询前缀和 <code>Sum(1, 7)</code>：</p><ol><li>首先加上 <code>t[7]</code> (管辖 <code>a[7]</code>)。</li><li>下一个要加的是 <code>7 - lowbit(7) = 7 - 1 = 6</code>，所以加上 <code>t[6]</code> (管辖 <code>a[5], a[6]</code>)。</li><li>再下一个是 <code>6 - lowbit(6) = 6 - 2 = 4</code>，所以加上 <code>t[4]</code> (管辖 <code>a[1], a[2], a[3], a[4]</code>)。</li><li>再下一个是 <code>4 - lowbit(4) = 4 - 4 = 0</code>，停止。<br>所以，<code>Sum(1, 7) = t[7] + t[6] + t[4]</code>。这个过程的长度也是 <code>log n</code> 级别的。</li></ol><p><img src="/img_1/19.png" alt="前缀和查询"></p><hr><h3 id="3-Python-代码实现"><a href="#3-Python-代码实现" class="headerlink" title="3. Python 代码实现"></a>3. Python 代码实现</h3><p>为了方便，树状数组的实现通常采用 <strong>1-based</strong> 索引，即数组下标从 1 开始。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FenwickTree</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    树状数组 (Fenwick Tree / Binary Indexed Tree)</span></span><br><span class="line"><span class="string">    支持单点更新和前缀和查询，时间复杂度均为 O(log n)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, size</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        初始化一个大小为 size 的树状数组。</span></span><br><span class="line"><span class="string">        通常 size 为原数组长度 n。内部数组大小为 n+1，使用 1-based 索引。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.size = size</span><br><span class="line">        <span class="variable language_">self</span>.tree = [<span class="number">0</span>] * (size + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_lowbit</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;返回 x 的二进制表示中最低位的 1 所代表的值&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> x &amp; (-x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">self, index, delta</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        在原数组的 index 位置上增加 delta。</span></span><br><span class="line"><span class="string">        index 是 1-based。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">while</span> index &lt;= <span class="variable language_">self</span>.size:</span><br><span class="line">            <span class="variable language_">self</span>.tree[index] += delta</span><br><span class="line">            index += <span class="variable language_">self</span>._lowbit(index)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">query</span>(<span class="params">self, index</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        查询原数组前缀 [1, index] 的和。</span></span><br><span class="line"><span class="string">        index 是 1-based。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> index &gt; <span class="number">0</span>:</span><br><span class="line">            result += <span class="variable language_">self</span>.tree[index]</span><br><span class="line">            index -= <span class="variable language_">self</span>._lowbit(index)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">query_range</span>(<span class="params">self, left, right</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        查询原数组区间 [left, right] 的和。</span></span><br><span class="line"><span class="string">        left 和 right 都是 1-based。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> left &gt; right:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.query(right) - <span class="variable language_">self</span>.query(left - <span class="number">1</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="4-经典应用场景"><a href="#4-经典应用场景" class="headerlink" title="4. 经典应用场景"></a>4. 经典应用场景</h3><h4 id="场景一：单点更新，区间查询-最经典"><a href="#场景一：单点更新，区间查询-最经典" class="headerlink" title="场景一：单点更新，区间查询 (最经典)"></a>场景一：单点更新，区间查询 (最经典)</h4><p><strong>问题描述</strong>：给定一个数组，有两种操作：</p><ol><li><code>update i val</code>: 将数组第 <code>i</code> 个元素的值改为 <code>val</code>。</li><li><code>query l r</code>: 查询区间 <code>[l, r]</code> 的和。</li></ol><p><strong>解法</strong>：<br>直接使用上面的模板。对于 <code>update</code> 操作，由于我们模板中的 <code>update</code> 是增加一个 <code>delta</code>，所以我们需要先知道原值，计算出差值 <code>delta</code>。</p><p><strong>示例代码</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 假设我们有一个初始数组 nums</span></span><br><span class="line">nums = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span>]</span><br><span class="line">n = <span class="built_in">len</span>(nums)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 0. 为了方便，我们创建一个 1-based 的原数组副本</span></span><br><span class="line"><span class="comment">#    在实际应用中，如果只需要相对变化，可以不需要这个</span></span><br><span class="line">original_array = [<span class="number">0</span>] + nums </span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 初始化树状数组</span></span><br><span class="line">ft = FenwickTree(n)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 将初始数组的值填入树状数组</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">    ft.update(i, original_array[i])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 执行查询操作</span></span><br><span class="line"><span class="comment"># 查询区间 [2, 5] 的和 (3 + 5 + 7 + 9)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Sum of range [2, 5]: <span class="subst">&#123;ft.query_range(<span class="number">2</span>, <span class="number">5</span>)&#125;</span>&quot;</span>)  <span class="comment"># 输出 24</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 执行更新操作</span></span><br><span class="line"><span class="comment"># 将第 3 个元素（值为5）更新为 6，即增加 1</span></span><br><span class="line">index_to_update = <span class="number">3</span></span><br><span class="line">new_value = <span class="number">6</span></span><br><span class="line">delta = new_value - original_array[index_to_update]</span><br><span class="line">ft.update(index_to_update, delta)</span><br><span class="line">original_array[index_to_update] = new_value <span class="comment"># 别忘了更新我们的副本</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 再次查询</span></span><br><span class="line"><span class="comment"># 查询区间 [2, 5] 的和 (3 + 6 + 7 + 9)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Sum of range [2, 5] after update: <span class="subst">&#123;ft.query_range(<span class="number">2</span>, <span class="number">5</span>)&#125;</span>&quot;</span>) <span class="comment"># 输出 25</span></span><br></pre></td></tr></table></figure><h4 id="场景二：区间更新，单点查询"><a href="#场景二：区间更新，单点查询" class="headerlink" title="场景二：区间更新，单点查询"></a>场景二：区间更新，单点查询</h4><p><strong>问题描述</strong>：给定一个数组，有两种操作：</p><ol><li><code>update l r val</code>: 将区间 <code>[l, r]</code> 内的每个元素都增加 <code>val</code>。</li><li><code>query i</code>: 查询第 <code>i</code> 个元素的值。</li></ol><p><strong>解法</strong>：<br>这需要一个巧妙的转换：<strong>差分数组</strong>。<br>我们维护原数组 <code>a</code> 的差分数组 <code>D</code>，其中 <code>D[i] = a[i] - a[i-1]</code> (规定 <code>a[0] = 0</code>)。</p><ul><li><p><strong>区间更新的影响</strong>：当我们将 <code>a</code> 的 <code>[l, r]</code> 区间都加上 <code>val</code> 时，差分数组 <code>D</code> 会发生什么变化？</p><ul><li><code>D[l]</code> 变为 <code>(a[l]+val) - a[l-1] = D[l] + val</code>。所以 <code>D[l]</code> 增加了 <code>val</code>。</li><li><code>D[r+1]</code> 变为 <code>a[r+1] - (a[r]+val) = D[r+1] - val</code>。所以 <code>D[r+1]</code> 减少了 <code>val</code>。</li><li>对于 <code>l</code> 和 <code>r+1</code> 之间的 <code>i</code>，<code>D[i]</code> 不变。<br>所以，一个<strong>区间更新</strong> <code>[l, r]</code> 被转换成了<strong>两个单点更新</strong> <code>D[l]</code> 和 <code>D[r+1]</code>。</li></ul></li><li><p><strong>单点查询的计算</strong>：原数组的 <code>a[i]</code> 值等于其差分数组的前缀和。<br><code>a[i] = D[1] + D[2] + ... + D[i]</code>。</p></li></ul><p>综上，我们可以在差分数组 <code>D</code> 上建立一个树状数组，从而实现：</p><ul><li><strong>区间更新</strong> -&gt; <code>O(log n)</code> (两次单点更新)</li><li><strong>单点查询</strong> -&gt; <code>O(log n)</code> (一次前缀和查询)</li></ul><p><strong>示例代码</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 假设初始数组全为 0，大小为 n</span></span><br><span class="line">n = <span class="number">10</span></span><br><span class="line"><span class="comment"># 我们在差分数组上建立树状数组</span></span><br><span class="line"><span class="comment"># 差分数组初始也全为 0</span></span><br><span class="line">diff_ft = FenwickTree(n) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 操作1: 区间 [2, 7] 增加 5</span></span><br><span class="line">l, r, val = <span class="number">2</span>, <span class="number">7</span>, <span class="number">5</span></span><br><span class="line">diff_ft.update(l, val)</span><br><span class="line"><span class="keyword">if</span> r + <span class="number">1</span> &lt;= n:</span><br><span class="line">    diff_ft.update(r + <span class="number">1</span>, -val)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 操作2: 区间 [4, 9] 增加 2</span></span><br><span class="line">l, r, val = <span class="number">4</span>, <span class="number">9</span>, <span class="number">2</span></span><br><span class="line">diff_ft.update(l, val)</span><br><span class="line"><span class="keyword">if</span> r + <span class="number">1</span> &lt;= n:</span><br><span class="line">    diff_ft.update(r + <span class="number">1</span>, -val)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 操作3: 查询第 5 个元素的值</span></span><br><span class="line"><span class="comment"># a[5] = D[1] + D[2] + ... + D[5]</span></span><br><span class="line">index_to_query = <span class="number">5</span></span><br><span class="line">value = diff_ft.query(index_to_query)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Value at index <span class="subst">&#123;index_to_query&#125;</span>: <span class="subst">&#123;value&#125;</span>&quot;</span>) <span class="comment"># 应该输出 7 (5+2)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 操作4: 查询第 8 个元素的值</span></span><br><span class="line">index_to_query = <span class="number">8</span></span><br><span class="line">value = diff_ft.query(index_to_query)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Value at index <span class="subst">&#123;index_to_query&#125;</span>: <span class="subst">&#123;value&#125;</span>&quot;</span>) <span class="comment"># 应该输出 2</span></span><br></pre></td></tr></table></figure><h4 id="场景三：区间更新，区间查询"><a href="#场景三：区间更新，区间查询" class="headerlink" title="场景三：区间更新，区间查询"></a>场景三：区间更新，区间查询</h4><p><strong>问题描述</strong>：给定一个数组，有两种操作：</p><ol><li><code>update l r val</code>: 将区间 <code>[l, r]</code> 内的每个元素都增加 <code>val</code>。</li><li><code>query l r</code>: 查询区间 <code>[l, r]</code> 的和。</li></ol><p><strong>解法</strong>：<br>这是最复杂的场景，需要两个树状数组。<br>基于场景二的差分思想，我们要求 <code>Sum(a[1]...a[x])</code>。<br><code>Sum(a[1]..a[x]) = Sum_{i=1 to x} a[i] = Sum_{i=1 to x} Sum_{j=1 to i} D[j]</code><br>这个公式可以进行数学推导和展开：<br><code>Sum_{i=1 to x} (x - i + 1) * D[i]</code><br><code>= (x+1) * Sum_{i=1 to x} D[i] - Sum_{i=1 to x} i * D[i]</code></p><p>这个公式告诉我们，为了求 <code>a</code> 的前缀和，我们需要维护两个东西：</p><ol><li><code>Sum_{i=1 to x} D[i]</code></li><li><code>Sum_{i=1 to x} i * D[i]</code></li></ol><p>因此，我们建立<strong>两个树状数组</strong>：</p><ul><li><code>BIT1</code>：维护差分数组 <code>D</code>。</li><li><code>BIT2</code>：维护 <code>i * D[i]</code> 构成的数组。</li></ul><p><strong>操作流程</strong>：</p><ul><li><strong>区间更新 <code>[l, r]</code> 加 <code>val</code></strong>：<ul><li>在 <code>BIT1</code> 上：<code>update(l, val)</code>, <code>update(r+1, -val)</code>。</li><li>在 <code>BIT2</code> 上：<code>update(l, l*val)</code>, <code>update(r+1, -(r+1)*val)</code>。</li></ul></li><li><strong>查询前缀和 <code>Sum(a[1]..a[x])</code></strong>：<ul><li>结果 &#x3D; <code>(x+1) * BIT1.query(x) - BIT2.query(x)</code>。</li></ul></li><li><strong>查询区间和 <code>Sum(a[l]..a[r])</code></strong>：<ul><li>结果 &#x3D; <code>prefix_sum(r) - prefix_sum(l-1)</code>。</li></ul></li></ul><p><strong>示例代码</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AdvancedFenwickTree</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, size</span>):</span><br><span class="line">        <span class="variable language_">self</span>.size = size</span><br><span class="line">        <span class="variable language_">self</span>.bit1 = FenwickTree(size) <span class="comment"># 维护 D[i]</span></span><br><span class="line">        <span class="variable language_">self</span>.bit2 = FenwickTree(size) <span class="comment"># 维护 i * D[i]</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update_range</span>(<span class="params">self, left, right, delta</span>):</span><br><span class="line">        <span class="comment"># 对 BIT1 更新</span></span><br><span class="line">        <span class="variable language_">self</span>.bit1.update(left, delta)</span><br><span class="line">        <span class="variable language_">self</span>.bit1.update(right + <span class="number">1</span>, -delta)</span><br><span class="line">        <span class="comment"># 对 BIT2 更新</span></span><br><span class="line">        <span class="variable language_">self</span>.bit2.update(left, left * delta)</span><br><span class="line">        <span class="variable language_">self</span>.bit2.update(right + <span class="number">1</span>, (right + <span class="number">1</span>) * (-delta))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_query_prefix_sum</span>(<span class="params">self, index</span>):</span><br><span class="line">        <span class="comment"># 根据公式计算 a 的前缀和</span></span><br><span class="line">        res1 = <span class="variable language_">self</span>.bit1.query(index)</span><br><span class="line">        res2 = <span class="variable language_">self</span>.bit2.query(index)</span><br><span class="line">        <span class="keyword">return</span> (index + <span class="number">1</span>) * res1 - res2</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">query_range_sum</span>(<span class="params">self, left, right</span>):</span><br><span class="line">        <span class="comment"># 区间和 = 前缀和之差</span></span><br><span class="line">        sum_right = <span class="variable language_">self</span>._query_prefix_sum(right)</span><br><span class="line">        sum_left_minus_1 = <span class="variable language_">self</span>._query_prefix_sum(left - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> sum_right - sum_left_minus_1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line">n = <span class="number">10</span></span><br><span class="line">adv_ft = AdvancedFenwickTree(n)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始数组全为 0</span></span><br><span class="line"><span class="comment"># 区间 [2, 7] 增加 3</span></span><br><span class="line">adv_ft.update_range(<span class="number">2</span>, <span class="number">7</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 区间 [4, 9] 增加 5</span></span><br><span class="line">adv_ft.update_range(<span class="number">4</span>, <span class="number">9</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询区间 [3, 8] 的和</span></span><br><span class="line"><span class="comment"># a[3] = 3</span></span><br><span class="line"><span class="comment"># a[4] = 3+5=8</span></span><br><span class="line"><span class="comment"># a[5] = 3+5=8</span></span><br><span class="line"><span class="comment"># a[6] = 3+5=8</span></span><br><span class="line"><span class="comment"># a[7] = 3+5=8</span></span><br><span class="line"><span class="comment"># a[8] = 5</span></span><br><span class="line"><span class="comment"># Sum = 3 + 8*4 + 5 = 3 + 32 + 5 = 40</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Sum of range [3, 8]: <span class="subst">&#123;adv_ft.query_range_sum(<span class="number">3</span>, <span class="number">8</span>)&#125;</span>&quot;</span>) <span class="comment"># 输出 40</span></span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>[1] <a href="https://www.bilibili.com/video/BV1pE41197Qj/?spm_id_from=333.1365.top_right_bar_window_history.content.click&vd_source=58f3263b57ef9a6a30806fa51b07a5c1">〔manim | 算法 | 数据结构〕 完全理解并深入应用树状数组 | 支持多种动态维护区间操作</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CPP学习笔记—智能指针</title>
      <link href="/2025/08/29/CPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
      <url>/2025/08/29/CPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<h3 id="1-为什么需要智能指针？"><a href="#1-为什么需要智能指针？" class="headerlink" title="1. 为什么需要智能指针？"></a>1. 为什么需要智能指针？</h3><p>在 C&#x2F;C++ 中，内存管理是一个核心但又极易出错的话题。传统的内存管理依赖于程序员手动使用 <code>new</code> 和 <code>delete</code> (或 <code>malloc</code> 和 <code>free</code>) 来申请和释放内存。这导致了几个经典的问题：</p><ol><li><strong>内存泄漏 (Memory Leaks)</strong>：忘记调用 <code>delete</code>。当一个动态分配的对象不再被使用，但其内存没有被释放时，这块内存就无法被再次使用，造成了内存泄漏。长时间运行的程序中，内存泄漏会耗尽系统资源，导致程序崩溃。</li><li><strong>悬挂指针 (Dangling Pointers)</strong>：一个指针指向的内存已经被释放，但指针本身没有被置为 <code>nullptr</code>。如果之后不小心通过这个悬挂指针访问或修改内存，会导致未定义行为（Undefined Behavior），通常表现为程序崩溃或数据损坏。</li><li><strong>重复释放 (Double Free)</strong>：对同一块内存调用两次或多次 <code>delete</code>。这也是一种严重的未定义行为，通常会导致程序崩溃。</li><li><strong>异常安全问题</strong>：在 <code>new</code> 和 <code>delete</code> 之间如果发生异常，<code>delete</code> 语句可能永远不会被执行，从而导致内存泄漏。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">risky_function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyObject* ptr = <span class="keyword">new</span> <span class="built_in">MyObject</span>(); <span class="comment">// 1. 分配资源</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... 做一些可能抛出异常的操作 ...</span></span><br><span class="line">    <span class="built_in">do_something_that_might_throw</span>(); </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span> ptr; <span class="comment">// 2. 释放资源。如果上面一行抛出异常，这里永远不会被执行！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了解决这些问题，C++ 引入了<strong>智能指针 (Smart Pointers)</strong>。</p><h3 id="2-核心思想：RAII-Resource-Acquisition-Is-Initialization"><a href="#2-核心思想：RAII-Resource-Acquisition-Is-Initialization" class="headerlink" title="2. 核心思想：RAII (Resource Acquisition Is Initialization)"></a>2. 核心思想：RAII (Resource Acquisition Is Initialization)</h3><p>智能指针的实现依赖于一个 C++ 的核心编程范式：<strong>RAII</strong>，即“资源获取即初始化”。</p><ul><li><strong>核心理念</strong>：将资源的生命周期与一个栈上对象的生命周期绑定。</li><li><strong>具体实现</strong>：<ol><li>在对象的<strong>构造函数</strong>中获取资源（例如，通过 <code>new</code> 分配内存）。</li><li>在对象的<strong>析构函数</strong>中释放资源（例如，调用 <code>delete</code>）。</li></ol></li><li><strong>工作原理</strong>：当一个对象在栈上创建时，它的生命周期是由其作用域（scope）决定的。当程序执行离开该作用域时（无论是正常结束、<code>return</code>、还是因为异常），该对象的析构函数会<strong>被自动调用</strong>。由于资源释放在析构函数中，这就保证了资源总是能被正确释放。</li></ul><p>智能指针本质上就是一个<strong>封装了原始指针（裸指针）的类模板</strong>，它利用 RAII 思想，在其析构函数中自动处理资源的释放。</p><hr><h3 id="3-C-标准库中的智能指针"><a href="#3-C-标准库中的智能指针" class="headerlink" title="3. C++ 标准库中的智能指针"></a>3. C++ 标准库中的智能指针</h3><p>现代 C++ (C++11及以后) 在 <code>&lt;memory&gt;</code> 头文件中提供了三种主要的智能指针，每一种都有明确的 <strong>所有权（Ownership）</strong> 语义。</p><ol><li><code>std::unique_ptr</code>：独占所有权的智能指针。</li><li><code>std::shared_ptr</code>：共享所有权的智能指针。</li><li><code>std::weak_ptr</code>：<code>shared_ptr</code> 的观察者，不拥有资源。</li></ol><hr><h3 id="4-std-unique-ptr：独占所有者"><a href="#4-std-unique-ptr：独占所有者" class="headerlink" title="4. std::unique_ptr：独占所有者"></a>4. <code>std::unique_ptr</code>：独占所有者</h3><p><code>std::unique_ptr</code> 是最常用、最轻量级的智能指针。</p><h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ul><li><strong>独占所有权</strong>：在任何时刻，只有一个 <code>unique_ptr</code> 可以指向并拥有一个给定的对象。当这个 <code>unique_ptr</code> 被销毁时（例如离开作用域），它所指向的对象也会被自动删除。</li><li><strong>不可复制</strong>：你不能拷贝一个 <code>unique_ptr</code>，因为它代表着独一无二的所有权。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::unique_ptr&lt;<span class="type">int</span>&gt; p1 = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line"><span class="comment">// std::unique_ptr&lt;int&gt; p2 = p1; // 编译错误！</span></span><br></pre></td></tr></table></figure></li><li><strong>可以移动</strong>：虽然不能复制，但可以通过 <code>std::move</code> 将所有权从一个 <code>unique_ptr</code> <strong>转移</strong>给另一个。转移后，原来的 <code>unique_ptr</code> 会变成空指针。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::unique_ptr&lt;<span class="type">int</span>&gt; p1 = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line">std::unique_ptr&lt;<span class="type">int</span>&gt; p2 = std::<span class="built_in">move</span>(p1); <span class="comment">// 正确，p1 现在是 nullptr</span></span><br><span class="line"><span class="comment">// *p1; // 运行时错误，p1 是空的</span></span><br></pre></td></tr></table></figure></li><li><strong>轻量级</strong>：在大多数情况下，<code>unique_ptr</code> 和裸指针的大小完全相同，没有任何额外的性能开销。它是一个“零成本抽象”。</li></ul><h4 id="如何创建和使用"><a href="#如何创建和使用" class="headerlink" title="如何创建和使用"></a>如何创建和使用</h4><p><strong>最佳实践</strong>是使用 <code>std::make_unique</code> (C++14 及以后版本) 来创建 <code>unique_ptr</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> val) : <span class="built_in">value</span>(val) &#123; std::cout &lt;&lt; <span class="string">&quot;MyClass(&quot;</span> &lt;&lt; value &lt;&lt; <span class="string">&quot;) constructed.\n&quot;</span>; &#125;</span><br><span class="line">    ~<span class="built_in">MyClass</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;MyClass(&quot;</span> &lt;&lt; value &lt;&lt; <span class="string">&quot;) destructed.\n&quot;</span>; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Value is &quot;</span> &lt;&lt; value &lt;&lt; <span class="string">&quot;\n&quot;</span>; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数返回一个 unique_ptr，演示所有权转移</span></span><br><span class="line"><span class="function">std::unique_ptr&lt;MyClass&gt; <span class="title">create_object</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;MyClass&gt;(val); <span class="comment">// RVO/NRVO 会自动处理移动</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Entering inner scope.\n&quot;</span>;</span><br><span class="line">        <span class="keyword">auto</span> ptr = <span class="built_in">create_object</span>(<span class="number">100</span>);</span><br><span class="line">        ptr-&gt;<span class="built_in">print</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Leaving inner scope.\n&quot;</span>;</span><br><span class="line">    &#125; <span class="comment">// ptr 在这里离开作用域，它的析构函数被调用，MyClass(100) 被自动销毁</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Returned to main scope.\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Entering inner scope.</span><br><span class="line">MyClass(100) constructed.</span><br><span class="line">Value is 100</span><br><span class="line">Leaving inner scope.</span><br><span class="line">MyClass(100) destructed.</span><br><span class="line">Returned to main scope.</span><br></pre></td></tr></table></figure><h4 id="何时使用-unique-ptr"><a href="#何时使用-unique-ptr" class="headerlink" title="何时使用 unique_ptr"></a>何时使用 <code>unique_ptr</code></h4><ul><li><strong>默认首选</strong>：当你需要一个指向动态分配对象的指针时，<code>unique_ptr</code> 应该是你的第一选择。</li><li><strong>明确所有权</strong>：用于表示对象有一个清晰的、单一的所有者。例如，工厂函数返回一个新创建的对象。</li><li><strong>管理非内存资源</strong>：通过提供自定义删除器（Custom Deleter），<code>unique_ptr</code> 也可以管理如文件句柄、数据库连接、网络套接字等资源。</li></ul><hr><h3 id="5-std-shared-ptr：共享所有者"><a href="#5-std-shared-ptr：共享所有者" class="headerlink" title="5. std::shared_ptr：共享所有者"></a>5. <code>std::shared_ptr</code>：共享所有者</h3><p><code>std::shared_ptr</code> 允许多个指针共享对同一个对象的所有权。</p><h4 id="特性-1"><a href="#特性-1" class="headerlink" title="特性"></a>特性</h4><ul><li><strong>共享所有权</strong>：可以有多个 <code>shared_ptr</code> 指向同一个对象。</li><li><strong>引用计数</strong>：<code>shared_ptr</code> 内部维护一个<strong>引用计数</strong>。每当有一个新的 <code>shared_ptr</code> 指向该对象（通过拷贝构造或拷贝赋值），引用计数加一。每当有一个 <code>shared_ptr</code> 被销毁或指向其他对象，引用计数减一。</li><li><strong>自动销毁</strong>：当引用计数变为 0 时，表示没有任何 <code>shared_ptr</code> 再指向该对象，此时对象会被自动删除。</li><li><strong>可以复制</strong>：<code>shared_ptr</code> 可以被自由地复制。</li><li><strong>开销较大</strong>：相比 <code>unique_ptr</code>，<code>shared_ptr</code> 有额外的开销。它需要动态分配一个“控制块”（Control Block）来存储引用计数、弱引用计数和删除器等信息。因此，<code>shared_ptr</code> 的大小是裸指针的两倍，并且有线程安全的引用计数操作开销。</li></ul><h4 id="如何创建和使用-1"><a href="#如何创建和使用-1" class="headerlink" title="如何创建和使用"></a>如何创建和使用</h4><p><strong>最佳实践</strong>是使用 <code>std::make_shared</code> (C++11 及以后版本) 来创建 <code>shared_ptr</code>。</p><p><strong>为什么用 <code>make_shared</code>?</strong><br><code>std::make_shared</code> 只进行<strong>一次</strong>堆内存分配，同时为对象和控制块分配空间。而 <code>std::shared_ptr&lt;T&gt;(new T())</code> 需要<strong>两次</strong>堆内存分配（一次为 <code>T</code> 对象，一次为控制块），效率更低且有异常安全风险。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process_data</span><span class="params">(std::shared_ptr&lt;MyClass&gt; sp)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Inside process_data, use_count: &quot;</span> &lt;&lt; sp.<span class="built_in">use_count</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    sp-&gt;<span class="built_in">print</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> sp1 = std::<span class="built_in">make_shared</span>&lt;MyClass&gt;(<span class="number">200</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;After creation, sp1 use_count: &quot;</span> &lt;&lt; sp<span class="number">1.</span><span class="built_in">use_count</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// 输出 1</span></span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        std::shared_ptr&lt;MyClass&gt; sp2 = sp1; <span class="comment">// 拷贝，引用计数增加</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Inside scope, sp1 use_count: &quot;</span> &lt;&lt; sp<span class="number">1.</span><span class="built_in">use_count</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// 输出 2</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Inside scope, sp2 use_count: &quot;</span> &lt;&lt; sp<span class="number">2.</span><span class="built_in">use_count</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// 输出 2</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">process_data</span>(sp1); <span class="comment">// 传参也是拷贝，函数内引用计数为3</span></span><br><span class="line">    &#125; <span class="comment">// sp2 离开作用域，引用计数减少</span></span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Outside scope, sp1 use_count: &quot;</span> &lt;&lt; sp<span class="number">1.</span><span class="built_in">use_count</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// 输出 1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="comment">// sp1 离开作用域，引用计数变为0，MyClass(200)被销毁</span></span><br></pre></td></tr></table></figure><h4 id="shared-ptr-的陷阱：循环引用-Circular-Reference"><a href="#shared-ptr-的陷阱：循环引用-Circular-Reference" class="headerlink" title="shared_ptr 的陷阱：循环引用 (Circular Reference)"></a><code>shared_ptr</code> 的陷阱：循环引用 (Circular Reference)</h4><p>这是 <code>shared_ptr</code> 最著名的问题。如果两个对象互相持有对方的 <code>shared_ptr</code>，它们的引用计数永远不会变为 0，从而导致内存泄漏。</p><p>关于循环引用的分析，我们首先需要明确一点的是，指针变量是存储在栈上的（在64位操作系统上通常是固定的8个字节），其指向在堆上动态分配的内存块，当作用域的生命周期结束（如函数结束）时，只是栈上的指针变量被销毁了，堆上动态分配的内存块并未被销毁，因此当我们手动管理内存时才需要使用delete去释放堆上的内存。然而对于<code>shared_ptr</code>来说，其通过引用计数智能实现了这点，当引用计数归零时，会智能地释放堆上的内存。</p><p>然后我们来看下面的例子，我们在main函数中创建了两个<code>shared_ptr</code>分别指向两个<code>Node</code>，其中<code>n1</code>内部又有一个<code>shared_ptr</code>指向<code>n2</code>，<code>n2</code>内部又有一个<code>shared_ptr</code>指向<code>n1</code>，因此智能指针<code>n1</code>和<code>n2</code>此时的引用计数都为2，当main函数结束时，<code>n1</code>和<code>n2</code>被销毁，此时智能指针<code>n1</code>和<code>n2</code>的引用计数变为1，由于堆上的内存只有在引用计数为0时才会被自动释放，因此此时内存不会被智能指针自动释放，造成内存泄漏。</p><p>为什么<code>n1</code>被销毁了，它的成员变量other这个<code>shared_ptr</code>没有被销毁？因为other这个<code>shared_ptr</code>和<code>n1</code>不同，它存储在堆上，所以不会被销毁，也就导致引用计数不归零。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    std::shared_ptr&lt;Node&gt; other;</span><br><span class="line">    ~<span class="built_in">Node</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Node destructed.\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> n1 = std::<span class="built_in">make_shared</span>&lt;Node&gt;();</span><br><span class="line">    <span class="keyword">auto</span> n2 = std::<span class="built_in">make_shared</span>&lt;Node&gt;();</span><br><span class="line"></span><br><span class="line">    n1-&gt;other = n2; <span class="comment">// n2 的引用计数为 2 (n2, n1-&gt;other)</span></span><br><span class="line">    n2-&gt;other = n1; <span class="comment">// n1 的引用计数为 2 (n1, n2-&gt;other)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当 main 函数结束，n1 和 n2 被销毁，引用计数各减为 1</span></span><br><span class="line">    <span class="comment">// n1-&gt;other 仍然持有 n2，n2-&gt;other 仍然持有 n1</span></span><br><span class="line">    <span class="comment">// 引用计数永远不为 0，两个 Node 对象都不会被销毁，造成内存泄漏！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了解决这个问题，我们引入了 <code>std::weak_ptr</code>。</p><h4 id="何时使用-shared-ptr"><a href="#何时使用-shared-ptr" class="headerlink" title="何时使用 shared_ptr"></a>何时使用 <code>shared_ptr</code></h4><ul><li>当资源需要被多个所有者共享，且这些所有者的生命周期不确定，无法明确由谁来最后删除资源时。例如：<ul><li>图状数据结构中的节点。</li><li>观察者模式中，被观察者可能比观察者先销毁。</li><li>需要将对象存储在多个数据结构中。</li></ul></li></ul><hr><h3 id="6-std-weak-ptr：弱引用观察者"><a href="#6-std-weak-ptr：弱引用观察者" class="headerlink" title="6. std::weak_ptr：弱引用观察者"></a>6. <code>std::weak_ptr</code>：弱引用观察者</h3><p><code>std::weak_ptr</code> 是 <code>shared_ptr</code> 的好搭档，它专门为了解决循环引用问题而生。</p><h4 id="特性-2"><a href="#特性-2" class="headerlink" title="特性"></a>特性</h4><ul><li><strong>非拥有性</strong>：<code>weak_ptr</code> 指向一个由 <code>shared_ptr</code> 管理的对象，但它<strong>不增加</strong>引用计数。它只是一个观察者。</li><li><strong>不能直接访问对象</strong>：你不能通过 <code>*</code> 或 <code>-&gt;</code> 直接解引用 <code>weak_ptr</code>。</li><li><strong>检查对象是否存在</strong>：可以通过 <code>expired()</code> 方法检查它所指向的对象是否已经被销毁。</li><li><strong>安全地获取 <code>shared_ptr</code></strong>：使用 <code>lock()</code> 方法。如果对象仍然存在，<code>lock()</code> 会返回一个指向该对象的有效的 <code>shared_ptr</code>（并增加引用计数）；如果对象已被销毁，<code>lock()</code> 会返回一个空的 <code>shared_ptr</code>。这是访问 <code>weak_ptr</code> 所指对象的唯一安全方式。</li></ul><h4 id="解决循环引用"><a href="#解决循环引用" class="headerlink" title="解决循环引用"></a>解决循环引用</h4><p>我们将上面例子中的一个 <code>shared_ptr</code> 改为 <code>weak_ptr</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="comment">// 使用 weak_ptr 打破循环</span></span><br><span class="line">    std::weak_ptr&lt;Node&gt; other; </span><br><span class="line">    ~<span class="built_in">Node</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Node destructed.\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> n1 = std::<span class="built_in">make_shared</span>&lt;Node&gt;();</span><br><span class="line">    <span class="keyword">auto</span> n2 = std::<span class="built_in">make_shared</span>&lt;Node&gt;();</span><br><span class="line"></span><br><span class="line">    n1-&gt;other = n2; <span class="comment">// n2 的引用计数仍为 1 (来自n2本身)</span></span><br><span class="line">    n2-&gt;other = n1; <span class="comment">// n1 的引用计数仍为 1 (来自n1本身)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 weak_ptr 指向的对象</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> sp = n1-&gt;other.<span class="built_in">lock</span>()) &#123;</span><br><span class="line">        <span class="comment">// sp 是一个 shared_ptr，可以安全使用</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;n2 still alive.\n&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;n2 has been destroyed.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">// main 结束，n1 和 n2 销毁，引用计数变为0，对象被正确析构</span></span><br></pre></td></tr></table></figure><p><strong>输出:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">n2 still alive.</span><br><span class="line">Node destructed.</span><br><span class="line">Node destructed.</span><br></pre></td></tr></table></figure><p>因为 <code>weak_ptr</code> 不增加引用计数，当 <code>n1</code> 和 <code>n2</code> 离开作用域时，它们的引用计数都能顺利降为 0，从而正确释放内存。</p><h4 id="何时使用-weak-ptr"><a href="#何时使用-weak-ptr" class="headerlink" title="何时使用 weak_ptr"></a>何时使用 <code>weak_ptr</code></h4><ul><li><strong>打破 <code>shared_ptr</code> 的循环引用</strong>：这是其最主要的应用场景。</li><li><strong>缓存</strong>：当你想缓存一个大对象但又不希望因为缓存的存在而阻止该对象被销毁时。</li><li><strong>观察者模式</strong>：当需要安全地检查一个对象是否还存在，但又不影响其生命周期时。</li></ul><h3 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h3><table><thead><tr><th align="left">特性</th><th align="left"><code>std::unique_ptr</code></th><th align="left"><code>std::shared_ptr</code></th><th align="left"><code>std::weak_ptr</code></th></tr></thead><tbody><tr><td align="left"><strong>所有权</strong></td><td align="left">独占、唯一</td><td align="left">共享、引用计数</td><td align="left">非拥有、观察者</td></tr><tr><td align="left"><strong>可否复制</strong></td><td align="left">否（但可移动）</td><td align="left">是</td><td align="left">是</td></tr><tr><td align="left"><strong>性能开销</strong></td><td align="left">极低（几乎为零）</td><td align="left">较高（控制块、原子操作）</td><td align="left">较高（需要访问控制块）</td></tr><tr><td align="left"><strong>主要用途</strong></td><td align="left">默认选择，管理有单一所有者的资源</td><td align="left">管理有多个不确定生命周期所有者的资源</td><td align="left">打破 <code>shared_ptr</code> 循环引用，监视对象</td></tr><tr><td align="left"><strong>创建方式</strong></td><td align="left"><code>std::make_unique</code></td><td align="left"><code>std::make_shared</code></td><td align="left">从 <code>shared_ptr</code> 构造</td></tr></tbody></table><ol><li><strong>默认使用 <code>std::unique_ptr</code></strong>：这是最安全、最高效的选择。它清晰地表达了所有权。</li><li><strong>当你确实需要共享所有权时，才使用 <code>std::shared_ptr</code></strong>：仔细思考你的设计，是否真的无法确定一个唯一的“所有者”。如果答案是肯定的，那么 <code>shared_ptr</code> 就是正确的工具。</li><li><strong>当你使用 <code>shared_ptr</code> 并且可能出现循环引用时，使用 <code>std::weak_ptr</code></strong>：在相互引用的类中，将其中一方（通常是“子”指向“父”或“被拥有者”指向“拥有者”）的指针改为 <code>weak_ptr</code>。</li><li><strong>裸指针 (<code>T*</code>) 还有用吗？</strong> 有。用于<strong>非拥有</strong>、<strong>仅观察</strong>的场景，并且你能<strong>百分之百保证</strong>该指针的生命周期不会超过它所指向的对象的生命周期。典型的例子是函数参数和 <code>this</code> 指针。</li></ol>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CPP学习笔记—特殊成员函数</title>
      <link href="/2025/08/28/CPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E7%89%B9%E6%AE%8A%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0/"/>
      <url>/2025/08/28/CPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E7%89%B9%E6%AE%8A%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="1-引言：对象生命周期与-RAII"><a href="#1-引言：对象生命周期与-RAII" class="headerlink" title="1. 引言：对象生命周期与 RAII"></a>1. 引言：对象生命周期与 RAII</h3><p>C++ 中，对象有明确的生命周期：它被创建，然后在使用结束后被销毁。<strong>构造函数、拷贝构造函数、拷贝赋值运算符、移动构造函数、移动赋值运算符和析构函数</strong>这六个函数（通常被称为<strong>特殊成员函数</strong>）就是用来管理这个生命周期的。它们控制着对象的：</p><ul><li><strong>创建</strong> (Construction)</li><li><strong>销毁</strong> (Destruction)</li><li><strong>拷贝</strong> (Copying)</li><li><strong>移动</strong> (Moving)</li></ul><p>它们是实现 C++ 核心设计哲学 <strong>RAII (Resource Acquisition Is Initialization)</strong> 的基石。RAII 意味着在对象的构造函数中获取资源（如内存、文件句柄、锁），并在其析构函数中释放资源，从而将资源的生命周期与对象的生命周期绑定在一起，避免资源泄漏。</p><h3 id="2-核心示例：一个简单的-Buffer-类"><a href="#2-核心示例：一个简单的-Buffer-类" class="headerlink" title="2. 核心示例：一个简单的 Buffer 类"></a>2. 核心示例：一个简单的 <code>Buffer</code> 类</h3><p>我们将使用一个简单的 <code>Buffer</code> 类来贯穿整个讲解。这个类在堆上分配了一块整数数组，因此它需要手动管理内存资源。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span> <span class="comment">// For std::copy</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Buffer</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span>* _ptr;</span><br><span class="line">    <span class="type">size_t</span> _size;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 我们将在这里填充这六个特殊成员函数</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (_ptr) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; _size; ++i) &#123;</span><br><span class="line">                std::cout &lt;&lt; _ptr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h3 id="3-构造函数-Constructor"><a href="#3-构造函数-Constructor" class="headerlink" title="3. 构造函数 (Constructor)"></a>3. 构造函数 (Constructor)</h3><ul><li><strong>目的</strong>：<strong>初始化</strong>一个新创建的对象，为其分配所需资源，并建立一个有效的初始状态。</li><li><strong>特征</strong>：函数名与类名相同，没有返回类型。</li><li><strong>何时调用</strong>：当一个新对象被创建时。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 Buffer 类中</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 参数化构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Buffer</span><span class="params">(<span class="type">size_t</span> size)</span> : _ptr(new int[size]), _size(size) &#123;</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Constructor called (size=&quot;</span> &lt;&lt; size &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// 初始化 buffer 内容，例如全为0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; _size; ++i) &#123;</span><br><span class="line">            _ptr[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认构造函数 (创建一个空 Buffer)</span></span><br><span class="line">    <span class="built_in">Buffer</span>() : _ptr(<span class="literal">nullptr</span>), _size(<span class="number">0</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Default Constructor called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li><strong>重点</strong>：使用 <strong>成员初始化列表 (Member Initializer List)</strong>（即冒号 <code>:</code> 后面的部分）来初始化成员。这比在构造函数体 <code>{}</code> 内赋值更高效，对于 <code>const</code> 成员或引用成员来说是必须的。</li></ul><hr><h3 id="4-析构函数-Destructor"><a href="#4-析构函数-Destructor" class="headerlink" title="4. 析构函数 (Destructor)"></a>4. 析构函数 (Destructor)</h3><ul><li><strong>目的</strong>：在对象生命周期结束时 <strong>清理</strong> 对象，释放其占有的资源。</li><li><strong>特征</strong>：函数名前面有一个波浪号 <code>~</code>，没有返回类型，也没有参数。</li><li><strong>何时调用</strong>：当对象离开其作用域、<code>delete</code>一个指向对象的指针时，或程序结束时（对于全局&#x2F;静态对象）。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 Buffer 类中</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">Buffer</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Destructor called (size=&quot;</span> &lt;&lt; _size &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">delete</span>[] _ptr; <span class="comment">// 释放构造函数中分配的内存</span></span><br><span class="line">        _ptr = <span class="literal">nullptr</span>; <span class="comment">// 好的实践，防止悬挂指针</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li><strong>重点</strong>：如果你的类被用作基类，并且你希望通过基类指针 <code>delete</code> 派生类对象，那么析构函数 <strong>必须</strong> 声明为 <code>virtual</code>（<code>virtual ~Buffer()</code>），以防止资源泄漏。</li></ul><hr><h3 id="5-拷贝构造函数-Copy-Constructor"><a href="#5-拷贝构造函数-Copy-Constructor" class="headerlink" title="5. 拷贝构造函数 (Copy Constructor)"></a>5. 拷贝构造函数 (Copy Constructor)</h3><ul><li><strong>目的</strong>：使用一个 <strong>已存在的同类对象</strong> 来 <strong>创建一个新的对象</strong>。这是“拷贝”语义的来源。</li><li><strong>特征</strong>：参数是此类的一个 <code>const</code> 引用。<code>const</code> 是因为我们不应该修改源对象，引用 <code>&amp;</code> 是为了避免无限递归的拷贝。</li><li><strong>何时调用</strong>：<ol><li><code>Buffer b2 = b1;</code> 或 <code>Buffer b2(b1);</code> (初始化)</li><li>函数按值传递对象：<code>void func(Buffer b);</code></li><li>函数按值返回对象：<code>Buffer func();</code></li></ol></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 Buffer 类中</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 拷贝构造函数 (实现深拷贝)</span></span><br><span class="line">    <span class="built_in">Buffer</span>(<span class="type">const</span> Buffer&amp; other) : _ptr(<span class="keyword">new</span> <span class="type">int</span>[other._size]), _size(other._size) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Copy Constructor called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// 复制源对象 buffer 中的内容，而不是仅仅复制指针</span></span><br><span class="line">        std::<span class="built_in">copy</span>(other._ptr, other._ptr + other._size, _ptr);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li><strong>重点</strong>：如果你不提供，编译器会生成一个默认的拷贝构造函数，它执行 <strong>浅拷贝</strong>（只复制指针 <code>_ptr</code> 的值，不复制其指向的数据），这会导致两个对象指向同一块内存，从而引发“重复释放”的严重错误。因此，对于管理资源的类，<strong>必须</strong> 实现深拷贝。</li></ul><hr><h3 id="6-拷贝赋值运算符-Copy-Assignment-Operator"><a href="#6-拷贝赋值运算符-Copy-Assignment-Operator" class="headerlink" title="6. 拷贝赋值运算符 (Copy Assignment Operator)"></a>6. 拷贝赋值运算符 (Copy Assignment Operator)</h3><ul><li><strong>目的</strong>：将一个 <strong>已存在的对象</strong> 的值赋给另一个 <strong>已存在的对象</strong>。</li><li><strong>特征</strong>：通常返回一个指向当前对象的引用 (<code>*this</code>) 以支持链式赋值 (<code>a = b = c;</code>)。</li><li><strong>何时调用</strong>：<code>b2 = b1;</code> (赋值，此时 b1 和 b2 都已经存在)。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 Buffer 类中</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Buffer&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Buffer&amp; other) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Copy Assignment Operator called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 检查自赋值 (非常重要！)</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;other) &#123;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 释放当前对象已有的资源</span></span><br><span class="line">        <span class="keyword">delete</span>[] _ptr;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 分配新资源并从源对象拷贝数据 (深拷贝)</span></span><br><span class="line">        _size = other._size;</span><br><span class="line">        _ptr = <span class="keyword">new</span> <span class="type">int</span>[other._size];</span><br><span class="line">        std::<span class="built_in">copy</span>(other._ptr, other._ptr + other._size, _ptr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 返回 *this</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li><strong>重点</strong>：自赋值检查 (<code>if (this == &amp;other)</code>) 是防止在 <code>b1 = b1;</code> 这种情况下，提前 <code>delete</code> 掉自己的资源导致后续无法拷贝。</li></ul><hr><h3 id="7-“三之法则”-The-Rule-of-Three"><a href="#7-“三之法则”-The-Rule-of-Three" class="headerlink" title="7. “三之法则” (The Rule of Three)"></a>7. “三之法则” (The Rule of Three)</h3><p>这是一个经典的 C++ 设计准则：<br><strong>如果你需要显式声明析构函数、拷贝构造函数或拷贝赋值运算符中的任何一个，那么你几乎肯定需要将这三个都声明。</strong><br>我们的 <code>Buffer</code> 类就是完美范例：因为它需要自定义析构函数来释放内存，所以它也必须自定义拷贝操作来实现深拷贝。</p><hr><h3 id="8-移动构造函数-Move-Constructor-C-11"><a href="#8-移动构造函数-Move-Constructor-C-11" class="headerlink" title="8. 移动构造函数 (Move Constructor) - C++11"></a>8. 移动构造函数 (Move Constructor) - C++11</h3><ul><li><strong>目的</strong>：从一个临时对象（右值，如函数返回值）<strong>“窃取”或“转移”</strong> 资源来构造一个新对象。这比深拷贝高效得多，因为它避免了内存的重新分配和数据的复制。</li><li><strong>特征</strong>：参数是一个非 <code>const</code> 的右值引用 (<code>&amp;&amp;</code>)。</li><li><strong>何时调用</strong>：当用一个右值初始化对象时，例如 <code>Buffer b(create_buffer());</code> 或 <code>Buffer b(std::move(another_buffer));</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 Buffer 类中</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 移动构造函数</span></span><br><span class="line">    <span class="built_in">Buffer</span>(Buffer&amp;&amp; other) <span class="keyword">noexcept</span> </span><br><span class="line">        : _ptr(other._ptr), _size(other._size) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Move Constructor called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 1. &quot;窃取&quot;资源</span></span><br><span class="line">        <span class="comment">// 已经通过初始化列表完成</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 将源对象置于一个有效的、可析构的状态</span></span><br><span class="line">        <span class="comment">//    这是关键！防止源对象的析构函数释放我们刚刚&quot;窃取&quot;的资源</span></span><br><span class="line">        other._ptr = <span class="literal">nullptr</span>;</span><br><span class="line">        other._size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li><strong>重点</strong>：移动构造函数应该是 <code>noexcept</code> 的，这向编译器承诺它不会抛出异常，使得标准库容器（如 <code>std::vector</code>）在需要重新分配内存时可以安全地使用移动而非拷贝，从而获得巨大性能提升。</li></ul><hr><h3 id="9-移动赋值运算符-Move-Assignment-Operator-C-11"><a href="#9-移动赋值运算符-Move-Assignment-Operator-C-11" class="headerlink" title="9. 移动赋值运算符 (Move Assignment Operator) - C++11"></a>9. 移动赋值运算符 (Move Assignment Operator) - C++11</h3><ul><li><strong>目的</strong>：将一个临时对象（右值）的资源 <strong>“窃取”</strong> 给一个已存在的对象。</li><li><strong>特征</strong>：参数是右值引用 <code>&amp;&amp;</code>，返回 <code>*this</code>。</li><li><strong>何时调用</strong>：当将一个右值赋给一个已存在的对象时，例如 <code>b = create_buffer();</code> 或 <code>b = std::move(another_buffer);</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 Buffer 类中</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Buffer&amp; <span class="keyword">operator</span>=(Buffer&amp;&amp; other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Move Assignment Operator called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;other) &#123; <span class="comment">// 检查自移动</span></span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 释放当前对象的资源</span></span><br><span class="line">        <span class="keyword">delete</span>[] _ptr;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. &quot;窃取&quot;源对象的资源</span></span><br><span class="line">        _ptr = other._ptr;</span><br><span class="line">        _size = other._size;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 将源对象置于有效、可析构的状态</span></span><br><span class="line">        other._ptr = <span class="literal">nullptr</span>;</span><br><span class="line">        other._size = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr><h3 id="10-“五之法则”-The-Rule-of-Five-与-“零之法则”-The-Rule-of-Zero"><a href="#10-“五之法则”-The-Rule-of-Five-与-“零之法则”-The-Rule-of-Zero" class="headerlink" title="10. “五之法则” (The Rule of Five) 与 “零之法则” (The Rule of Zero)"></a>10. “五之法则” (The Rule of Five) 与 “零之法则” (The Rule of Zero)</h3><ul><li><p><strong>五之法则 (Rule of Five)</strong>：C++11 后的扩展。如果一个类需要自定义析构、拷贝或移动操作中的任何一个，那么它可能需要全部五个。</p></li><li><p><strong>零之法则 (Rule of Zero)</strong> - <strong>现代 C++ 最佳实践</strong>：<br><strong>你的类应该只负责业务逻辑，而将资源管理委托给专门的 RAII 类（如 <code>std::vector</code>, <code>std::string</code>, <code>std::unique_ptr</code>, <code>std::shared_ptr</code>）。</strong><br>如果遵循此法则，你的类通常 <strong>不需要</strong> 手动编写任何特殊成员函数，编译器自动生成的版本会做正确的事。</p><p><strong>使用零之法则重写 <code>Buffer</code> 类：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ModernBuffer</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; _data; <span class="comment">// std::vector 内部已经正确实现了所有五个特殊函数！</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ModernBuffer</span>(<span class="type">size_t</span> size) : _data(size) &#123;&#125; <span class="comment">// 简洁</span></span><br><span class="line">    <span class="comment">// 不需要手动写析构、拷贝、移动函数！</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="11-总结"><a href="#11-总结" class="headerlink" title="11. 总结"></a>11. 总结</h3><table><thead><tr><th align="left">函数名称</th><th align="left">签名示例</th><th align="left">目的</th><th align="left">触发示例 (<code>b1</code>, <code>b2</code> 已存在)</th></tr></thead><tbody><tr><td align="left"><strong>构造函数</strong></td><td align="left"><code>Buffer(size_t size);</code></td><td align="left">创建并初始化新对象</td><td align="left"><code>Buffer b1(10);</code></td></tr><tr><td align="left"><strong>析构函数</strong></td><td align="left"><code>~Buffer();</code></td><td align="left">销毁对象，释放资源</td><td align="left">(自动调用) <code>}</code> 或 <code>delete ptr;</code></td></tr><tr><td align="left"><strong>拷贝构造函数</strong></td><td align="left"><code>Buffer(const Buffer&amp; other);</code></td><td align="left">用 <code>other</code> 创建一个 <strong>新对象</strong></td><td align="left"><code>Buffer b3 = b1;</code></td></tr><tr><td align="left"><strong>拷贝赋值运算符</strong></td><td align="left"><code>Buffer&amp; operator=(const Buffer&amp; other);</code></td><td align="left">将 <code>other</code> 赋给一个 <strong>已存在对象</strong></td><td align="left"><code>b2 = b1;</code></td></tr><tr><td align="left"><strong>移动构造函数 (C++11)</strong></td><td align="left"><code>Buffer(Buffer&amp;&amp; other) noexcept;</code></td><td align="left">从临时对象 <code>other</code> <strong>窃取资源</strong> 创建新对象</td><td align="left"><code>Buffer b3 = create_buffer();</code></td></tr><tr><td align="left"><strong>移动赋值运算符 (C++11)</strong></td><td align="left"><code>Buffer&amp; operator=(Buffer&amp;&amp; other) noexcept;</code></td><td align="left">从临时对象 <code>other</code> <strong>窃取资源</strong> 给已存在对象</td><td align="left"><code>b2 = std::move(b1);</code></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CPP学习笔记—深拷贝与浅拷贝</title>
      <link href="/2025/08/28/CPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
      <url>/2025/08/28/CPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
      
        <content type="html"><![CDATA[<p>C++ 中的深拷贝（Deep Copy）和浅拷贝（Shallow Copy）是一个 C++ 实际开发中至关重要的核心概念，因为它直接关系到程序的正确性和内存安全。</p><hr><h3 id="1-问题的根源：指针和动态内存"><a href="#1-问题的根源：指针和动态内存" class="headerlink" title="1. 问题的根源：指针和动态内存"></a>1. 问题的根源：指针和动态内存</h3><p>要理解深拷贝和浅拷贝，首先必须明白问题的根源在哪里。如果一个类只包含基本数据类型（如 <code>int</code>, <code>double</code>）或者不持有动态资源的对象（如 <code>std::string</code>，它自己内部处理好了深拷贝），那么我们通常不需要关心这个问题。</p><p><strong>问题出现在当一个类的成员变量是指针，并且这个指针指向了在堆（Heap）上动态分配的内存时。</strong></p><p>来看一个简单的例子，一个自定义的字符串包装类：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyString</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* _data;</span><br><span class="line">    <span class="type">size_t</span> _len;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyString</span>(<span class="type">const</span> <span class="type">char</span>* s = <span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">        _len = <span class="built_in">strlen</span>(s);</span><br><span class="line">        _data = <span class="keyword">new</span> <span class="type">char</span>[_len + <span class="number">1</span>]; <span class="comment">// 在堆上分配内存</span></span><br><span class="line">        <span class="built_in">strcpy</span>(_data, s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">MyString</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] _data; <span class="comment">// 在析构时释放内存</span></span><br><span class="line">        _data = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... 其他成员函数 ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个 <code>MyString</code> 类自己管理了一块动态内存（<code>_data</code>）。当我们复制这个类的对象时，问题就来了。</p><hr><h3 id="2-浅拷贝-Shallow-Copy-：简单的成员复制"><a href="#2-浅拷贝-Shallow-Copy-：简单的成员复制" class="headerlink" title="2. 浅拷贝 (Shallow Copy)：简单的成员复制"></a>2. 浅拷贝 (Shallow Copy)：简单的成员复制</h3><h4 id="什么是浅拷贝？"><a href="#什么是浅拷贝？" class="headerlink" title="什么是浅拷贝？"></a>什么是浅拷贝？</h4><p>浅拷贝，也称为“成员逐一复制”或“位拷贝”，是<strong>仅仅复制对象的所有成员变量的值</strong>。</p><ul><li>对于基本数据类型，复制的是值本身。</li><li>对于指针类型，复制的是 <strong>指针的地址值</strong>，而不是指针所指向的内存内容。</li></ul><h4 id="编译器何时会生成浅拷贝？"><a href="#编译器何时会生成浅拷贝？" class="headerlink" title="编译器何时会生成浅拷贝？"></a>编译器何时会生成浅拷贝？</h4><p>当你没有自定义拷贝构造函数和拷贝赋值运算符时，编译器会自动为你生成它们。而这些自动生成的版本执行的就是浅拷贝。</p><h4 id="浅拷贝带来的致命问题"><a href="#浅拷贝带来的致命问题" class="headerlink" title="浅拷贝带来的致命问题"></a>浅拷贝带来的致命问题</h4><p>让我们看看使用默认的浅拷贝会发生什么：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// (接上文的 MyString 类定义)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cause_problem</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyString <span class="title">str1</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;</span><br><span class="line">    MyString str2 = str1; <span class="comment">// 调用了编译器生成的拷贝构造函数 -&gt; 浅拷贝</span></span><br><span class="line">&#125; <span class="comment">// 函数结束，str1 和 str2 的析构函数被调用</span></span><br></pre></td></tr></table></figure><p><strong>发生了什么？</strong></p><ol><li><p><code>MyString str1(&quot;hello&quot;);</code></p><ul><li><code>str1._data</code> 指向堆上的一块内存，内容为 “hello\0”。</li><li><code>str1._len</code> 为 5。</li></ul></li><li><p><code>MyString str2 = str1;</code> (浅拷贝)</p><ul><li><code>str2._len</code> 被赋值为 <code>str1._len</code> (值为 5)。</li><li><code>str2._data</code> 被赋值为 <code>str1._data</code> (同一个内存地址！)。</li></ul></li></ol><p>现在，<code>str1</code> 和 <code>str2</code> 内部的 <code>_data</code> 指针指向了 <strong>同一块</strong> 堆内存。</p><p><strong>问题一：悬挂指针 (Dangling Pointer)</strong></p><p>如果 <code>str2</code> 在某个时刻被修改，<code>str1</code> 也会被“意外”地修改，因为它们共享数据。更严重的是，如果其中一个对象被销毁…</p><p><strong>问题二：重复释放 (Double Free)</strong></p><p>当 <code>cause_problem</code> 函数结束时：</p><ol><li><code>str2</code> 的析构函数被调用。它执行 <code>delete[] _data;</code>，成功释放了内存。</li><li><code>str1</code> 的析构函数被调用。它执行 <code>delete[] _data;</code>，试图 <strong>再次释放同一块已经被释放的内存</strong>。</li></ol><p><strong>这会导致程序崩溃！</strong> 这就是所谓的“重复释放”错误，是 C++ 中非常严重的内存错误。</p><hr><h3 id="3-深拷贝-Deep-Copy-：复制指针指向的内容"><a href="#3-深拷贝-Deep-Copy-：复制指针指向的内容" class="headerlink" title="3. 深拷贝 (Deep Copy)：复制指针指向的内容"></a>3. 深拷贝 (Deep Copy)：复制指针指向的内容</h3><h4 id="什么是深拷贝？"><a href="#什么是深拷贝？" class="headerlink" title="什么是深拷贝？"></a>什么是深拷贝？</h4><p>深拷贝是在进行对象复制时，如果遇到指针类型的成员变量，它<strong>不会只复制指针的地址，而是会重新分配一块新的内存空间，然后将原始指针所指向的内容复制到这块新内存中</strong>。</p><p>这样，两个对象就各自拥有了独立的内存资源，互不影响。</p><h4 id="如何实现深拷贝？"><a href="#如何实现深拷贝？" class="headerlink" title="如何实现深拷贝？"></a>如何实现深拷贝？</h4><p>要实现深拷贝，你必须<strong>手动</strong>为你的类提供：</p><ol><li><strong>拷贝构造函数 (Copy Constructor)</strong></li><li><strong>拷贝赋值运算符 (Copy Assignment Operator)</strong></li></ol><hr><h3 id="4-C-中的实现：拷贝构造函数与拷贝赋值运算符"><a href="#4-C-中的实现：拷贝构造函数与拷贝赋值运算符" class="headerlink" title="4. C++ 中的实现：拷贝构造函数与拷贝赋值运算符"></a>4. C++ 中的实现：拷贝构造函数与拷贝赋值运算符</h3><p>让我们为 <code>MyString</code> 类添加深拷贝的实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyString</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* _data;</span><br><span class="line">    <span class="type">size_t</span> _len;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 默认构造函数</span></span><br><span class="line">    <span class="built_in">MyString</span>(<span class="type">const</span> <span class="type">char</span>* s = <span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Constructor called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        _len = <span class="built_in">strlen</span>(s);</span><br><span class="line">        _data = <span class="keyword">new</span> <span class="type">char</span>[_len + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(_data, s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">MyString</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Destructor called for &quot;</span> &lt;&lt; (_data ? _data : <span class="string">&quot;null&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">delete</span>[] _data;</span><br><span class="line">        _data = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 拷贝构造函数 (实现深拷贝)</span></span><br><span class="line">    <span class="built_in">MyString</span>(<span class="type">const</span> MyString&amp; other) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Copy Constructor called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        _len = other._len;</span><br><span class="line">        _data = <span class="keyword">new</span> <span class="type">char</span>[_len + <span class="number">1</span>]; <span class="comment">// 分配新的内存</span></span><br><span class="line">        <span class="built_in">strcpy</span>(_data, other._data); <span class="comment">// 拷贝内容</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 拷贝赋值运算符 (实现深拷贝)</span></span><br><span class="line">    MyString&amp; <span class="keyword">operator</span>=(<span class="type">const</span> MyString&amp; other) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Copy Assignment Operator called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 关键步骤1：检查自赋值</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;other) &#123;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关键步骤2：释放当前对象已有的资源</span></span><br><span class="line">        <span class="keyword">delete</span>[] _data;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关键步骤3：分配新资源并拷贝内容</span></span><br><span class="line">        _len = other._len;</span><br><span class="line">        _data = <span class="keyword">new</span> <span class="type">char</span>[_len + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(_data, other._data);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关键步骤4：返回*this以支持链式赋值 (a = b = c)</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (_data) &#123;</span><br><span class="line">            std::cout &lt;&lt; _data &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyString <span class="title">str1</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>; <span class="comment">// Constructor</span></span><br><span class="line">    </span><br><span class="line">    MyString str2 = str1; <span class="comment">// 调用拷贝构造函数</span></span><br><span class="line">    <span class="comment">// 等价于 MyString str2(str1);</span></span><br><span class="line"></span><br><span class="line">    MyString str3; <span class="comment">// Constructor</span></span><br><span class="line">    str3 = str1;   <span class="comment">// 调用拷贝赋值运算符</span></span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;--- Exiting main ---&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// str3, str2, str1 的析构函数依次被调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Constructor called</span><br><span class="line">Copy Constructor called</span><br><span class="line">Constructor called</span><br><span class="line">Copy Assignment Operator called</span><br><span class="line">--- Exiting main ---</span><br><span class="line">Destructor called for hello</span><br><span class="line">Destructor called for hello</span><br><span class="line">Destructor called for hello</span><br></pre></td></tr></table></figure><p>现在，每个对象都有自己独立的内存，析构时各自释放自己的内存，程序运行正常，没有任何内存错误。</p><hr><h3 id="5-“三-五-零之法则”-The-Rule-of-Three-Five-Zero"><a href="#5-“三-五-零之法则”-The-Rule-of-Three-Five-Zero" class="headerlink" title="5. “三&#x2F;五&#x2F;零之法则” (The Rule of Three&#x2F;Five&#x2F;Zero)"></a>5. “三&#x2F;五&#x2F;零之法则” (The Rule of Three&#x2F;Five&#x2F;Zero)</h3><p>这是一个关于何时需要手写特殊成员函数（析构、拷贝、移动）的指导方针。</p><h4 id="三之法则-Rule-of-Three-经典-C"><a href="#三之法则-Rule-of-Three-经典-C" class="headerlink" title="三之法则 (Rule of Three) - 经典 C++"></a>三之法则 (Rule of Three) - 经典 C++</h4><p><strong>如果你需要显式地声明析构函数、拷贝构造函数、或拷贝赋值运算符中的任何一个，那么你很可能需要把这三个都声明。</strong></p><ul><li><strong>原因</strong>：手动管理资源（如 <code>new</code>&#x2F;<code>delete</code>）通常是同时需要这三者的根本原因。<ul><li>需要析构函数来 <code>delete</code> 资源。</li><li>需要拷贝构造函数和拷贝赋值运算符来实现深拷贝，以避免浅拷贝带来的问题。</li></ul></li></ul><p>我们的 <code>MyString</code> 例子完美地诠释了三之法则。</p><h4 id="五之法则-Rule-of-Five-C-11"><a href="#五之法则-Rule-of-Five-C-11" class="headerlink" title="五之法则 (Rule of Five) - C++11"></a>五之法则 (Rule of Five) - C++11</h4><p>随着 C++11 引入了<strong>移动语义 (Move Semantics)</strong>，这个法则扩展了。</p><p><strong>如果你需要手动实现析构、拷贝构造、拷贝赋值、移动构造、或移动赋值中的任何一个，那么你可能需要实现所有五个。</strong></p><ul><li><strong>移动构造函数</strong> <code>MyString(MyString&amp;&amp; other)</code></li><li><strong>移动赋值运算符</strong> <code>MyString&amp; operator=(MyString&amp;&amp; other)</code></li></ul><p>移动操作用于从临时对象（右值）“窃取”资源，而不是昂贵的拷贝，极大地提高了性能。</p><h4 id="零之法则-Rule-of-Zero-现代-C-最佳实践"><a href="#零之法则-Rule-of-Zero-现代-C-最佳实践" class="headerlink" title="零之法则 (Rule of Zero) - 现代 C++ 最佳实践"></a>零之法则 (Rule of Zero) - 现代 C++ 最佳实践</h4><p><strong>一个类应该专注于一项任务。如果这个任务是业务逻辑，那么它就不应该操心资源管理。</strong></p><p><strong>核心思想</strong>：<strong>不要自己手动管理资源！</strong> 使用 C++ 标准库提供的 RAII (Resource Acquisition Is Initialization) 容器和智能指针。</p><ul><li>用 <code>std::string</code> 代替 <code>char*</code>。</li><li>用 <code>std::vector&lt;T&gt;</code> 代替 <code>T*</code> 动态数组。</li><li>用 <code>std::unique_ptr&lt;T&gt;</code> 或 <code>std::shared_ptr&lt;T&gt;</code> 来管理单个动态对象的生命周期。</li></ul><p>如果你遵循零之法则，你的类可能看起来像这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyModernClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string _name; <span class="comment">// std::string 内部实现了深拷贝</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; _items; <span class="comment">// std::vector 内部实现了深拷贝</span></span><br><span class="line">    std::unique_ptr&lt;SomeResource&gt; _resource; <span class="comment">// unique_ptr 管理资源，但不可拷贝</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 不需要手动写析构、拷贝构造、拷贝赋值、移动构造、移动赋值！</span></span><br><span class="line">    <span class="comment">// 编译器自动生成的版本会正确地调用每个成员的对应函数。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当拷贝 <code>MyModernClass</code> 的对象时，编译器生成的拷贝构造函数会自动调用 <code>std::string</code> 和 <code>std::vector</code> 的拷贝构造函数，它们会执行正确的深拷贝。你一行代码都不用多写，这就是零之法则。</p><hr><h3 id="6-总结对比表"><a href="#6-总结对比表" class="headerlink" title="6. 总结对比表"></a>6. 总结对比表</h3><table><thead><tr><th align="left">特性</th><th align="left">浅拷贝 (Shallow Copy)</th><th align="left">深拷贝 (Deep Copy)</th></tr></thead><tbody><tr><td align="left"><strong>定义</strong></td><td align="left">只复制成员变量的值，如果是指针，则复制地址。</td><td align="left">复制成员变量的值，如果是指针，则为指针所指内容分配新内存并复制。</td></tr><tr><td align="left"><strong>实现方式</strong></td><td align="left">编译器默认生成。</td><td align="left">需要用户自己实现拷贝构造函数和拷贝赋值运算符。</td></tr><tr><td align="left"><strong>资源管理</strong></td><td align="left">多个对象共享同一份外部资源。</td><td align="left">每个对象拥有自己独立的外部资源副本。</td></tr><tr><td align="left"><strong>优点</strong></td><td align="left">速度快，开销小。</td><td align="left">安全，对象间互不影响，避免内存错误。</td></tr><tr><td align="left"><strong>缺点</strong></td><td align="left">极易导致悬挂指针和重复释放等内存错误，非常危险。</td><td align="left">实现复杂，有额外的内存分配和数据复制开销，性能较低。</td></tr><tr><td align="left"><strong>适用场景</strong></td><td align="left">仅当类中没有指针成员或不涉及动态资源管理时才安全。</td><td align="left"><strong>只要类中包含指向动态分配资源的指针，就必须使用深拷贝。</strong></td></tr><tr><td align="left"><strong>现代实践</strong></td><td align="left">尽量避免需要手动区分的场景，使用 RAII 类（<code>std::string</code>, <code>std::vector</code>, 智能指针）来自动处理，遵循“零之法则”。</td><td align="left"></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CPP学习笔记—多态</title>
      <link href="/2025/08/27/CPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E5%A4%9A%E6%80%81/"/>
      <url>/2025/08/27/CPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E5%A4%9A%E6%80%81/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是多态？"><a href="#什么是多态？" class="headerlink" title="什么是多态？"></a>什么是多态？</h2><p><strong>多态</strong>，从字面意思上看，是“多种形态”的意思。在 C++ 中，多态是面向对象编程（OOP）的三大核心特性之一（另外两个是<strong>封装</strong>和<strong>继承</strong>）。它允许你使用一个统一的接口来处理不同类型的对象，使得程序具有更好的可扩展性和灵活性。</p><p>一个通俗的例子是：你有一个通用的“遥控器”（接口），这个遥控器上有个“开&#x2F;关”按钮。当你用这个遥控器对着电视机按“开&#x2F;关”，电视机就会打开或关闭；当你用同一个遥控器对着空调按“开&#x2F;关”，空调就会打开或关闭。遥控器本身并不知道它控制的是电视机还是空调，它只知道发出一个“开&#x2F;关”的指令。具体执行这个指令的是哪个设备，以及这个设备如何执行（电视机是点亮屏幕，空调是启动压缩机），是在运行时才决定的。</p><p>在 C++ 中，这个“遥控器”就是<strong>基类指针或引用</strong>，而“电视机”和“空调”就是<strong>派生类对象</strong>。</p><h2 id="C-中的多态分类"><a href="#C-中的多态分类" class="headerlink" title="C++ 中的多态分类"></a>C++ 中的多态分类</h2><p>C++ 中的多态主要分为两类：</p><ol><li><strong>静态多态（编译时多态）</strong>：在程序编译期间就已经确定了函数调用的地址。它的执行速度快，但灵活性稍差。</li><li><strong>动态多态（运行时多态）</strong>：在程序运行期间才能确定调用哪个函数。这是我们通常所说的 OOP 中的多态，它提供了极高的灵活性和可扩展性。</li></ol><hr><h3 id="一、-静态多态-Static-Polymorphism"><a href="#一、-静态多态-Static-Polymorphism" class="headerlink" title="一、 静态多态 (Static Polymorphism)"></a>一、 静态多态 (Static Polymorphism)</h3><p>静态多态主要通过<strong>函数重载</strong>和<strong>模板</strong>来实现。</p><h4 id="1-函数重载-Function-Overloading"><a href="#1-函数重载-Function-Overloading" class="headerlink" title="1. 函数重载 (Function Overloading)"></a>1. 函数重载 (Function Overloading)</h4><p>允许在同一个作用域内定义多个同名函数，但它们的参数列表（参数类型、参数个数或参数顺序）必须不同。编译器在编译时，会根据你传入的实参类型来决定调用哪个具体的函数版本。</p><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Printing an integer: &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">double</span> d)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Printing a double: &quot;</span> &lt;&lt; d &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> std::string&amp; s)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Printing a string: &quot;</span> &lt;&lt; s &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">10</span>);        <span class="comment">// 编译器在编译时就知道要调用 print(int)</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">3.14</span>);      <span class="comment">// 编译器在编译时就知道要调用 print(double)</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello&quot;</span>);   <span class="comment">// 编译器在编译时就知道要调用 print(const std::string&amp;)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-模板-Templates"><a href="#2-模板-Templates" class="headerlink" title="2. 模板 (Templates)"></a>2. 模板 (Templates)</h4><p>模板允许我们编写与类型无关的代码，也称为泛型编程。编译器会根据模板参数的实际类型，在编译时生成相应类型的函数或类。</p><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 编译器根据 int 生成一个 add(int, int) 版本</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Int sum: &quot;</span> &lt;&lt; <span class="built_in">add</span>(<span class="number">5</span>, <span class="number">10</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编译器根据 double 生成一个 add(double, double) 版本</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Double sum: &quot;</span> &lt;&lt; <span class="built_in">add</span>(<span class="number">3.5</span>, <span class="number">7.2</span>) &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// std::string 也重载了 + 操作符，所以也可以用</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;String concat: &quot;</span> &lt;&lt; <span class="built_in">add</span>(std::<span class="built_in">string</span>(<span class="string">&quot;hello &quot;</span>), std::<span class="built_in">string</span>(<span class="string">&quot;world&quot;</span>)) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>静态多态的特点：</strong></p><ul><li><strong>决策时机</strong>：编译时。</li><li><strong>绑定方式</strong>：静态绑定（Static Binding）或早绑定（Early Binding）。</li><li><strong>效率</strong>：高，因为没有运行时的额外开销。</li><li><strong>灵活性</strong>：相对较低，所有可能性都必须在编译时确定。</li></ul><hr><h3 id="二、-动态多态-Dynamic-Polymorphism"><a href="#二、-动态多态-Dynamic-Polymorphism" class="headerlink" title="二、 动态多态 (Dynamic Polymorphism)"></a>二、 动态多态 (Dynamic Polymorphism)</h3><p>这是 C++ 多态的核心。它依赖于<strong>继承</strong>、<strong>虚函数 (Virtual Functions)</strong> 和<strong>基类指针&#x2F;引用</strong>。</p><h4 id="实现动态多态的三个条件"><a href="#实现动态多态的三个条件" class="headerlink" title="实现动态多态的三个条件"></a>实现动态多态的三个条件</h4><ol><li><strong>继承关系</strong>：必须存在一个基类和至少一个派生类。</li><li><strong>虚函数</strong>：基类中必须有虚函数（使用 <code>virtual</code> 关键字声明），并且派生类需要重写（Override）这个函数。</li><li><strong>基类指针或引用</strong>：必须通过指向派生类对象的基类指针或引用来调用虚函数。</li></ol><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><p>让我们通过一个经典的 <code>Animal</code> 例子来理解。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 基类 Animal</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 2. 声明虚函数 makeSound</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">makeSound</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Some generic animal sound...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 关键！当基类指针可能被用来删除派生类对象时，析构函数必须是虚函数</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Animal</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Animal destructor called.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类 Dog</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 重写（Override）基类的虚函数</span></span><br><span class="line">    <span class="comment">// &#x27;override&#x27; 关键字是 C++11 引入的，它不是必须的，但强烈推荐使用</span></span><br><span class="line">    <span class="comment">// 它可以让编译器检查你是否真的重写了基类的虚函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">makeSound</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Woof! Woof!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~<span class="built_in">Dog</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Dog destructor called.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类 Cat</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">makeSound</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Meow! Meow!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~<span class="built_in">Cat</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Cat destructor called.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">performSound</span><span class="params">(<span class="type">const</span> Animal&amp; animal)</span> </span>&#123;</span><br><span class="line">    animal.<span class="built_in">makeSound</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Dog myDog;</span><br><span class="line">    Cat myCat;</span><br><span class="line">    Animal myAnimal;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 通过基类引用调用</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;--- Calling via reference ---&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">performSound</span>(myDog);    <span class="comment">// 运行时，系统发现 animal 引用的是一个 Dog 对象，调用 Dog::makeSound()</span></span><br><span class="line">    <span class="built_in">performSound</span>(myCat);    <span class="comment">// 运行时，系统发现 animal 引用的是一个 Cat 对象，调用 Cat::makeSound()</span></span><br><span class="line">    <span class="built_in">performSound</span>(myAnimal); <span class="comment">// 运行时，系统发现 animal 引用的是一个 Animal 对象，调用 Animal::makeSound()</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n--- Calling via pointer ---&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 3. 通过基类指针调用</span></span><br><span class="line">    Animal* animalPtr = <span class="keyword">new</span> <span class="built_in">Dog</span>(); <span class="comment">// 基类指针指向派生类对象</span></span><br><span class="line">    animalPtr-&gt;<span class="built_in">makeSound</span>();        <span class="comment">// 运行时，系统发现 animalPtr 指向的是一个 Dog 对象，调用 Dog::makeSound()</span></span><br><span class="line">    <span class="keyword">delete</span> animalPtr;              <span class="comment">// 因为析构函数是虚函数，会先调用 Dog 的析构，再调用 Animal 的析构</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    animalPtr = <span class="keyword">new</span> <span class="built_in">Cat</span>();</span><br><span class="line">    animalPtr-&gt;<span class="built_in">makeSound</span>();        <span class="comment">// 运行时，系统发现 animalPtr 指向的是一个 Cat 对象，调用 Cat::makeSound()</span></span><br><span class="line">    <span class="keyword">delete</span> animalPtr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>main</code> 函数中，<code>animalPtr</code> 的类型是 <code>Animal*</code>，但它实际指向的对象的类型在运行时是可变的（<code>Dog</code> 或 <code>Cat</code>）。当你调用 <code>animalPtr-&gt;makeSound()</code> 时，程序并不会调用 <code>Animal::makeSound()</code>，而是会根据 <code>animalPtr</code> 当前实际指向的对象类型，去调用该类型对应的 <code>makeSound()</code> 版本。这个过程就叫做<strong>动态绑定 (Dynamic Binding)</strong> 或<strong>晚绑定 (Late Binding)</strong>。</p><h3 id="动态多态的底层实现原理：虚函数表-v-table"><a href="#动态多态的底层实现原理：虚函数表-v-table" class="headerlink" title="动态多态的底层实现原理：虚函数表 (v-table)"></a>动态多态的底层实现原理：虚函数表 (v-table)</h3><p>C++ 编译器是如何实现动态绑定的呢？答案是<strong>虚函数表（Virtual Function Table, 简称 v-table）<strong>和</strong>虚函数指针（Virtual Function Pointer, 简称 v-ptr）</strong>。</p><ol><li><p><strong>虚函数表 (v-table)</strong>：</p><ul><li>当一个类中包含至少一个虚函数时，编译器会为这个<strong>类</strong>创建一个静态的数组，这个数组就是虚函数表（v-table）。</li><li>v-table 中存放的是该类所有虚函数的地址。</li><li>如果派生类重写了基类的虚函数，那么在派生类的 v-table 中，相应的位置会被替换为派生类重写的那个函数的地址。如果派生类没有重写，那么它将继承基类 v-table 中的函数地址。</li><li><strong>每个拥有虚函数的类只有一张 v-table</strong>。</li></ul></li><li><p><strong>虚函数指针 (v-ptr)</strong>：</p><ul><li>当一个类的对象被创建时，如果这个类有虚函数（或继承了虚函数），编译器会在这个<strong>对象</strong>的内存布局的起始位置（通常是这样，但具体位置由编译器决定）偷偷地插入一个指针。</li><li>这个指针就是虚函数指针（v-ptr），它指向该对象所属类的 v-table。</li><li><strong>每个对象实例里面都包含一个 v-ptr</strong>。</li></ul></li></ol><h4 id="调用过程剖析"><a href="#调用过程剖析" class="headerlink" title="调用过程剖析"></a>调用过程剖析</h4><p>让我们以上面的 <code>animalPtr-&gt;makeSound()</code> 为例，看看运行时发生了什么：</p><ol><li><p><strong>创建对象</strong>：<code>animalPtr = new Dog();</code></p><ul><li>在堆上分配 <code>Dog</code> 对象的内存。</li><li>编译器在 <code>Dog</code> 对象的内存中放入一个 v-ptr。</li><li>这个 v-ptr 指向 <code>Dog</code> 类的 v-table。<code>Dog</code> 的 v-table 中包含了 <code>Dog::makeSound</code> 的地址。</li></ul></li><li><p><strong>调用虚函数</strong>：<code>animalPtr-&gt;makeSound();</code></p><ul><li>程序通过 <code>animalPtr</code> 访问它所指向的对象（那个 <code>Dog</code> 对象）。</li><li>通过对象内存中的 v-ptr 找到 <code>Dog</code> 类的 v-table。</li><li>在 v-table 中查找 <code>makeSound</code> 函数的地址（虚函数在 v-table 中的偏移量是固定的，在编译时就确定了）。</li><li>根据找到的地址，调用 <code>Dog::makeSound()</code> 函数。</li></ul></li></ol><p>整个过程可以简化为：<code>对象地址 -&gt; v-ptr -&gt; v-table -&gt; 虚函数地址 -&gt; 调用函数</code>。</p><p>这个通过指针间接查找函数地址的过程，虽然带来了一点点性能开销（一次指针跳转和一次数组索引），但它实现了在运行时根据对象的实际类型来调用正确函数的能力，这就是动态多态的精髓。</p><h3 id="为什么析构函数需要是虚函数？"><a href="#为什么析构函数需要是虚函数？" class="headerlink" title="为什么析构函数需要是虚函数？"></a>为什么析构函数需要是虚函数？</h3><p>这是一个非常重要的知识点。在上面的例子中，<code>Animal</code> 的析构函数被声明为 <code>virtual</code>。</p><p><strong>原因</strong>：考虑 <code>delete animalPtr;</code> 这行代码。<br><code>animalPtr</code> 的静态类型是 <code>Animal*</code>。如果析构函数不是虚函数，编译器会进行静态绑定，只会调用 <code>Animal</code> 的析构函数 <code>~Animal()</code>。这会导致 <code>animalPtr</code> 指向的 <code>Dog</code> 对象部分没有被正确析构（<code>~Dog()</code> 不会被调用），从而造成<strong>内存泄漏</strong>或<strong>资源泄漏</strong>。</p><p>当析构函数是虚函数时，<code>delete</code> 操作也会通过 v-table 进行动态绑定。系统会发现 <code>animalPtr</code> 实际指向 <code>Dog</code> 对象，于是：</p><ol><li>调用 <code>Dog</code> 的析构函数 <code>~Dog()</code>。</li><li><code>Dog</code> 的析构函数执行完毕后，会自动调用其基类 <code>Animal</code> 的析构函数 <code>~Animal()</code>。</li></ol><p>这样就保证了从派生类到基类的完整析构链，避免了内存泄漏。</p><p><strong>黄金法则</strong>：<strong>如果一个类可能被用作基类，并且你可能会通过基类指针删除派生类的对象，那么它的析构函数必须是虚函数。</strong></p><h3 id="纯虚函数与抽象类"><a href="#纯虚函数与抽象类" class="headerlink" title="纯虚函数与抽象类"></a>纯虚函数与抽象类</h3><ul><li><strong>纯虚函数 (Pure Virtual Function)</strong>：一个没有实现的虚函数，其声明方式是在函数末尾加上 <code>= 0</code>。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>; <span class="comment">// 纯虚函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><strong>抽象类 (Abstract Class)</strong>：包含至少一个纯虚函数的类。<ul><li>抽象类<strong>不能被实例化</strong>（不能创建对象）。</li><li>它主要用作接口，强制所有派生类必须提供纯虚函数的具体实现。如果派生类没有实现所有纯虚函数，那么这个派生类也仍然是抽象类。</li></ul></li></ul><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">getArea</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>; <span class="comment">// 纯虚函数，定义接口</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Shape</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> radius;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Circle</span>(<span class="type">double</span> r) : <span class="built_in">radius</span>(r) &#123;&#125;</span><br><span class="line">    <span class="comment">// 必须实现 getArea()</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">getArea</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3.14159</span> * radius * radius;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Shape* s = new Shape(); // 错误！不能实例化抽象类</span></span><br><span class="line">Shape* c = <span class="keyword">new</span> <span class="built_in">Circle</span>(<span class="number">10.0</span>); <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><table><thead><tr><th align="left">特性</th><th align="left">静态多态 (编译时)</th><th align="left">动态多态 (运行时)</th></tr></thead><tbody><tr><td align="left"><strong>实现方式</strong></td><td align="left">函数重载、模板</td><td align="left">继承、虚函数、基类指针&#x2F;引用</td></tr><tr><td align="left"><strong>绑定时机</strong></td><td align="left">编译时（静态绑定&#x2F;早绑定）</td><td align="left">运行时（动态绑定&#x2F;晚绑定）</td></tr><tr><td align="left"><strong>底层机制</strong></td><td align="left">编译器根据参数类型决定调用</td><td align="left">虚函数表 (v-table) 和虚函数指针 (v-ptr)</td></tr><tr><td align="left"><strong>性能</strong></td><td align="left">速度快，无运行时开销</td><td align="left">稍慢，有一次间接寻址的开销</td></tr><tr><td align="left"><strong>灵活性</strong></td><td align="left">较低，编译时已确定</td><td align="left">极高，允许在运行时处理未知类型的对象</td></tr><tr><td align="left"><strong>典型应用</strong></td><td align="left">泛型编程（如STL）、数值计算</td><td align="left">基于接口的编程、插件系统、UI框架等</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CPP学习笔记—四种强制类型转换</title>
      <link href="/2025/08/27/CPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E5%9B%9B%E7%A7%8D%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
      <url>/2025/08/27/CPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E5%9B%9B%E7%A7%8D%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<p>C++中的四种强制类型转换：<code>static_cast</code>、<code>dynamic_cast</code>、<code>const_cast</code> 和 <code>reinterpret_cast</code>。</p><h3 id="为什么需要新的类型转换？"><a href="#为什么需要新的类型转换？" class="headerlink" title="为什么需要新的类型转换？"></a>为什么需要新的类型转换？</h3><p>在C++之前，C语言使用一种通用的强制类型转换语法，例如 <code>(new_type)expression</code> 或 <code>new_type(expression)</code>。这种C风格的转换方式存在几个问题：</p><ol><li><strong>过于粗暴</strong>：它可以在任何类型之间进行转换，无论是相关的还是不相关的，这使得它非常不安全。</li><li><strong>意图不明</strong>：从语法上无法清晰地看出程序员想要做什么样的转换（例如，是移除const、进行继承体系中的转换，还是进行底层的位模式重新解释）。</li><li><strong>难以搜索</strong>：在代码库中搜索 <code>(</code> 符号来定位所有的类型转换是非常困难的，不利于代码审查和维护。</li></ol><p>为了解决这些问题，C++引入了四个功能更明确、更安全的命名转换操作符。它们让代码的意图更加清晰，并允许编译器进行更严格的检查。</p><hr><h3 id="1-static-cast"><a href="#1-static-cast" class="headerlink" title="1. static_cast"></a>1. <code>static_cast</code></h3><p><code>static_cast</code> 是最常用、最“温和”的类型转换，它的转换在<strong>编译时</strong>进行检查。它主要用于处理那些编译器认为“合理”或“有道理”的类型转换。</p><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">static_cast</span>&lt;new_type&gt;(expression);</span><br></pre></td></tr></table></figure><h4 id="使用场合"><a href="#使用场合" class="headerlink" title="使用场合"></a>使用场合</h4><ol><li><p><strong>相关类型间的转换（继承体系中）</strong></p><ul><li><strong>上行转换（Upcasting）</strong>：将派生类的指针或引用转换为基类的指针或引用。这是安全的，因为派生类对象本身就是一个基类对象。虽然通常是隐式进行的，但显式使用 <code>static_cast</code> 可以让代码意图更明确。</li><li><strong>下行转换（Downcasting）</strong>：将基类的指针或引用转换为派生类的指针或引用。<strong>这是不安全的</strong>，因为它不进行运行时检查。程序员必须自己保证这个转换是有效的（即基类指针确实指向一个派生类对象）。如果转换无效，将导致未定义行为（Undefined Behavior）。</li></ul></li><li><p><strong>基本数据类型之间的转换</strong></p><ul><li>例如，<code>int</code> 转 <code>double</code>，<code>char</code> 转 <code>int</code> 等。这和C风格的转换效果类似，但更具可读性。</li></ul></li><li><p><strong>空指针 <code>void*</code> 与其他类型指针之间的转换</strong></p><ul><li>将任何类型的指针转换为 <code>void*</code> 是安全的。</li><li>将 <code>void*</code> 转换回原始类型的指针也是可以的，但程序员需要确保转换的类型是正确的。</li></ul></li><li><p><strong>枚举类型与整型之间的转换</strong></p><ul><li>将枚举值转换为整型，或将整型转换为枚举类型。</li></ul></li></ol><h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 继承体系中的转换</span></span><br><span class="line">    Derived d;</span><br><span class="line">    Base* pb = &amp;d; <span class="comment">// 隐式上行转换</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显式上行转换 (安全)</span></span><br><span class="line">    Base* pb_static = <span class="built_in">static_cast</span>&lt;Base*&gt;(&amp;d); </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不安全的下行转换 (程序员保证其正确性)</span></span><br><span class="line">    Derived* pd_static = <span class="built_in">static_cast</span>&lt;Derived*&gt;(pb); </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 基本数据类型转换</span></span><br><span class="line">    <span class="type">double</span> pi = <span class="number">3.14159</span>;</span><br><span class="line">    <span class="type">int</span> truncated_pi = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(pi); <span class="comment">// truncated_pi 的值为 3</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Truncated Pi: &quot;</span> &lt;&lt; truncated_pi &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. void* 指针转换</span></span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">void</span>* p_void = <span class="built_in">static_cast</span>&lt;<span class="type">void</span>*&gt;(&amp;a);</span><br><span class="line">    <span class="type">int</span>* p_int = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>*&gt;(p_void);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value from void*: &quot;</span> &lt;&lt; *p_int &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="2-dynamic-cast"><a href="#2-dynamic-cast" class="headerlink" title="2. dynamic_cast"></a>2. <code>dynamic_cast</code></h3><p><code>dynamic_cast</code> 是专门用于处理<strong>多态类型</strong>的转换，它在<strong>运行时</strong>进行类型检查，因此具有一定的性能开销。</p><h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dynamic_cast</span>&lt;new_type&gt;(expression);</span><br></pre></td></tr></table></figure><h4 id="关键要求"><a href="#关键要求" class="headerlink" title="关键要求"></a>关键要求</h4><ul><li>只能用于包含虚函数（virtual function）的类（即多态类），因为运行时类型信息（RTTI）是存储在虚函数表（vtable）中的。</li><li>只能用于指针或引用类型的转换。</li></ul><h4 id="使用场合-1"><a href="#使用场合-1" class="headerlink" title="使用场合"></a>使用场合</h4><ol><li><strong>安全的下行转换（Safe Downcasting）</strong><ul><li>这是 <code>dynamic_cast</code> 最核心的用途。当你有一个基类指针或引用，但不确定它实际指向的是哪个派生类对象时，可以使用 <code>dynamic_cast</code> 来安全地尝试转换。</li><li><strong>对于指针</strong>：如果转换成功，它会返回一个指向派生类对象的有效指针；如果转换失败（即基类指针并未指向目标派生类对象），它会返回 <code>nullptr</code>。</li><li><strong>对于引用</strong>：如果转换成功，它会返回一个指向派生类对象的引用；如果转换失败，它会抛出一个 <code>std::bad_cast</code> 异常。</li></ul></li></ol><h4 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123;&#125; <span class="comment">// 必须有虚函数才能使用 dynamic_cast</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived1</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">derived1_func</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Called Derived1 function.\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived2</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">derived2_func</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Called Derived2 function.\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(Base* ptr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 尝试转换为 Derived1 指针</span></span><br><span class="line">    <span class="keyword">if</span> (Derived1* d1 = <span class="built_in">dynamic_cast</span>&lt;Derived1*&gt;(ptr)) &#123;</span><br><span class="line">        d1-&gt;<span class="built_in">derived1_func</span>();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 尝试转换为 Derived2 指针</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (Derived2* d2 = <span class="built_in">dynamic_cast</span>&lt;Derived2*&gt;(ptr)) &#123;</span><br><span class="line">        d2-&gt;<span class="built_in">derived2_func</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Unknown derived type.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* b1 = <span class="keyword">new</span> <span class="built_in">Derived1</span>();</span><br><span class="line">    Base* b2 = <span class="keyword">new</span> <span class="built_in">Derived2</span>();</span><br><span class="line">    Base* b3 = <span class="keyword">new</span> <span class="built_in">Base</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">process</span>(b1); <span class="comment">// 输出: Called Derived1 function.</span></span><br><span class="line">    <span class="built_in">process</span>(b2); <span class="comment">// 输出: Called Derived2 function.</span></span><br><span class="line">    <span class="built_in">process</span>(b3); <span class="comment">// 输出: Unknown derived type.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> b1;</span><br><span class="line">    <span class="keyword">delete</span> b2;</span><br><span class="line">    <span class="keyword">delete</span> b3;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="3-const-cast"><a href="#3-const-cast" class="headerlink" title="3. const_cast"></a>3. <code>const_cast</code></h3><p><code>const_cast</code> 是四种转换中唯一一个能改变 <strong>常量性（const）</strong> 或 <strong>易变性（volatile）</strong> 的。它不能改变变量的类型。</p><h4 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">const_cast</span>&lt;new_type&gt;(expression);</span><br></pre></td></tr></table></figure><h4 id="使用场合-2"><a href="#使用场合-2" class="headerlink" title="使用场合"></a>使用场合</h4><ol><li><strong>移除 <code>const</code> 属性</strong><ul><li>最常见的场景是当你需要调用一个非 <code>const</code> 成员函数或一个接受非 <code>const</code> 参数的函数，但你手中只有一个 <code>const</code> 对象、指针或引用。</li><li><strong>警告</strong>：如果你对一个本身被定义为 <code>const</code> 的对象使用 <code>const_cast</code> 并尝试修改它，结果是<strong>未定义行为</strong>。<code>const_cast</code> 的安全使用前提是，被转换的对象本身不是 <code>const</code> 的。</li></ul></li></ol><h4 id="代码示例-2"><a href="#代码示例-2" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个老旧的 C-style API，它接受 char* 但保证不修改内容</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">legacy_c_api</span><span class="params">(<span class="type">char</span>* str)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Legacy API received: &quot;</span> &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> std::string my_str = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// my_str.c_str() 返回 const char*，但 legacy_c_api 需要 char*</span></span><br><span class="line">    <span class="comment">// 我们知道这个 API 不会修改数据，所以可以安全地使用 const_cast</span></span><br><span class="line">    <span class="built_in">legacy_c_api</span>(<span class="built_in">const_cast</span>&lt;<span class="type">char</span>*&gt;(my_str.<span class="built_in">c_str</span>()));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 危险的用法示例</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> val = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span>* ptr = <span class="built_in">const_cast</span>&lt;<span class="type">int</span>*&gt;(&amp;val);</span><br><span class="line">    <span class="comment">// *ptr = 20; // ！！！未定义行为 (UB)！val 本身是 const 的</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> non_const_val = <span class="number">20</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>* const_ptr = &amp;non_const_val;</span><br><span class="line">    <span class="type">int</span>* modifiable_ptr = <span class="built_in">const_cast</span>&lt;<span class="type">int</span>*&gt;(const_ptr);</span><br><span class="line">    *modifiable_ptr = <span class="number">30</span>; <span class="comment">// 这是安全的，因为 non_const_val 本身不是 const</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;non_const_val is now: &quot;</span> &lt;&lt; non_const_val &lt;&lt; std::endl; <span class="comment">// 输出 30</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="4-reinterpret-cast"><a href="#4-reinterpret-cast" class="headerlink" title="4. reinterpret_cast"></a>4. <code>reinterpret_cast</code></h3><p><code>reinterpret_cast</code> 是最强大、最危险的类型转换。它执行的是底层的、与实现相关的位模式重新解释，基本上是告诉编译器：“别管类型系统了，就当这块内存是另一种类型”。</p><h4 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">reinterpret_cast</span>&lt;new_type&gt;(expression);</span><br></pre></td></tr></table></figure><h4 id="使用场合-3"><a href="#使用场合-3" class="headerlink" title="使用场合"></a>使用场合</h4><p><code>reinterpret_cast</code> 的使用场景非常有限，通常只在低级编程中出现。</p><ol><li><p><strong>指针与整型之间的转换</strong></p><ul><li>将指针地址存为一个整数，或者将一个整数地址恢复为指针。这在某些需要序列化指针或与硬件交互的场景中有用。</li></ul></li><li><p><strong>不相关类型指针之间的转换</strong></p><ul><li>例如，将 <code>int*</code> 转换为 <code>char*</code> 以便按字节访问一个整数，或者在自定义内存分配器等场景中进行转换。</li><li>这种转换完全绕过了类型系统，极易出错。</li></ul></li><li><p><strong>函数指针的转换</strong></p><ul><li>在不同类型的函数指针之间进行转换，但调用转换后的函数指针可能导致未定义行为。</li></ul></li></ol><h4 id="代码示例-3"><a href="#代码示例-3" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdint&gt;</span> <span class="comment">// for uintptr_t</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">65</span>; <span class="comment">// ASCII &#x27;A&#x27;</span></span><br><span class="line">    <span class="type">int</span>* p_int = &amp;i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 将 int* 转换为 char*，按字节查看 int</span></span><br><span class="line">    <span class="type">char</span>* p_char = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span>*&gt;(p_int);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;First byte of int &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; is: &quot;</span> &lt;&lt; *p_char &lt;&lt; std::endl; <span class="comment">// 在小端系统上会输出 &#x27;A&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 指针与整型之间的转换</span></span><br><span class="line">    <span class="type">uintptr_t</span> addr = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(p_int);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Address as integer: &quot;</span> &lt;&lt; std::hex &lt;&lt; addr &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>* p_int_restored = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">int</span>*&gt;(addr);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value from restored pointer: &quot;</span> &lt;&lt; std::dec &lt;&lt; *p_int_restored &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>警告</strong>：<code>reinterpret_cast</code> 是不可移植的，其行为依赖于具体的编译器和平台。应尽可能避免使用它。</p><hr><h3 id="上行转换-Upcasting"><a href="#上行转换-Upcasting" class="headerlink" title="上行转换 (Upcasting)"></a>上行转换 (Upcasting)</h3><h4 id="1-什么是上行转换？"><a href="#1-什么是上行转换？" class="headerlink" title="1. 什么是上行转换？"></a>1. 什么是上行转换？</h4><p>上行转换是指将一个<strong>派生类（Derived Class）<strong>的指针或引用转换为其</strong>基类（Base Class）<strong>的指针或引用。这个转换是沿着继承层次结构</strong>向上</strong>的，所以称为“上行”。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : <span class="keyword">public</span> Animal &#123;&#125;;</span><br><span class="line"></span><br><span class="line">Dog myDog;</span><br><span class="line">Animal&amp; animalRef = myDog;         <span class="comment">// 上行转换 (引用)</span></span><br><span class="line">Animal* animalPtr = &amp;myDog;        <span class="comment">// 上行转换 (指针)</span></span><br></pre></td></tr></table></figure><h4 id="2-为什么是安全的？"><a href="#2-为什么是安全的？" class="headerlink" title="2. 为什么是安全的？"></a>2. 为什么是安全的？</h4><p>上行转换是<strong>绝对安全</strong>的，并且通常是<strong>隐式进行</strong>的，不需要显式使用强制类型转换。</p><p>这是基于 <strong>“is-a”</strong>（是一个）的继承关系。派生类对象包含了基类的所有成员和方法，因此一个派生类对象 <em>本身就是</em> 一个基类对象。当我们将 <code>Dog*</code> 转换为 <code>Animal*</code> 时，我们只是限制了我们的“视野”，让我们只能通过这个 <code>Animal*</code> 指针访问 <code>Animal</code> 类中定义的成员。我们不会访问到任何不存在的东西。</p><h4 id="3-应用场景在哪里？"><a href="#3-应用场景在哪里？" class="headerlink" title="3. 应用场景在哪里？"></a>3. 应用场景在哪里？</h4><p>上行转换是实现<strong>多态</strong>的核心。没有上行转换，多态几乎无法工作。</p><p><strong>主要应用场景：实现多态和代码复用</strong></p><p>假设我们有一个动物园，里面有各种动物，它们都会叫，但叫声不同。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">makeSound</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Some generic animal sound...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Animal</span>() &#123;&#125; <span class="comment">// 多态基类需要虚析构函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">makeSound</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Woof! Woof!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">makeSound</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Meow!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个函数接受任何 Animal 类型的引用，实现了代码复用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">make_animal_speak</span><span class="params">(<span class="type">const</span> Animal&amp; animal)</span> </span>&#123;</span><br><span class="line">    animal.<span class="built_in">makeSound</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Dog myDog;</span><br><span class="line">    Cat myCat;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 场景1: 函数参数多态</span></span><br><span class="line">    <span class="comment">// 这里发生了隐式的上行转换，myDog 和 myCat 被当做 Animal 对待</span></span><br><span class="line">    <span class="built_in">make_animal_speak</span>(myDog); <span class="comment">// 输出: Woof! Woof!</span></span><br><span class="line">    <span class="built_in">make_animal_speak</span>(myCat); <span class="comment">// 输出: Meow!</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 场景2: 容器多态</span></span><br><span class="line">    <span class="comment">// 使用一个基类指针的容器来管理所有派生类对象</span></span><br><span class="line">    std::vector&lt;std::unique_ptr&lt;Animal&gt;&gt; zoo;</span><br><span class="line">    zoo.<span class="built_in">push_back</span>(std::<span class="built_in">make_unique</span>&lt;Dog&gt;()); <span class="comment">// Dog* 隐式上行转换为 Animal*</span></span><br><span class="line">    zoo.<span class="built_in">push_back</span>(std::<span class="built_in">make_unique</span>&lt;Cat&gt;()); <span class="comment">// Cat* 隐式上行转换为 Animal*</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我们可以用统一的方式处理容器中所有不同类型的对象</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; animal : zoo) &#123;</span><br><span class="line">        animal-&gt;<span class="built_in">makeSound</span>(); <span class="comment">// 动态绑定，调用各自的 makeSound 版本</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结</strong>：上行转换让我们能够用一个通用的基类接口来处理所有不同的派生类对象，极大地提高了代码的灵活性和可扩展性。</p><hr><h3 id="下行转换-Downcasting"><a href="#下行转换-Downcasting" class="headerlink" title="下行转换 (Downcasting)"></a>下行转换 (Downcasting)</h3><h4 id="1-什么是下行转换？"><a href="#1-什么是下行转换？" class="headerlink" title="1. 什么是下行转换？"></a>1. 什么是下行转换？</h4><p>下行转换是指将一个<strong>基类（Base Class）<strong>的指针或引用转换为其</strong>派生类（Derived Class）<strong>的指针或引用。这个转换是沿着继承层次结构</strong>向下</strong>的，所以称为“下行”。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Animal* animalPtr = <span class="keyword">new</span> <span class="built_in">Dog</span>(); <span class="comment">// 指针实际指向一个 Dog 对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试将基类指针转换为派生类指针</span></span><br><span class="line">Dog* dogPtr = <span class="built_in">static_cast</span>&lt;Dog*&gt;(animalPtr); <span class="comment">// 不安全的下行转换</span></span><br><span class="line">Dog* dogPtr_safe = <span class="built_in">dynamic_cast</span>&lt;Dog*&gt;(animalPtr); <span class="comment">// 安全的下行转换</span></span><br></pre></td></tr></table></figure><h4 id="2-为什么是不安全的？"><a href="#2-为什么是不安全的？" class="headerlink" title="2. 为什么是不安全的？"></a>2. 为什么是不安全的？</h4><p>下行转换是<strong>不安全</strong>的，因为它无法在编译时保证转换的正确性。一个基类指针可能指向任何一个派生类对象，或者就是一个基类对象。如果你把它转换成一个错误的派生类类型，然后试图访问该派生类特有的成员，就会导致<strong>未定义行为（Undefined Behavior）</strong>，通常是程序崩溃。</p><p>这就是为什么C++提供了两种下行转换的方式：</p><ul><li><strong><code>static_cast</code>（不安全）</strong>：它在编译时进行转换，不进行任何运行时检查。它假设程序员已经100%确定这个转换是正确的。如果转换错误，后果自负。性能较高。</li><li><strong><code>dynamic_cast</code>（安全）</strong>：它在运行时进行检查，以确定转换是否有效。<ul><li>对于指针：如果转换成功，返回有效的派生类指针；如果失败（比如 <code>Animal*</code> 实际指向一个 <code>Cat</code> 对象，但你试图转为 <code>Dog*</code>），则返回 <code>nullptr</code>。</li><li>对于引用：如果转换成功，返回有效的派生类引用；如果失败，则抛出 <code>std::bad_cast</code> 异常。</li><li><strong>前提</strong>：<code>dynamic_cast</code> 只能用于带有虚函数的多态类。</li></ul></li></ul><h4 id="3-应用场景在哪里？-1"><a href="#3-应用场景在哪里？-1" class="headerlink" title="3. 应用场景在哪里？"></a>3. 应用场景在哪里？</h4><p>尽管我们应该尽量通过虚函数来避免下行转换，但在某些情况下它仍然是必要或方便的。</p><p><strong>主要应用场景：调用派生类特有的方法</strong></p><p>当你通过基类指针处理一组对象时，有时你需要判断某个对象是否是某个特定的派生类型，并调用它独有的方法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">makeSound</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">wagTail</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="comment">// 这是 Dog 特有的方法</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;The dog is wagging its tail.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">makeSound</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">purr</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="comment">// 这是 Cat 特有的方法</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;The cat is purring.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process_animal</span><span class="params">(Animal* animal)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!animal) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    animal-&gt;<span class="built_in">makeSound</span>(); <span class="comment">// 调用通用的多态方法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 现在，我们想调用派生类特有的方法</span></span><br><span class="line">    <span class="comment">// 使用安全的 dynamic_cast</span></span><br><span class="line">    <span class="keyword">if</span> (Dog* dog = <span class="built_in">dynamic_cast</span>&lt;Dog*&gt;(animal)) &#123;</span><br><span class="line">        dog-&gt;<span class="built_in">wagTail</span>(); <span class="comment">// 转换成功，可以安全调用</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (Cat* cat = <span class="built_in">dynamic_cast</span>&lt;Cat*&gt;(animal)) &#123;</span><br><span class="line">        cat-&gt;<span class="built_in">purr</span>(); <span class="comment">// 转换成功，可以安全调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::unique_ptr&lt;Animal&gt; myDog = std::<span class="built_in">make_unique</span>&lt;Dog&gt;();</span><br><span class="line">    std::unique_ptr&lt;Animal&gt; myCat = std::<span class="built_in">make_unique</span>&lt;Cat&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">process_animal</span>(myDog.<span class="built_in">get</span>());</span><br><span class="line">    <span class="comment">// 输出:</span></span><br><span class="line">    <span class="comment">// Woof! Woof!</span></span><br><span class="line">    <span class="comment">// The dog is wagging its tail.</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">process_animal</span>(myCat.<span class="built_in">get</span>());</span><br><span class="line">    <span class="comment">// 输出:</span></span><br><span class="line">    <span class="comment">// Meow!</span></span><br><span class="line">    <span class="comment">// The cat is purring.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结</strong>：当下多态接口无法满足需求，你必须访问派生类提供的特定功能时，就需要使用下行转换。在这种情况下，<strong>强烈推荐使用 <code>dynamic_cast</code></strong> 来保证类型安全。频繁使用下行转换有时也暗示着类的设计可能存在问题（比如，某些功能也许应该被提升到基类接口中）。</p><table><thead><tr><th align="left">特性</th><th align="left">上行转换 (Upcasting)</th><th align="left">下行转换 (Downcasting)</th></tr></thead><tbody><tr><td align="left"><strong>方向</strong></td><td align="left">派生类 → 基类</td><td align="left">基类 → 派生类</td></tr><tr><td align="left"><strong>安全性</strong></td><td align="left"><strong>总是安全的</strong></td><td align="left"><strong>本质上不安全</strong>，需要运行时检查</td></tr><tr><td align="left"><strong>转换方式</strong></td><td align="left">通常是<strong>隐式</strong>的，也可使用 <code>static_cast</code></td><td align="left">必须是<strong>显式</strong>的</td></tr><tr><td align="left"><strong>常用转换符</strong></td><td align="left">(隐式) 或 <code>static_cast</code></td><td align="left"><code>dynamic_cast</code> (安全) 或 <code>static_cast</code> (不安全)</td></tr><tr><td align="left"><strong>核心目的</strong></td><td align="left">实现<strong>多态</strong>，统一处理不同对象</td><td align="left">调用<strong>派生类特有</strong>的功能</td></tr><tr><td align="left"><strong>设计思想</strong></td><td align="left">符合“is-a”关系，是良好设计的基石</td><td align="left">有时是必要的，但过多使用可能意味着设计缺陷</td></tr></tbody></table><hr><h3 id="总结与对比"><a href="#总结与对比" class="headerlink" title="总结与对比"></a>总结与对比</h3><table><thead><tr><th align="left">转换操作符</th><th align="left">主要用途</th><th align="left">检查时机</th><th align="left">安全性</th><th align="left">核心场景</th></tr></thead><tbody><tr><td align="left"><strong><code>static_cast</code></strong></td><td align="left">“合理的”类型转换</td><td align="left">编译时</td><td align="left">中等（下行转换不安全）</td><td align="left">基本类型转换、继承体系中的上&#x2F;下行转换（需程序员保证安全）</td></tr><tr><td align="left"><strong><code>dynamic_cast</code></strong></td><td align="left">多态类型安全的下行转换</td><td align="left">运行时</td><td align="left">高</td><td align="left">在继承体系中，安全地将基类指针&#x2F;引用转换为派生类指针&#x2F;引用</td></tr><tr><td align="left"><strong><code>const_cast</code></strong></td><td align="left">添加或移除 <code>const</code>&#x2F;<code>volatile</code></td><td align="left">编译时</td><td align="left">低（易导致UB）</td><td align="left">与不符合 <code>const</code> 规范的旧API交互</td></tr><tr><td align="left"><strong><code>reinterpret_cast</code></strong></td><td align="left">底层位模式重新解释</td><td align="left">编译时</td><td align="left">极低（非常危险）</td><td align="left">低级内存操作、指针与整数转换、不相关指针转换</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基本排序算法</title>
      <link href="/2025/08/22/%E5%9F%BA%E6%9C%AC%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2025/08/22/%E5%9F%BA%E6%9C%AC%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="一、冒泡排序"><a href="#一、冒泡排序" class="headerlink" title="一、冒泡排序"></a>一、冒泡排序</h2><h3 id="1-什么是冒泡排序？"><a href="#1-什么是冒泡排序？" class="headerlink" title="1. 什么是冒泡排序？"></a>1. 什么是冒泡排序？</h3><p>冒泡排序（Bubble Sort）是一种简单直观的排序算法。它得名于其工作方式，即较小（或较大）的元素会像水中的气泡一样，通过不断交换，慢慢“浮”到数列的顶端。</p><h4 id="a-核心思想"><a href="#a-核心思想" class="headerlink" title="a. 核心思想"></a>a. 核心思想</h4><p>它重复地遍历待排序的数列，一次比较两个相邻的元素，如果它们的顺序（如从大到小或从小到大）错误就把它们交换过来。遍历数列的工作会重复地进行，直到没有再需要交换的元素为止，这意味着整个数列已经排序完成。</p><h4 id="b-工作原理"><a href="#b-工作原理" class="headerlink" title="b. 工作原理"></a>b. 工作原理</h4><ol><li><strong>比较相邻元素</strong>：从列表的第一个元素开始，比较它和下一个元素。</li><li><strong>交换</strong>：如果第一个元素比第二个元素大（以升序为例），就交换它们的位置。</li><li><strong>向后移动</strong>：继续比较下一对相邻的元素（即新的第二个和第三个元素），重复步骤2。</li><li><strong>完成一轮</strong>：持续这个过程，直到列表的末尾。经过第一轮遍历后，最大的元素会被放置在列表的最后一个位置。</li><li><strong>重复</strong>：对除了最后一个元素之外的所有元素，重复以上步骤。每一轮遍历都会将当前未排序部分的最大元素放到其最终位置。</li><li><strong>终止</strong>：当某一轮遍历中没有发生任何交换时，说明列表已经完全排序，可以提前终止算法。</li></ol><h3 id="2-图解示例"><a href="#2-图解示例" class="headerlink" title="2. 图解示例"></a>2. 图解示例</h3><p>让我们用一个简单的例子 <code>[5, 1, 4, 2, 8]</code> 来演示冒泡排序的过程（升序排列）。</p><p><strong>第一轮 (Pass 1):</strong></p><ul><li><code>(5, 1)</code>: 5 &gt; 1，交换 -&gt; <code>[1, 5, 4, 2, 8]</code></li><li><code>(5, 4)</code>: 5 &gt; 4，交换 -&gt; <code>[1, 4, 5, 2, 8]</code></li><li><code>(5, 2)</code>: 5 &gt; 2，交换 -&gt; <code>[1, 4, 2, 5, 8]</code></li><li><code>(5, 8)</code>: 5 &lt; 8，不交换 -&gt; <code>[1, 4, 2, 5, 8]</code></li><li><strong>结果</strong>: 经过第一轮，最大的元素 <code>8</code> 已经“冒泡”到了正确的位置。</li></ul><p><strong>第二轮 (Pass 2):</strong> (现在只需要处理前4个元素)</p><ul><li><code>(1, 4)</code>: 1 &lt; 4，不交换 -&gt; <code>[1, 4, 2, 5, 8]</code></li><li><code>(4, 2)</code>: 4 &gt; 2，交换 -&gt; <code>[1, 2, 4, 5, 8]</code></li><li><code>(4, 5)</code>: 4 &lt; 5，不交换 -&gt; <code>[1, 2, 4, 5, 8]</code></li><li><strong>结果</strong>: 第二大的元素 <code>5</code> 已经就位。</li></ul><p><strong>第三轮 (Pass 3):</strong> (现在只需要处理前3个元素)</p><ul><li><code>(1, 2)</code>: 1 &lt; 2，不交换 -&gt; <code>[1, 2, 4, 5, 8]</code></li><li><code>(2, 4)</code>: 2 &lt; 4，不交换 -&gt; <code>[1, 2, 4, 5, 8]</code></li><li><strong>结果</strong>: 此时，我们发现这一轮没有发生任何交换。这意味着列表已经排好序了，可以提前结束。</li></ul><p>最终排序结果: <code>[1, 2, 4, 5, 8]</code></p><h3 id="3-Python-代码实现"><a href="#3-Python-代码实现" class="headerlink" title="3. Python 代码实现"></a>3. Python 代码实现</h3><p>下面提供了两种 Python 实现：一个基础版本和一个优化版本。</p><h4 id="a-基础版冒泡排序"><a href="#a-基础版冒泡排序" class="headerlink" title="a. 基础版冒泡排序"></a>a. 基础版冒泡排序</h4><p>这个版本直接翻译了冒泡排序的基本思想，即使列表已经排好序，它也会完成所有的循环。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bubble_sort_basic</span>(<span class="params">arr</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    基础版冒泡排序</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    n = <span class="built_in">len</span>(arr)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 外层循环决定了需要进行多少轮“冒泡”</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="comment"># 内层循环负责每一轮的比较和交换</span></span><br><span class="line">        <span class="comment"># -i 是因为每轮过后，末尾的 i 个元素已经是有序的了，无需再比较</span></span><br><span class="line">        <span class="comment"># -1 是因为我们要比较 arr[j] 和 arr[j+1]，防止索引越界</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, n - i - <span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 如果前一个元素大于后一个元素（升序排列），则交换</span></span><br><span class="line">            <span class="keyword">if</span> arr[j] &gt; arr[j + <span class="number">1</span>]:</span><br><span class="line">                arr[j], arr[j + <span class="number">1</span>] = arr[j + <span class="number">1</span>], arr[j] <span class="comment"># Pythonic 的交换方式</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 示例 ---</span></span><br><span class="line">my_list = [<span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">8</span>]</span><br><span class="line">bubble_sort_basic(my_list)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;基础版排序后的列表:&quot;</span>, my_list)  <span class="comment"># 输出: [1, 2, 4, 5, 8]</span></span><br><span class="line"></span><br><span class="line">another_list = [<span class="number">64</span>, <span class="number">34</span>, <span class="number">25</span>, <span class="number">12</span>, <span class="number">22</span>, <span class="number">11</span>, <span class="number">90</span>]</span><br><span class="line">bubble_sort_basic(another_list)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;基础版排序后的列表:&quot;</span>, another_list) <span class="comment"># 输出: [11, 12, 22, 25, 34, 64, 90]</span></span><br></pre></td></tr></table></figure><h4 id="b-优化版冒泡排序"><a href="#b-优化版冒泡排序" class="headerlink" title="b. 优化版冒泡排序"></a>b. 优化版冒泡排序</h4><p>如果在某一轮遍历中，一次交换都没有发生，这说明整个列表已经是有序的了。我们可以利用这一点来提前结束排序，从而提高效率。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bubble_sort_optimized</span>(<span class="params">arr</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    优化版冒泡排序</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    n = <span class="built_in">len</span>(arr)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 外层循环</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="comment"># 设置一个标志位，用于检查本轮是否发生了交换</span></span><br><span class="line">        swapped = <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 内层循环</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, n - i - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> arr[j] &gt; arr[j + <span class="number">1</span>]:</span><br><span class="line">                arr[j], arr[j + <span class="number">1</span>] = arr[j + <span class="number">1</span>], arr[j]</span><br><span class="line">                <span class="comment"># 只要发生了一次交换，就将标志位设为 True</span></span><br><span class="line">                swapped = <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 如果在一整轮的比较中都没有发生交换，说明列表已经有序</span></span><br><span class="line">        <span class="comment"># 此时可以提前退出循环</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> swapped:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 示例 ---</span></span><br><span class="line">my_list_opt = [<span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">8</span>]</span><br><span class="line">bubble_sort_optimized(my_list_opt)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;优化版排序后的列表:&quot;</span>, my_list_opt)  <span class="comment"># 输出: [1, 2, 4, 5, 8]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对于一个几乎有序的列表，优化效果会很明显</span></span><br><span class="line">nearly_sorted_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">bubble_sort_optimized(nearly_sorted_list)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;优化版排序后的列表:&quot;</span>, nearly_sorted_list) <span class="comment"># 输出: [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure><h3 id="4-算法分析"><a href="#4-算法分析" class="headerlink" title="4. 算法分析"></a>4. 算法分析</h3><ul><li><p><strong>时间复杂度</strong>:</p><ul><li><strong>最坏情况</strong>: <code>O(n²)</code>。当待排序列表是完全逆序时，需要进行 n*(n-1)&#x2F;2 次比较和交换。</li><li><strong>平均情况</strong>: <code>O(n²)</code>。</li><li><strong>最好情况</strong>: <code>O(n)</code>。当列表已经是有序的时，对于优化版的冒泡排序，只需要进行一轮遍历（n-1次比较）而没有任何交换，即可确定列表已有序并终止。</li></ul></li><li><p><strong>空间复杂度</strong>: <code>O(1)</code>。冒泡排序是<strong>原地排序</strong>算法，因为它只需要一个额外的临时变量来进行元素交换，所需空间是常数级别的。</p></li><li><p><strong>稳定性</strong>: 冒泡排序是<strong>稳定</strong>的。因为只有当 <code>arr[j] &gt; arr[j+1]</code> 时才会交换，相等的值不会改变它们的相对顺序。</p></li></ul><h3 id="5-小结"><a href="#5-小结" class="headerlink" title="5. 小结"></a>5. 小结</h3><p><strong>优点</strong>:</p><ul><li><strong>实现简单</strong>：代码逻辑非常清晰，容易理解和实现。</li><li><strong>稳定性</strong>：是一种稳定的排序算法。</li><li><strong>空间效率高</strong>：是原地排序，不需要额外的存储空间。</li></ul><p><strong>缺点</strong>:</p><ul><li><strong>时间效率低</strong>：<code>O(n²)</code> 的时间复杂度使其在处理大规模数据时非常慢。</li></ul><p>因此，冒泡排序在实际应用中很少被使用，它更多地是作为一种教学工具，帮助初学者理解排序算法的基本思想。</p><hr><h2 id="二、选择排序"><a href="#二、选择排序" class="headerlink" title="二、选择排序"></a>二、选择排序</h2><h3 id="1-什么是选择排序？"><a href="#1-什么是选择排序？" class="headerlink" title="1. 什么是选择排序？"></a>1. 什么是选择排序？</h3><p>选择排序（Selection Sort）是另一种简单直观的排序算法。它的工作原理非常直接：首先在未排序的序列中找到最小（或最大）的元素，然后将它存放到排序序列的起始位置。接着，再从剩余未排序的元素中继续寻找最小（或最大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p><h4 id="a-核心思想-1"><a href="#a-核心思想-1" class="headerlink" title="a. 核心思想"></a>a. 核心思想</h4><p>算法将列表分为两个部分：</p><ol><li><strong>已排序部分</strong>：位于列表的前端。</li><li><strong>未排序部分</strong>：位于列表的后端。</li></ol><p>在每一轮迭代中，算法会从“未排序部分”中挑选出最小的元素，并将其与“未排序部分”的第一个元素交换位置。这样，已排序部分的长度就增加了一，而未排序部分的长度减少了一。</p><h4 id="b-工作原理-1"><a href="#b-工作原理-1" class="headerlink" title="b. 工作原理"></a>b. 工作原理</h4><ol><li><strong>找到最小值</strong>：从列表的第一个元素开始，遍历整个列表，找到最小元素的索引。</li><li><strong>交换</strong>：将找到的最小元素与列表的第一个元素进行交换。此时，第一个元素就是整个列表最小的，它现在属于“已排序部分”。</li><li><strong>缩小范围</strong>：从列表的第二个元素开始，重复以上过程（在剩余的“未排序部分”中找到最小值，并与该部分的第一个元素交换）。</li><li><strong>重复</strong>：持续这个过程，每次都将未排序部分的查找范围缩小一个元素。</li><li><strong>终止</strong>：当“未排序部分”只剩下一个元素时，整个列表就已经排序完成了。</li></ol><h3 id="2-图解示例-1"><a href="#2-图解示例-1" class="headerlink" title="2. 图解示例"></a>2. 图解示例</h3><p>我们还是用 <code>[5, 1, 4, 2, 8]</code> 这个例子来演示选择排序的过程（升序排列）。</p><p><strong>初始状态:</strong> <code>[5, 1, 4, 2, 8]</code> (整个列表都是未排序部分)</p><p><strong>第一轮 (Pass 1):</strong></p><ul><li><strong>查找范围</strong>: <code>[5, 1, 4, 2, 8]</code></li><li>在范围中找到的最小元素是 <code>1</code>。</li><li>将 <code>1</code> 与范围的第一个元素 <code>5</code> 交换。</li><li><strong>结果</strong>: <code>[1, 5, 4, 2, 8]</code></li><li><strong>已排序部分</strong>: <code>[1]</code></li></ul><p><strong>第二轮 (Pass 2):</strong></p><ul><li><strong>查找范围</strong>: <code>[5, 4, 2, 8]</code> (从第二个元素开始)</li><li>在范围中找到的最小元素是 <code>2</code>。</li><li>将 <code>2</code> 与范围的第一个元素 <code>5</code> 交换。</li><li><strong>结果</strong>: <code>[1, 2, 4, 5, 8]</code></li><li><strong>已排序部分</strong>: <code>[1, 2]</code></li></ul><p><strong>第三轮 (Pass 3):</strong></p><ul><li><strong>查找范围</strong>: <code>[4, 5, 8]</code> (从第三个元素开始)</li><li>在范围中找到的最小元素是 <code>4</code>。</li><li>它本身就是范围的第一个元素，所以和自己交换（无变化）。</li><li><strong>结果</strong>: <code>[1, 2, 4, 5, 8]</code></li><li><strong>已排序部分</strong>: <code>[1, 2, 4]</code></li></ul><p><strong>第四轮 (Pass 4):</strong></p><ul><li><strong>查找范围</strong>: <code>[5, 8]</code> (从第四个元素开始)</li><li>在范围中找到的最小元素是 <code>5</code>。</li><li>它本身就是范围的第一个元素，和自己交换（无变化）。</li><li><strong>结果</strong>: <code>[1, 2, 4, 5, 8]</code></li><li><strong>已排序部分</strong>: <code>[1, 2, 4, 5]</code></li></ul><p>此时，未排序部分只剩下 <code>[8]</code>，算法结束。</p><p>最终排序结果: <code>[1, 2, 4, 5, 8]</code></p><h3 id="3-Python-代码实现-1"><a href="#3-Python-代码实现-1" class="headerlink" title="3. Python 代码实现"></a>3. Python 代码实现</h3><p>下面是选择排序的 Python 代码实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">selection_sort</span>(<span class="params">arr</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    选择排序函数</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    n = <span class="built_in">len</span>(arr)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 遍历整个列表，i 是已排序部分的边界</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="comment"># 假设当前位置的元素是未排序部分中的最小元素</span></span><br><span class="line">        min_index = i</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 遍历 i 之后的所有元素，以找到真正的最小元素</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">if</span> arr[j] &lt; arr[min_index]:</span><br><span class="line">                min_index = j  <span class="comment"># 更新最小元素的索引</span></span><br><span class="line">                </span><br><span class="line">        <span class="comment"># 将找到的最小元素与当前位置 i 的元素进行交换</span></span><br><span class="line">        <span class="comment"># 如果 min_index 没有改变，就意味着当前元素已经是最小的，无需交换</span></span><br><span class="line">        <span class="keyword">if</span> min_index != i:</span><br><span class="line">            arr[i], arr[min_index] = arr[min_index], arr[i]</span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 示例 ---</span></span><br><span class="line">my_list = [<span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">8</span>]</span><br><span class="line">selection_sort(my_list)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;排序后的列表:&quot;</span>, my_list)  <span class="comment"># 输出: [1, 2, 4, 5, 8]</span></span><br><span class="line"></span><br><span class="line">another_list = [<span class="number">64</span>, <span class="number">34</span>, <span class="number">25</span>, <span class="number">12</span>, <span class="number">22</span>, <span class="number">11</span>, <span class="number">90</span>]</span><br><span class="line">selection_sort(another_list)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;排序后的列表:&quot;</span>, another_list) <span class="comment"># 输出: [11, 12, 22, 25, 34, 64, 90]</span></span><br></pre></td></tr></table></figure><h3 id="4-算法分析-1"><a href="#4-算法分析-1" class="headerlink" title="4. 算法分析"></a>4. 算法分析</h3><ul><li><p><strong>时间复杂度</strong>:</p><ul><li><strong>最坏情况</strong>: <code>O(n²)</code>。</li><li><strong>平均情况</strong>: <code>O(n²)</code>。</li><li><strong>最好情况</strong>: <code>O(n²)</code>。</li><li><strong>解释</strong>：无论输入数据是什么样的（即使是已经排好序的），选择排序的比较次数都是固定的。它有两层嵌套循环，外层循环 <code>n-1</code> 次，内层循环的比较次数是一个等差数列 <code>(n-1) + (n-2) + ... + 1</code>，总比较次数为 <code>n*(n-1)/2</code>。因此，其时间复杂度总是 <code>O(n²)</code>。</li></ul></li><li><p><strong>空间复杂度</strong>: <code>O(1)</code>。选择排序也是<strong>原地排序</strong>算法，只需要一个额外的变量 <code>min_index</code> 来存储索引，空间是常数级别的。</p></li><li><p><strong>稳定性</strong>: 选择排序是<strong>不稳定</strong>的。</p><ul><li><strong>解释</strong>：稳定性指相等的元素在排序后其相对位置保持不变。在选择排序中，交换操作可能会打乱相等元素的原始顺序。</li><li>例如，对于列表 <code>[5a, 8, 5b, 2]</code>（<code>5a</code> 和 <code>5b</code> 值相等，但我们用 a 和 b 区分它们），第一轮会找到 <code>2</code>，然后将 <code>5a</code> 和 <code>2</code> 交换，列表变为 <code>[2, 8, 5b, 5a]</code>。此时，<code>5b</code> 跑到了 <code>5a</code> 的前面，它们的相对顺序改变了。</li></ul></li></ul><h3 id="5-小结-1"><a href="#5-小结-1" class="headerlink" title="5. 小结"></a>5. 小结</h3><p><strong>优点</strong>:</p><ul><li><strong>实现简单</strong>：和冒泡排序一样，逻辑简单，易于理解。</li><li><strong>移动次数少</strong>：对于每个元素，最多只会进行一次交换。如果数据的交换成本（移动成本）远高于比较成本，选择排序会比冒泡排序更有优势。</li></ul><p><strong>缺点</strong>:</p><ul><li><strong>时间效率低</strong>：<code>O(n²)</code> 的时间复杂度使其不适合处理大规模数据。</li><li><strong>性能固定</strong>：无法像优化后的冒泡排序那样，在数据基本有序时提前结束，它总是会执行完所有的比较。</li></ul><p>总的来说，选择排序也是一种主要用于教学目的的算法，在实际工程中很少使用。</p><hr><h2 id="三、插入排序"><a href="#三、插入排序" class="headerlink" title="三、插入排序"></a>三、插入排序</h2><h3 id="1-什么是插入排序？"><a href="#1-什么是插入排序？" class="headerlink" title="1. 什么是插入排序？"></a>1. 什么是插入排序？</h3><p>插入排序（Insertion Sort）是一种简单直观的排序算法，其工作方式非常像我们平时整理扑克牌。我们每次从牌堆里抽一张牌，然后将它插入到手中已有牌的正确位置，以保证手中的牌一直是有序的。</p><h4 id="a-核心思想-2"><a href="#a-核心思想-2" class="headerlink" title="a. 核心思想"></a>a. 核心思想</h4><p>算法将列表分成“已排序”和“未排序”两个部分。初始时，已排序部分只包含第一个元素。然后，算法每次从未排序部分取出一个元素，在已排序部分中从后向前扫描，找到相应的位置并插入。</p><h4 id="b-工作原理-2"><a href="#b-工作原理-2" class="headerlink" title="b. 工作原理"></a>b. 工作原理</h4><ol><li><strong>从第二个元素开始</strong>：将列表的第一个元素视为一个已排序的子序列。</li><li><strong>选择并比较</strong>：取出未排序部分的第一个元素（我们称之为“待插入元素”或 <code>key</code>）。</li><li><strong>向后移动</strong>：将这个 <code>key</code> 与已排序子序列中的元素从后向前逐一比较。如果已排序的元素大于 <code>key</code>，则将该元素向右移动一个位置。</li><li><strong>插入</strong>：重复步骤3，直到找到一个小于或等于 <code>key</code> 的元素，或者已到达子序列的开头。然后将 <code>key</code> 插入到这个位置。</li><li><strong>重复</strong>：对未排序部分的所有元素重复步骤2-4，直到整个列表都变为已排序状态。</li></ol><h3 id="2-图解示例-2"><a href="#2-图解示例-2" class="headerlink" title="2. 图解示例"></a>2. 图解示例</h3><p>我们用 <code>[5, 2, 4, 6, 1, 3]</code> 这个例子来演示插入排序的过程（升序排列）。我们将用 <code>|</code> 符号来分隔已排序和未排序部分。</p><p><strong>初始状态:</strong> <code>[5 | 2, 4, 6, 1, 3]</code> (已排序部分是 <code>[5]</code>)</p><p><strong>第一轮 (处理 <code>2</code>):</strong></p><ul><li><code>key = 2</code>。</li><li>比较 <code>2</code> 和 <code>5</code>。<code>5 &gt; 2</code>，所以将 <code>5</code> 向右移动 -&gt; <code>[ _, 5, 4, 6, 1, 3]</code></li><li>已到达列表开头，将 <code>2</code> 插入空位。</li><li><strong>结果</strong>: <code>[2, 5 | 4, 6, 1, 3]</code></li></ul><p><strong>第二轮 (处理 <code>4</code>):</strong></p><ul><li><code>key = 4</code>。</li><li>比较 <code>4</code> 和 <code>5</code>。<code>5 &gt; 4</code>，将 <code>5</code> 向右移动 -&gt; <code>[2, _, 5, 6, 1, 3]</code></li><li>比较 <code>4</code> 和 <code>2</code>。<code>2 &lt; 4</code>，停止移动。将 <code>4</code> 插入空位。</li><li><strong>结果</strong>: <code>[2, 4, 5 | 6, 1, 3]</code></li></ul><p><strong>第三轮 (处理 <code>6</code>):</strong></p><ul><li><code>key = 6</code>。</li><li>比较 <code>6</code> 和 <code>5</code>。<code>5 &lt; 6</code>，停止移动。<code>6</code> 保持原位。</li><li><strong>结果</strong>: <code>[2, 4, 5, 6 | 1, 3]</code></li></ul><p><strong>第四轮 (处理 <code>1</code>):</strong></p><ul><li><code>key = 1</code>。</li><li>比较 <code>1</code> 和 <code>6</code> (<code>6 &gt; 1</code>) -&gt; 右移 <code>6</code></li><li>比较 <code>1</code> 和 <code>5</code> (<code>5 &gt; 1</code>) -&gt; 右移 <code>5</code></li><li>比较 <code>1</code> 和 <code>4</code> (<code>4 &gt; 1</code>) -&gt; 右移 <code>4</code></li><li>比较 <code>1</code> 和 <code>2</code> (<code>2 &gt; 1</code>) -&gt; 右移 <code>2</code></li><li>已到达列表开头，将 <code>1</code> 插入。</li><li><strong>结果</strong>: <code>[1, 2, 4, 5, 6 | 3]</code></li></ul><p><strong>第五轮 (处理 <code>3</code>):</strong></p><ul><li><code>key = 3</code>。</li><li>比较 <code>3</code> 和 <code>6</code> (<code>6 &gt; 3</code>) -&gt; 右移 <code>6</code></li><li>比较 <code>3</code> 和 <code>5</code> (<code>5 &gt; 3</code>) -&gt; 右移 <code>5</code></li><li>比较 <code>3</code> 和 <code>4</code> (<code>4 &gt; 3</code>) -&gt; 右移 <code>4</code></li><li>比较 <code>3</code> 和 <code>2</code> (<code>2 &lt; 3</code>)，停止移动。将 <code>3</code> 插入。</li><li><strong>结果</strong>: <code>[1, 2, 3, 4, 5, 6]</code></li></ul><p>算法结束，列表已完全排序。</p><h3 id="3-Python-代码实现-2"><a href="#3-Python-代码实现-2" class="headerlink" title="3. Python 代码实现"></a>3. Python 代码实现</h3><p>下面是插入排序的 Python 代码实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">insertion_sort</span>(<span class="params">arr</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    插入排序函数</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 从第二个元素开始遍历 (索引为 1)</span></span><br><span class="line">    <span class="comment"># 因为第一个元素自己就是一个已排序的子序列</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(arr)):</span><br><span class="line">        <span class="comment"># key 是当前需要被插入的元素</span></span><br><span class="line">        key = arr[i]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># j 是已排序部分的最后一个元素的索引</span></span><br><span class="line">        j = i - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 将 key 与已排序部分的元素从后向前比较</span></span><br><span class="line">        <span class="comment"># 如果已排序的元素大于 key，则将其向后移动</span></span><br><span class="line">        <span class="keyword">while</span> j &gt;= <span class="number">0</span> <span class="keyword">and</span> key &lt; arr[j]:</span><br><span class="line">            arr[j + <span class="number">1</span>] = arr[j] <span class="comment"># 元素后移</span></span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        <span class="comment"># 当循环结束时，j+1 就是 key 应该插入的位置</span></span><br><span class="line">        arr[j + <span class="number">1</span>] = key</span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 示例 ---</span></span><br><span class="line">my_list = [<span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">3</span>]</span><br><span class="line">insertion_sort(my_list)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;排序后的列表:&quot;</span>, my_list)  <span class="comment"># 输出: [1, 2, 3, 4, 5, 6]</span></span><br><span class="line"></span><br><span class="line">another_list = [<span class="number">64</span>, <span class="number">34</span>, <span class="number">25</span>, <span class="number">12</span>, <span class="number">22</span>, <span class="number">11</span>, <span class="number">90</span>]</span><br><span class="line">insertion_sort(another_list)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;排序后的列表:&quot;</span>, another_list) <span class="comment"># 输出: [11, 12, 22, 25, 34, 64, 90]</span></span><br></pre></td></tr></table></figure><h3 id="4-算法分析-2"><a href="#4-算法分析-2" class="headerlink" title="4. 算法分析"></a>4. 算法分析</h3><ul><li><p><strong>时间复杂度</strong>:</p><ul><li><strong>最坏情况</strong>: <code>O(n²)</code>。当待排序列表是完全逆序时，每个元素都需要与前面所有已排序的元素进行比较和移动。</li><li><strong>平均情况</strong>: <code>O(n²)</code>。</li><li><strong>最好情况</strong>: <code>O(n)</code>。当列表已经是有序的时，每次插入操作只需要进行一次比较，内层循环不会执行。这使得插入排序在处理“几乎有序”的数据时非常高效。</li></ul></li><li><p><strong>空间复杂度</strong>: <code>O(1)</code>。插入排序是<strong>原地排序</strong>算法，只需要一个额外的变量 <code>key</code> 来存储待插入元素，空间是常数级别的。</p></li><li><p><strong>稳定性</strong>: 插入排序是<strong>稳定</strong>的。</p><ul><li><strong>解释</strong>：当待插入元素 <code>key</code> 遇到与它相等的元素时，循环条件 <code>key &lt; arr[j]</code> 为假，循环会停止，<code>key</code> 会被插入到这个相等元素的后面。因此，相等元素的原始相对顺序得以保留。</li></ul></li></ul><h3 id="5-小结-2"><a href="#5-小结-2" class="headerlink" title="5. 小结"></a>5. 小结</h3><p><strong>优点</strong>:</p><ul><li><strong>实现简单</strong>：代码简洁，易于理解。</li><li><strong>高效处理小规模或基本有序的数据</strong>：对于小列表，它的性能很好。对于几乎排好序的列表，它的时间复杂度接近线性 <code>O(n)</code>，这是它优于冒泡排序和选择排序的一个重要特点。</li><li><strong>稳定性</strong>：是一种稳定的排序算法。</li><li><strong>空间效率高</strong>：是原地排序，占用极少的额外空间。</li><li><strong>在线算法 (Online Algorithm)</strong>：可以边接收数据边排序，因为它在决定一个元素的位置时，不需要知道后面元素的信息。</li></ul><p><strong>缺点</strong>:</p><ul><li><strong>时间效率低</strong>：对于大规模且无序的数据，<code>O(n²)</code> 的时间复杂度使其效率低下，不如快速排序、归并排序等 <code>O(n log n)</code> 算法。</li></ul><p>总的来说，插入排序是小型数据集和几乎有序数据集的绝佳选择。在一些复杂排序算法中（如 Timsort，Python 的 <code>list.sort()</code> 和 <code>sorted()</code> 使用的算法），当数据块小到一定程度时，也会切换到插入排序来进行处理。</p><hr><h2 id="四、快速排序"><a href="#四、快速排序" class="headerlink" title="四、快速排序"></a>四、快速排序</h2><p>快速排序（Quicksort）是计算机科学中最著名和使用最广泛的排序算法之一。它由托尼·霍尔在1959年发明。</p><h3 id="1-什么是快速排序？"><a href="#1-什么是快速排序？" class="headerlink" title="1. 什么是快速排序？"></a>1. 什么是快速排序？</h3><p>快速排序是一种高效的、基于<strong>分治法（Divide and Conquer）</strong> 的排序算法。与归并排序类似，它也将问题分解为更小的子问题来解决，但其分治的方式非常独特。</p><h4 id="a-核心思想-分治法"><a href="#a-核心思想-分治法" class="headerlink" title="a. 核心思想 (分治法)"></a>a. 核心思想 (分治法)</h4><p>快速排序将一个大数组的排序问题分解为对两个小数组的排序问题。其步骤如下：</p><ol><li><p><strong>分解 (Divide)</strong>：</p><ul><li>从数组中选择一个元素，我们称之为 <strong>“基准”（Pivot）</strong>。</li><li>重新排列数组，将所有小于基准的元素移动到基准的左边，所有大于基准的元素移动到基准的右边。相等的元素可以放在任何一边。</li><li>完成这个过程后，基准元素就处于其最终的排序位置。这个过程被称为 <strong>“分区”（Partitioning）</strong>。</li></ul></li><li><p><strong>征服 (Conquer)</strong>：</p><ul><li>递归地对基准左边的子数组和右边的子数组进行快速排序。</li></ul></li><li><p><strong>合并 (Combine)</strong>：</p><ul><li>因为子数组是原地排序的，所以当递归结束时，整个数组就已经排好序了。这个步骤是隐式的，不需要任何操作。</li></ul></li></ol><h4 id="b-分区（Partition）操作是关键"><a href="#b-分区（Partition）操作是关键" class="headerlink" title="b. 分区（Partition）操作是关键"></a>b. 分区（Partition）操作是关键</h4><p>分区的实现方式有很多种，最著名的是 <strong>Lomuto 分区方案</strong>。其工作原理如下：</p><ol><li>通常选择数组的最后一个元素作为基准。</li><li>维护一个指针 <code>i</code>，它指向“小于基准”区域的最后一个元素的下一个位置（可以看作是这个区域的右边界）。初始时，<code>i</code> 在数组的起始位置之前。</li><li>用另一个指针 <code>j</code> 遍历数组（从头到倒数第二个元素）。</li><li>如果 <code>arr[j]</code> 小于或等于基准，就将 <code>i</code> 向右移动一位，然后交换 <code>arr[i]</code> 和 <code>arr[j]</code>。这相当于将小于基准的元素 <code>arr[j]</code> 放入“小于基准”的区域。</li><li>遍历结束后，将基准元素（原本在数组末尾）与 <code>arr[i+1]</code> 交换。这样，基准就恰好位于所有比它小的元素和所有比它大的元素之间。</li><li>返回基准的新索引。</li></ol><h3 id="2-图解示例-3"><a href="#2-图解示例-3" class="headerlink" title="2. 图解示例"></a>2. 图解示例</h3><p>我们用 <code>[7, 2, 1, 6, 8, 5, 3, 4]</code> 这个例子来演示快速排序的过程。</p><p><strong>初始调用:</strong> <code>quick_sort([7, 2, 1, 6, 8, 5, 3, 4])</code></p><p><strong>第一轮 (Partition):</strong></p><ul><li>选择基准（Pivot），我们选最后一个元素 <code>4</code>。</li><li>分区过程会将 <code>&lt;4</code> 的元素放到左边，<code>&gt;4</code> 的元素放到右边。</li><li>分区后的数组可能样子是：<code>[3, 2, 1, 4, 8, 5, 7, 6]</code> (注意：分区结果不唯一，取决于具体实现)</li><li>现在 <code>4</code> 已经找到了它的最终位置（索引3）。</li></ul><p><strong>第二轮 (递归调用):</strong></p><ul><li><p>现在问题变成了两个独立的子问题：</p><ol><li>对 <code>4</code> 左边的子数组 <code>[3, 2, 1]</code> 进行快速排序。</li><li>对 <code>4</code> 右边的子数组 <code>[8, 5, 7, 6]</code> 进行快速排序。</li></ol></li><li><p><strong>处理左子数组 <code>[3, 2, 1]</code></strong>:</p><ul><li>选择基准 <code>1</code>。</li><li>分区后：<code>[1, 2, 3]</code> (<code>1</code> 位于正确位置)。</li><li>递归处理 <code>1</code> 左边（空）和右边 <code>[2, 3]</code> 的子数组。</li><li>处理 <code>[2, 3]</code>，基准为 <code>3</code>，分区后不变，<code>2</code> 在左，排序完成。</li></ul></li><li><p><strong>处理右子数组 <code>[8, 5, 7, 6]</code></strong>:</p><ul><li>选择基准 <code>6</code>。</li><li>分区后：<code>[5, 6, 7, 8]</code> (<code>6</code> 位于正确位置)。</li><li>递归处理 <code>6</code> 左边 <code>[5]</code> 和右边 <code>[7, 8]</code> 的子数组。</li><li><code>[5]</code> 已排序。处理 <code>[7, 8]</code>，基准为 <code>8</code>，分区后不变，<code>7</code> 在左，排序完成。</li></ul></li></ul><p><strong>最终结果:</strong><br>当所有递归调用都返回后，原始数组就变成了 <code>[1, 2, 3, 4, 5, 6, 7, 8]</code>。</p><h3 id="3-Python-代码实现-3"><a href="#3-Python-代码实现-3" class="headerlink" title="3. Python 代码实现"></a>3. Python 代码实现</h3><p>下面是使用 Lomuto 分区方案的快速排序 Python 实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">partition</span>(<span class="params">arr, low, high</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    分区函数 (Lomuto partition scheme)</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        arr: 待分区的列表</span></span><br><span class="line"><span class="string">        low: 起始索引</span></span><br><span class="line"><span class="string">        high: 结束索引 (也是基准元素的索引)</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        基准元素分区后的最终索引</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 选择最后一个元素作为基准</span></span><br><span class="line">    pivot = arr[high]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># i 是指向小于基准的区域的最后一个元素的下一个位置</span></span><br><span class="line">    i = low - <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 遍历从 low 到 high-1 的元素</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(low, high):</span><br><span class="line">        <span class="comment"># 如果当前元素小于或等于基准</span></span><br><span class="line">        <span class="keyword">if</span> arr[j] &lt;= pivot:</span><br><span class="line">            <span class="comment"># 将 i 向右移动</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 将小于基准的元素 arr[j] 交换到 i 指向的位置</span></span><br><span class="line">            arr[i], arr[j] = arr[j], arr[i]</span><br><span class="line">            </span><br><span class="line">    <span class="comment"># 将基准元素放到正确的位置 (i+1)</span></span><br><span class="line">    arr[i + <span class="number">1</span>], arr[high] = arr[high], arr[i + <span class="number">1</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 返回基准的索引</span></span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_quick_sort_recursive</span>(<span class="params">arr, low, high</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    快速排序的递归辅助函数</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> low &lt; high:</span><br><span class="line">        <span class="comment"># pi 是分区后基准的索引</span></span><br><span class="line">        pi = partition(arr, low, high)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 递归地对基准左边的子数组进行排序</span></span><br><span class="line">        _quick_sort_recursive(arr, low, pi - <span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 递归地对基准右边的子数组进行排序</span></span><br><span class="line">        _quick_sort_recursive(arr, pi + <span class="number">1</span>, high)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">quick_sort</span>(<span class="params">arr</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    快速排序主函数</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    _quick_sort_recursive(arr, <span class="number">0</span>, <span class="built_in">len</span>(arr) - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 示例 ---</span></span><br><span class="line">my_list = [<span class="number">7</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">quick_sort(my_list)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;排序后的列表:&quot;</span>, my_list)  <span class="comment"># 输出: [1, 2, 3, 4, 5, 6, 7, 8]</span></span><br><span class="line"></span><br><span class="line">another_list = [<span class="number">64</span>, <span class="number">34</span>, <span class="number">25</span>, <span class="number">12</span>, <span class="number">22</span>, <span class="number">11</span>, <span class="number">90</span>]</span><br><span class="line">quick_sort(another_list)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;排序后的列表:&quot;</span>, another_list) <span class="comment"># 输出: [11, 12, 22, 25, 34, 64, 90]</span></span><br></pre></td></tr></table></figure><h3 id="4-算法分析-3"><a href="#4-算法分析-3" class="headerlink" title="4. 算法分析"></a>4. 算法分析</h3><ul><li><p><strong>时间复杂度</strong>:</p><ul><li><strong>最坏情况</strong>: <code>O(n²)</code>。当每次选择的基准都是当前数组中的最小或最大元素时发生（例如，对一个已经排好序的数组进行排序）。这会导致分区极不平衡，递归树退化成一个线性链表。</li><li><strong>平均情况</strong>: <code>O(n log n)</code>。这是快速排序最常见的情况。每次分区都将数组分成大致相等的两部分，递归树的深度为 <code>log n</code>，每层分区操作的总时间是 <code>O(n)</code>。</li><li><strong>最好情况</strong>: <code>O(n log n)</code>。每次分区都恰好将数组分成两半。</li></ul></li><li><p><strong>空间复杂度</strong>: <code>O(log n)</code> (平均情况) 到 <code>O(n)</code> (最坏情况)。这个空间是递归调用栈所占用的。平均情况下递归深度为 <code>log n</code>，最坏情况下为 <code>n</code>。</p></li><li><p><strong>稳定性</strong>: 快速排序是<strong>不稳定</strong>的。在分区过程中，元素交换可能会改变相等元素的原始相对顺序。</p></li></ul><h3 id="5-优化"><a href="#5-优化" class="headerlink" title="5. 优化"></a>5. 优化</h3><p>为了避免最坏情况的发生，可以优化<strong>基准的选择</strong>：</p><ol><li><strong>随机基准</strong>：随机选择一个元素作为基准。这使得最坏情况在实践中几乎不可能发生。</li><li><strong>三数取中 (Median-of-Three)</strong>：取数组的第一个、中间一个和最后一个元素的中位数作为基准。这能有效避免在有序或逆序数组上性能下降的问题。</li></ol><h3 id="6-小结"><a href="#6-小结" class="headerlink" title="6. 小结"></a>6. 小结</h3><p><strong>优点</strong>:</p><ul><li><strong>极高的平均效率</strong>：<code>O(n log n)</code> 的平均时间复杂度，并且其常数因子很小，使其在实践中通常比其他 <code>O(n log n)</code> 算法（如归并排序、堆排序）更快。</li><li><strong>原地排序</strong>：通常是原地排序，只需要 <code>O(log n)</code> 的栈空间。</li></ul><p><strong>缺点</strong>:</p><ul><li><strong>最坏情况性能差</strong>：<code>O(n²)</code> 的时间复杂度在某些情况下可能发生。</li><li><strong>不稳定</strong>：不保证相等元素的相对顺序。</li><li><strong>对小数据量效率不高</strong>：对于非常小的数组，其递归开销可能比插入排序等简单算法更大。因此，一些优化的快速排序实现会在子数组小到一定程度时，切换到插入排序。</li></ul><hr><h2 id="五、归并排序"><a href="#五、归并排序" class="headerlink" title="五、归并排序"></a>五、归并排序</h2><h3 id="1-什么是归并排序？"><a href="#1-什么是归并排序？" class="headerlink" title="1. 什么是归并排序？"></a>1. 什么是归并排序？</h3><p>归并排序（Merge Sort）是另一种基于<strong>分治法（Divide and Conquer）<strong>思想的高效排序算法。它的名字来源于其核心操作——</strong>“归并”（Merge）</strong>，即将两个已经排好序的序列合并成一个有序序列。</p><h4 id="a-核心思想-分治法-1"><a href="#a-核心思想-分治法-1" class="headerlink" title="a. 核心思想 (分治法)"></a>a. 核心思想 (分治法)</h4><p>归并排序将排序问题分解为三个步骤：</p><ol><li><strong>分解 (Divide)</strong>：将待排序的列表不断地对半分割，直到每个子列表只包含一个元素。一个只包含一个元素的列表自然就是有序的。</li><li><strong>征服 (Conquer)</strong>：这一步是隐式的。因为分解到最后，每个子列表都只有一个元素，所以它们已经是“已排序”的状态。</li><li><strong>合并 (Combine)</strong>：从最小的子列表开始，将相邻的两个已排序的子列表 <strong>归并</strong> 成一个更大的、有序的列表。这个过程不断重复，直到所有子列表被合并成一个完整的、有序的列表。</li></ol><h4 id="b-工作原理-3"><a href="#b-工作原理-3" class="headerlink" title="b. 工作原理"></a>b. 工作原理</h4><p>归并排序的关键在于**“合并”**这一步。假设我们有两个已经排好序的列表 <code>A</code> 和 <code>B</code>，如何将它们合并成一个有序的大列表 <code>C</code> 呢？</p><ol><li>创建两个指针，分别指向 <code>A</code> 和 <code>B</code> 的起始位置。</li><li>比较两个指针指向的元素。</li><li>将较小的那个元素复制到 <code>C</code> 中，并将该指针向后移动一位。</li><li>重复步骤2和3，直到其中一个列表的所有元素都被复制完毕。</li><li>将另一个列表中剩余的所有元素直接复制到 <code>C</code> 的末尾。</li></ol><h3 id="2-图解示例-4"><a href="#2-图解示例-4" class="headerlink" title="2. 图解示例"></a>2. 图解示例</h3><p>我们用 <code>[8, 3, 1, 7, 0, 10, 2]</code> 这个例子来演示归并排序的过程。</p><p><strong>1. 分解 (Splitting Phase):</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">                [8, 3, 1, 7, 0, 10, 2]</span><br><span class="line">               /                       \</span><br><span class="line">        [8, 3, 1, 7]                  [0, 10, 2]</span><br><span class="line">       /           \                 /          \</span><br><span class="line">   [8, 3]        [1, 7]            [0, 10]      [2]</span><br><span class="line">  /      \      /      \          /       \</span><br><span class="line">[8]      [3]  [1]      [7]      [0]       [10]</span><br></pre></td></tr></table></figure><p>分解过程一直持续到每个子列表只有一个元素。</p><p><strong>2. 合并 (Merging Phase):</strong></p><p>现在，我们从底层开始，将这些单元素的列表两两合并。</p><ul><li><code>[8]</code> 和 <code>[3]</code> 合并成 <code>[3, 8]</code></li><li><code>[1]</code> 和 <code>[7]</code> 合并成 <code>[1, 7]</code></li><li><code>[0]</code> 和 <code>[10]</code> 合并成 <code>[0, 10]</code></li><li><code>[2]</code> 保持不变（因为它没有相邻的伙伴）</li></ul><p>此时，列表结构变为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[3, 8]        [1, 7]            [0, 10]      [2]</span><br></pre></td></tr></table></figure><ul><li><code>[3, 8]</code> 和 <code>[1, 7]</code> 合并成 <code>[1, 3, 7, 8]</code></li><li><code>[0, 10]</code> 和 <code>[2]</code> 合并成 <code>[0, 2, 10]</code></li></ul><p>此时，列表结构变为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1, 3, 7, 8]                  [0, 2, 10]</span><br></pre></td></tr></table></figure><ul><li>最后，<code>[1, 3, 7, 8]</code> 和 <code>[0, 2, 10]</code> 合并成最终结果 <code>[0, 1, 2, 3, 7, 8, 10]</code></li></ul><p>最终排序结果: <code>[0, 1, 2, 3, 7, 8, 10]</code></p><h3 id="3-Python-代码实现-4"><a href="#3-Python-代码实现-4" class="headerlink" title="3. Python 代码实现"></a>3. Python 代码实现</h3><p>下面是归并排序的典型 Python 递归实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">merge_sort</span>(<span class="params">arr</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    归并排序函数</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 递归的终止条件：如果列表只有一个元素或为空，则它已经是有序的</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(arr) &gt; <span class="number">1</span>:</span><br><span class="line">        <span class="comment"># 1. 分解 (Divide)</span></span><br><span class="line">        mid = <span class="built_in">len</span>(arr) // <span class="number">2</span>  <span class="comment"># 找到列表的中间位置</span></span><br><span class="line">        left_half = arr[:mid]  <span class="comment"># 分割成左半部分</span></span><br><span class="line">        right_half = arr[mid:] <span class="comment"># 分割成右半部分</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 递归地对左右两半进行排序</span></span><br><span class="line">        merge_sort(left_half)</span><br><span class="line">        merge_sort(right_half)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 2. 合并 (Combine/Merge)</span></span><br><span class="line">        i = <span class="number">0</span>  <span class="comment"># 左半部分的索引</span></span><br><span class="line">        j = <span class="number">0</span>  <span class="comment"># 右半部分的索引</span></span><br><span class="line">        k = <span class="number">0</span>  <span class="comment"># 合并后主列表的索引</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 当左右两半都还有元素时，进行比较</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(left_half) <span class="keyword">and</span> j &lt; <span class="built_in">len</span>(right_half):</span><br><span class="line">            <span class="keyword">if</span> left_half[i] &lt;= right_half[j]:</span><br><span class="line">                arr[k] = left_half[i]</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                arr[k] = right_half[j]</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            k += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 检查是否有剩余的元素</span></span><br><span class="line">        <span class="comment"># 如果左半部分还有剩余，直接复制过来</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(left_half):</span><br><span class="line">            arr[k] = left_half[i]</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            k += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 如果右半部分还有剩余，直接复制过来</span></span><br><span class="line">        <span class="keyword">while</span> j &lt; <span class="built_in">len</span>(right_half):</span><br><span class="line">            arr[k] = right_half[j]</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">            k += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 示例 ---</span></span><br><span class="line">my_list = [<span class="number">8</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="number">2</span>]</span><br><span class="line">merge_sort(my_list)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;排序后的列表:&quot;</span>, my_list)  <span class="comment"># 输出: [0, 1, 2, 3, 7, 8, 10]</span></span><br><span class="line"></span><br><span class="line">another_list = [<span class="number">64</span>, <span class="number">34</span>, <span class="number">25</span>, <span class="number">12</span>, <span class="number">22</span>, <span class="number">11</span>, <span class="number">90</span>]</span><br><span class="line">merge_sort(another_list)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;排序后的列表:&quot;</span>, another_list) <span class="comment"># 输出: [11, 12, 22, 25, 34, 64, 90]</span></span><br></pre></td></tr></table></figure><h3 id="4-算法分析-4"><a href="#4-算法分析-4" class="headerlink" title="4. 算法分析"></a>4. 算法分析</h3><ul><li><p><strong>时间复杂度</strong>: <code>O(n log n)</code>。</p><ul><li><strong>解释</strong>：分解过程将列表分成两半，这个过程的递归树深度是 <code>log n</code>。在每一层递归中，合并操作都需要遍历该层的所有元素，总共是 <code>n</code> 个元素。因此，总的时间复杂度是 <code>n * log n</code>。</li><li>这个时间复杂度非常<strong>稳定</strong>，无论是<strong>最好、最坏还是平均情况</strong>，都是 <code>O(n log n)</code>。这是归并排序的一个巨大优势。</li></ul></li><li><p><strong>空间复杂度</strong>: <code>O(n)</code>。</p><ul><li><strong>解释</strong>：归并排序<strong>不是原地排序</strong>。在合并阶段，需要创建临时的 <code>left_half</code> 和 <code>right_half</code> 列表来存储数据。在递归的每一层，这些临时列表加起来的总空间是 <code>O(n)</code>。</li></ul></li><li><p><strong>稳定性</strong>: 归并排序是<strong>稳定</strong>的。</p><ul><li><strong>解释</strong>：在合并操作中，当遇到相等的元素时（<code>left_half[i] &lt;= right_half[j]</code>），我们总是先取左半部分的元素。这保证了相等元素的原始相对顺序不会改变。</li></ul></li></ul><h3 id="5-小结-3"><a href="#5-小结-3" class="headerlink" title="5. 小结"></a>5. 小结</h3><p><strong>优点</strong>:</p><ul><li><strong>性能稳定可靠</strong>：时间复杂度始终是 <code>O(n log n)</code>，不受输入数据的影响。</li><li><strong>稳定性</strong>：是一种稳定的排序算法，适用于需要保持相等元素相对顺序的场景。</li><li><strong>适用性广</strong>：特别适合对链表进行排序，因为链表插入操作 <code>O(1)</code>，可以避免数组复制带来的开销。也适用于外部排序（数据量大到无法一次性载入内存）。</li></ul><p><strong>缺点</strong>:</p><ul><li><strong>空间复杂度较高</strong>：需要 <code>O(n)</code> 的额外空间，这在内存受限的情况下可能是一个问题。相比之下，快速排序的平均空间复杂度是 <code>O(log n)</code>。</li></ul><p>总的来说，归并排序是一种非常强大和可靠的排序算法，当需要一个性能稳定或排序结果稳定的算法时，它是一个绝佳的选择。</p><hr><h2 id="六、堆排序"><a href="#六、堆排序" class="headerlink" title="六、堆排序"></a>六、堆排序</h2><h3 id="1-什么是堆排序？"><a href="#1-什么是堆排序？" class="headerlink" title="1. 什么是堆排序？"></a>1. 什么是堆排序？</h3><p>堆排序是一种基于<strong>比较</strong>的排序算法，它利用了一种叫做 <strong>“堆”（Heap）</strong> 的数据结构。你可以把它看作是选择排序的一种改进版本。在选择排序中，我们每次都需要线性扫描 <code>O(n)</code> 来找到未排序部分的最大（或最小）元素。而堆排序通过将数据组织成一个堆，可以在 <code>O(log n)</code> 的时间内找到最大（或最小）元素，从而提高了效率。</p><h4 id="a-核心前提：什么是堆（Heap）？"><a href="#a-核心前提：什么是堆（Heap）？" class="headerlink" title="a. 核心前提：什么是堆（Heap）？"></a>a. 核心前提：什么是堆（Heap）？</h4><p>在介绍堆排序之前，必须先理解“堆”。堆是一个近似<strong>完全二叉树</strong>的结构，并同时满足<strong>堆的性质</strong>：</p><ol><li><p><strong>结构性</strong>：它是一棵完全二叉树。这意味着树的每一层都是完全填满的，除了最后一层，最后一层的节点都尽量靠左排列。这使得我们可以用一个 <strong>数组（列表）</strong> 来高效地表示它，而无需使用指针。</p><ul><li>对于数组中索引为 <code>i</code> 的节点：<ul><li>其父节点索引：<code>(i - 1) // 2</code></li><li>其左子节点索引：<code>2 * i + 1</code></li><li>其右子节点索引：<code>2 * i + 2</code></li></ul></li></ul></li><li><p><strong>堆序性 (Heap Property)</strong>：</p><ul><li><strong>最大堆 (Max-Heap)</strong>：父节点的值总是<strong>大于或等于</strong>其任何一个子节点的值。因此，堆的根节点（数组的第一个元素）是整个堆中的最大值。</li><li><strong>最小堆 (Min-Heap)</strong>：父节点的值总是<strong>小于或等于</strong>其任何一个子节点的值。因此，堆的根节点是整个堆中的最小值。</li></ul></li></ol><p><strong>为了实现升序排序，我们通常使用最大堆。</strong></p><h4 id="b-堆排序的工作原理"><a href="#b-堆排序的工作原理" class="headerlink" title="b. 堆排序的工作原理"></a>b. 堆排序的工作原理</h4><p>堆排序可以分为两个主要阶段：</p><p><strong>阶段一：建堆 (Build Heap)</strong></p><ol><li>将待排序的无序列表看作一个完全二叉树。</li><li>从最后一个非叶子节点开始，向前逐个处理到根节点。</li><li>对每个节点执行一个叫做 <strong>“堆化”（Heapify）</strong> 或“下沉”（Sift-down）的操作，确保以该节点为根的子树满足最大堆的性质。</li><li>当处理完所有非叶子节点后，整个列表就变成了一个最大堆。</li></ol><p><strong>阶段二：排序 (Sorting)</strong></p><ol><li>此时，列表的第一个元素（根节点）是当前所有元素中的最大值。</li><li>将这个最大值与列表的最后一个元素交换。这样，最大的元素就被放到了它最终应该在的正确位置。</li><li>将列表的已排序部分（即最后一个元素）从堆中移除（逻辑上通过缩小堆的大小来实现）。</li><li>此时，新的根节点可能违反了最大堆的性质。对新的根节点执行一次“堆化”操作，使其恢复最大堆的性质。</li><li>重复步骤2-4，每次都将堆顶的最大元素交换到末尾，然后缩小堆的范围并调整堆，直到堆的大小为1。</li></ol><h3 id="2-图解示例-5"><a href="#2-图解示例-5" class="headerlink" title="2. 图解示例"></a>2. 图解示例</h3><p>我们用 <code>[4, 10, 3, 5, 1, 2]</code> 来演示堆排序的过程。</p><p><strong>阶段一：构建最大堆</strong></p><ol><li>初始数组（看作树）：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">      4</span><br><span class="line">   /     \</span><br><span class="line">  10      3</span><br><span class="line"> / \     /</span><br><span class="line">5   1   2</span><br></pre></td></tr></table></figure></li><li>从最后一个非叶子节点 <code>3</code> (索引2) 开始堆化，无变化。</li><li>处理下一个非叶子节点 <code>10</code> (索引1)。它的子节点是 <code>5</code> 和 <code>1</code>。<code>10</code> 是最大的，无变化。</li><li>处理根节点 <code>4</code> (索引0)。它的子节点是 <code>10</code> 和 <code>3</code>。<code>10 &gt; 4</code>，交换 <code>4</code> 和 <code>10</code>。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">      10</span><br><span class="line">   /     \</span><br><span class="line">  4       3</span><br><span class="line"> / \     /</span><br><span class="line">5   1   2</span><br></pre></td></tr></table></figure>交换后，<code>4</code> 到了新位置（原 <code>10</code> 的位置），它的子节点是 <code>5</code> 和 <code>1</code>。<code>5 &gt; 4</code>，再次交换。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">      10</span><br><span class="line">   /     \</span><br><span class="line">  5       3</span><br><span class="line"> / \     /</span><br><span class="line">4   1   2</span><br></pre></td></tr></table></figure></li><li>建堆完成，数组变为 <code>[10, 5, 3, 4, 1, 2]</code>。</li></ol><p><strong>阶段二：排序</strong></p><ol><li><p><strong>第一次</strong>：堆是 <code>[10, 5, 3, 4, 1, 2]</code>。</p><ul><li>交换 <code>10</code> 和 <code>2</code> -&gt; <code>[2, 5, 3, 4, 1, 10]</code>。</li><li>堆范围缩小为前5个元素 <code>[2, 5, 3, 4, 1]</code>，对根节点 <code>2</code> 进行堆化 -&gt; <code>[5, 4, 3, 2, 1]</code>。</li><li>此时数组为 <code>[5, 4, 3, 2, 1, 10]</code>。</li></ul></li><li><p><strong>第二次</strong>：堆是 <code>[5, 4, 3, 2, 1]</code>。</p><ul><li>交换 <code>5</code> 和 <code>1</code> -&gt; <code>[1, 4, 3, 2, 5]</code>。</li><li>堆范围缩小为前4个元素 <code>[1, 4, 3, 2]</code>，对根节点 <code>1</code> 进行堆化 -&gt; <code>[4, 2, 3, 1]</code>。</li><li>此时数组为 <code>[4, 2, 3, 1, 5, 10]</code>。</li></ul></li><li><p>……以此类推，直到堆中只剩一个元素。</p></li></ol><p>最终排序结果: <code>[1, 2, 3, 4, 5, 10]</code></p><h3 id="3-Python-代码实现-5"><a href="#3-Python-代码实现-5" class="headerlink" title="3. Python 代码实现"></a>3. Python 代码实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">heapify</span>(<span class="params">arr, n, i</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    将以 i 为根的子树调整为最大堆</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        arr: 待调整的列表</span></span><br><span class="line"><span class="string">        n: 堆的大小</span></span><br><span class="line"><span class="string">        i: 子树的根节点索引</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    largest = i      <span class="comment"># 初始化最大值为根节点</span></span><br><span class="line">    left = <span class="number">2</span> * i + <span class="number">1</span>   <span class="comment"># 左子节点</span></span><br><span class="line">    right = <span class="number">2</span> * i + <span class="number">2</span>  <span class="comment"># 右子节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 检查左子节点是否存在且大于根节点</span></span><br><span class="line">    <span class="keyword">if</span> left &lt; n <span class="keyword">and</span> arr[left] &gt; arr[largest]:</span><br><span class="line">        largest = left</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 检查右子节点是否存在且大于当前最大值</span></span><br><span class="line">    <span class="keyword">if</span> right &lt; n <span class="keyword">and</span> arr[right] &gt; arr[largest]:</span><br><span class="line">        largest = right</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果最大值不是根节点，则交换它们，并继续向下堆化</span></span><br><span class="line">    <span class="keyword">if</span> largest != i:</span><br><span class="line">        arr[i], arr[largest] = arr[largest], arr[i]</span><br><span class="line">        <span class="comment"># 递归地堆化受影响的子树</span></span><br><span class="line">        heapify(arr, n, largest)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">heap_sort</span>(<span class="params">arr</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    堆排序函数</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    n = <span class="built_in">len</span>(arr)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 1. 构建最大堆</span></span><br><span class="line">    <span class="comment"># 从最后一个非叶子节点开始，向前遍历</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n // <span class="number">2</span> - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        heapify(arr, n, i)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. 一个个从堆顶取出元素，进行排序</span></span><br><span class="line">    <span class="comment"># 将当前最大元素（根）与末尾元素交换，然后重新调整堆</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">        arr[i], arr[<span class="number">0</span>] = arr[<span class="number">0</span>], arr[i]  <span class="comment"># 交换</span></span><br><span class="line">        heapify(arr, i, <span class="number">0</span>) <span class="comment"># 对缩小后的堆进行堆化</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 示例 ---</span></span><br><span class="line">my_list = [<span class="number">4</span>, <span class="number">10</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">heap_sort(my_list)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;排序后的列表:&quot;</span>, my_list)  <span class="comment"># 输出: [1, 2, 3, 4, 5, 10]</span></span><br><span class="line"></span><br><span class="line">another_list = [<span class="number">64</span>, <span class="number">34</span>, <span class="number">25</span>, <span class="number">12</span>, <span class="number">22</span>, <span class="number">11</span>, <span class="number">90</span>]</span><br><span class="line">heap_sort(another_list)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;排序后的列表:&quot;</span>, another_list) <span class="comment"># 输出: [11, 12, 22, 25, 34, 64, 90]</span></span><br></pre></td></tr></table></figure><h3 id="4-算法分析-5"><a href="#4-算法分析-5" class="headerlink" title="4. 算法分析"></a>4. 算法分析</h3><ul><li><p><strong>时间复杂度</strong>: <code>O(n log n)</code>。</p><ul><li><strong>建堆阶段</strong>: 虽然看起来是 <code>n/2</code> 次调用 <code>heapify</code> (复杂度 <code>log n</code>)，但精确分析表明建堆的时间复杂度是线性的 <code>O(n)</code>。</li><li><strong>排序阶段</strong>: 进行了 <code>n-1</code> 次交换和 <code>heapify</code> 操作。每次 <code>heapify</code> 的时间复杂度是 <code>O(log n)</code>。所以这部分是 <code>O(n log n)</code>。</li><li><strong>总计</strong>: <code>O(n) + O(n log n) = O(n log n)</code>。这个时间复杂度在<strong>最好、最坏和平均情况</strong>下都是一样的。</li></ul></li><li><p><strong>空间复杂度</strong>: <code>O(1)</code>。</p><ul><li>堆排序是<strong>原地排序</strong>算法，因为它是在原始数组上直接进行操作的，只需要常数级别的额外空间（用于递归调用栈，但可以被迭代写法替代）。</li></ul></li><li><p><strong>稳定性</strong>: 堆排序是<strong>不稳定</strong>的。</p><ul><li><strong>解释</strong>：在将堆顶元素与堆尾元素交换时，可能会打乱相等元素的原始相对顺序。例如 <code>[3a, 2, 3b]</code>，建堆后可能是 <code>[3b, 2, 3a]</code>，第一次交换会将 <code>3b</code> 与 <code>3a</code> 交换，<code>3a</code> 就跑到了 <code>3b</code> 的后面。</li></ul></li></ul><h3 id="5-小结-4"><a href="#5-小结-4" class="headerlink" title="5. 小结"></a>5. 小结</h3><p><strong>优点</strong>:</p><ul><li><strong>性能优秀且稳定</strong>：<code>O(n log n)</code> 的时间复杂度在各种情况下都得到保证，没有像快速排序那样的 <code>O(n²)</code> 最坏情况。</li><li><strong>空间效率高</strong>：<code>O(1)</code> 的空间复杂度，是原地排序算法。</li></ul><p><strong>缺点</strong>:</p><ul><li><strong>不稳定</strong>：不适用于需要保持相等元素相对顺序的场景。</li><li><strong>常数因子较大</strong>：在实践中，对于同样的数据，平均性能通常不如经过优化的快速排序，因为其数据访问模式对 CPU 缓存不友好。</li></ul><p>堆排序在需要 <code>O(n log n)</code> 最坏情况时间保证和 <code>O(1)</code> 空间复杂度的场景下非常有用，例如在一些嵌入式系统或对内存要求严格的环境中。它也是实现**优先队列（Priority Queue）**的常用数据结构。</p><hr><h2 id="七、希尔排序"><a href="#七、希尔排序" class="headerlink" title="七、希尔排序"></a>七、希尔排序</h2><h3 id="1-什么是希尔排序？"><a href="#1-什么是希尔排序？" class="headerlink" title="1. 什么是希尔排序？"></a>1. 什么是希尔排序？</h3><p>希尔排序，也称<strong>递减增量排序算法</strong>（Diminishing Increment Sort），是插入排序的一种更高效的改进版本。它由 Donald Shell 于1959年提出。</p><p>插入排序在处理“几乎有序”的数组时效率非常高，但当数组元素需要移动很长的距离时（例如，最小的元素在数组末尾），它的效率就很低，因为每个元素只能向前移动一个位置。</p><p>希尔排序的核心思想就是<strong>克服了插入排序的这个缺点</strong>。它通过允许交换相隔一定距离的元素，来快速地将元素移动到更接近其最终位置的地方，从而使得整个数组变得“部分有序”。然后，它逐步缩减这个距离，最后进行一次标准的插入排序，此时由于数组已经基本有序，排序速度会非常快。</p><h4 id="a-核心思想-3"><a href="#a-核心思想-3" class="headerlink" title="a. 核心思想"></a>a. 核心思想</h4><ol><li><strong>选择一个增量序列（Gap Sequence）</strong>：选择一个整数序列 <code>t1, t2, ..., tk</code>，其中 <code>t1 &gt; t2 &gt; ... &gt; tk = 1</code>。这个序列被称为增量或间隙（Gap）。</li><li><strong>分组排序</strong>：对于每一个增量 <code>t_i</code>，将整个数组分为 <code>t_i</code> 个子数组。每个子数组由所有相隔 <code>t_i</code> 的元素组成。</li><li><strong>对子数组进行插入排序</strong>：对这 <code>t_i</code> 个子数组分别进行插入排序。由于是同时对多个交错的子数组进行排序，这个过程实际上是在整个数组上进行一次“宏观”的插入排序。</li><li><strong>递减增量</strong>：重复步骤2和3，使用下一个更小的增量 <code>t_{i+1}</code>。</li><li><strong>最终排序</strong>：当增量 <code>t_k = 1</code> 时，整个数组被看作一个子数组，执行一次标准的插入排序。但此时，数组已经基本有序，所以这次插入排序的效率非常高。</li></ol><h4 id="b-增量序列的选择"><a href="#b-增量序列的选择" class="headerlink" title="b. 增量序列的选择"></a>b. 增量序列的选择</h4><p>增量序列的选择对希尔排序的性能至关重要。</p><ul><li><strong>Shell 原始序列</strong>: <code>N/2, N/4, ..., 1</code> (其中 N 是数组大小)。简单但不是最优。</li><li><strong>Knuth 序列</strong>: <code>1, 4, 13, 40, ...</code> (通过 <code>h = 3*h + 1</code> 生成)。性能更好，被广泛使用。</li><li><strong>Sedgewick 序列</strong>: <code>1, 5, 19, 41, ...</code> (更复杂的公式)。在实践中表现更好。</li></ul><p>对于教学和基础实现，我们通常使用最简单的 Shell 原始序列。</p><h3 id="2-图解示例-6"><a href="#2-图解示例-6" class="headerlink" title="2. 图解示例"></a>2. 图解示例</h3><p>我们用 <code>[8, 3, 1, 7, 0, 10, 2]</code> 这个例子来演示希尔排序的过程。数组长度 <code>n = 7</code>。<br>我们将使用 Shell 原始增量序列。</p><p><strong>第一轮：Gap &#x3D; <code>7 // 2 = 3</code></strong></p><ul><li>我们将数组分为3个子数组：<ul><li>子数组1: <code>arr[0]</code>, <code>arr[3]</code>, <code>arr[6]</code> -&gt; <code>[8, 7, 2]</code></li><li>子数组2: <code>arr[1]</code>, <code>arr[4]</code> -&gt; <code>[3, 0]</code></li><li>子数组3: <code>arr[2]</code>, <code>arr[5]</code> -&gt; <code>[1, 10]</code></li></ul></li><li>对每个子数组进行插入排序：<ul><li><code>[8, 7, 2]</code> -&gt; <code>[2, 7, 8]</code></li><li><code>[3, 0]</code> -&gt; <code>[0, 3]</code></li><li><code>[1, 10]</code> -&gt; <code>[1, 10]</code></li></ul></li><li>将排序后的元素放回原数组的交错位置。<ul><li><strong>结果数组</strong>: <code>[2, 0, 1, 7, 3, 10, 8]</code></li><li>注意：数组现在比原来更有序了。像 <code>0</code>, <code>1</code>, <code>2</code> 这样的小元素被快速移动到了数组的前端。</li></ul></li></ul><p><strong>第二轮：Gap &#x3D; <code>3 // 2 = 1</code></strong></p><ul><li>现在增量为1，这相当于对整个数组进行一次标准的插入排序。</li><li>待排序数组是 <code>[2, 0, 1, 7, 3, 10, 8]</code>。</li><li>因为这个数组已经“几乎有序”，插入排序会非常快。<ul><li><code>0</code> 会向前移动两位。</li><li><code>1</code> 会向前移动一位。</li><li><code>3</code> 会向前移动一位。</li><li><code>8</code> 会向前移动一位。</li></ul></li><li><strong>最终排序结果</strong>: <code>[0, 1, 2, 3, 7, 8, 10]</code></li></ul><h3 id="3-Python-代码实现-6"><a href="#3-Python-代码实现-6" class="headerlink" title="3. Python 代码实现"></a>3. Python 代码实现</h3><p>下面是使用 Shell 原始增量序列的 Python 代码实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">shell_sort</span>(<span class="params">arr</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    希尔排序函数</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    n = <span class="built_in">len</span>(arr)</span><br><span class="line">    <span class="comment"># 初始增量 gap，并不断缩小</span></span><br><span class="line">    gap = n // <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> gap &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="comment"># 下面的循环是分组后的插入排序</span></span><br><span class="line">        <span class="comment"># i 从 gap 开始，确保每个元素都能作为待插入元素</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(gap, n):</span><br><span class="line">            <span class="comment"># temp 是当前待插入的元素</span></span><br><span class="line">            temp = arr[i]</span><br><span class="line">            <span class="comment"># j 是当前元素所在分组的前一个元素的索引</span></span><br><span class="line">            j = i</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 在当前分组内进行插入排序的比较和移动</span></span><br><span class="line">            <span class="comment"># j &gt;= gap 保证了 j-gap 不会越界</span></span><br><span class="line">            <span class="comment"># arr[j - gap] &gt; temp 是插入排序的核心比较</span></span><br><span class="line">            <span class="keyword">while</span> j &gt;= gap <span class="keyword">and</span> arr[j - gap] &gt; temp:</span><br><span class="line">                arr[j] = arr[j - gap]</span><br><span class="line">                j -= gap</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 将待插入元素放入正确的位置</span></span><br><span class="line">            arr[j] = temp</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 缩小增量</span></span><br><span class="line">        gap //= <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 示例 ---</span></span><br><span class="line">my_list = [<span class="number">8</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="number">2</span>]</span><br><span class="line">shell_sort(my_list)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;排序后的列表:&quot;</span>, my_list)  <span class="comment"># 输出: [0, 1, 2, 3, 7, 8, 10]</span></span><br><span class="line"></span><br><span class="line">another_list = [<span class="number">64</span>, <span class="number">34</span>, <span class="number">25</span>, <span class="number">12</span>, <span class="number">22</span>, <span class="number">11</span>, <span class="number">90</span>]</span><br><span class="line">shell_sort(another_list)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;排序后的列表:&quot;</span>, another_list) <span class="comment"># 输出: [11, 12, 22, 25, 34, 64, 90]</span></span><br></pre></td></tr></table></figure><h3 id="4-算法分析-6"><a href="#4-算法分析-6" class="headerlink" title="4. 算法分析"></a>4. 算法分析</h3><ul><li><p><strong>时间复杂度</strong>:</p><ul><li>希尔排序的时间复杂度分析非常复杂，它<strong>完全取决于所选的增量序列</strong>。</li><li><strong>最坏情况</strong>: 使用 Shell 原始序列 <code>N/2, N/4, ...</code> 时，最坏时间复杂度为 <code>O(n²)</code>。</li><li><strong>平均&#x2F;最好情况</strong>: 使用更优的增量序列（如 Knuth 序列），其时间复杂度可以达到 <code>O(n^(3/2))</code> 甚至 <code>O(n log² n)</code>。它优于简单的 <code>O(n²)</code> 排序算法，但劣于 <code>O(n log n)</code> 的高级排序算法。</li></ul></li><li><p><strong>空间复杂度</strong>: <code>O(1)</code>。</p><ul><li>希尔排序是<strong>原地排序</strong>算法，只需要一个额外的变量 <code>temp</code> 来存储元素，空间是常数级别的。</li></ul></li><li><p><strong>稳定性</strong>: 希尔排序是<strong>不稳定</strong>的。</p><ul><li><strong>解释</strong>：在分组排序中，相隔较远的两个相等元素可能会在它们各自的子数组中被交换，从而导致它们的相对顺序发生改变。例如，在 <code>[5a, 1, 5b]</code> 中，如果 <code>gap=2</code>，<code>5a</code> 和 <code>5b</code> 在同一个子数组，它们的顺序可能不会变。但如果 <code>gap=1</code> 之前有其他 <code>gap</code> 使得 <code>5b</code> 被交换到了 <code>5a</code> 前面，稳定性就被破坏了。</li></ul></li></ul><h3 id="5-小结-5"><a href="#5-小结-5" class="headerlink" title="5. 小结"></a>5. 小结</h3><p><strong>优点</strong>:</p><ul><li><strong>性能优于简单排序</strong>：比冒泡排序、选择排序和插入排序等 <code>O(n²)</code> 算法要快得多。</li><li><strong>实现相对简单</strong>：相比快速排序、归并排序等，代码实现逻辑更简单一些。</li><li><strong>空间效率高</strong>：是原地排序，只需要 <code>O(1)</code> 的额外空间。</li></ul><p><strong>缺点</strong>:</p><ul><li><strong>性能不稳定</strong>：时间复杂度依赖于增量序列，难以精确分析。</li><li><strong>算法不稳定</strong>：不保证相等元素的相对顺序。</li><li><strong>性能瓶颈</strong>：对于大规模数据，其性能不如快速排序、归并排序和堆排序等 <code>O(n log n)</code> 算法。</li></ul><p>总的来说，希尔排序是一种在简单排序和高级排序之间的“中间地带”算法，适用于中等规模的数据集，并且在对内存要求严格的场景下有一定优势。</p><hr><h2 id="八、计数排序"><a href="#八、计数排序" class="headerlink" title="八、计数排序"></a>八、计数排序</h2><h3 id="1-什么是计数排序？"><a href="#1-什么是计数排序？" class="headerlink" title="1. 什么是计数排序？"></a>1. 什么是计数排序？</h3><p>计数排序是一种<strong>非比较型</strong>的整数排序算法，它的核心思想与我们之前讨论的比较排序算法（如快速排序、归并排序）完全不同。它不是通过比较元素大小来排序，而是通过<strong>统计每个整数出现的次数</strong>来确定元素的位置。</p><p>这个算法的效率非常高，可以达到线性时间复杂度 <code>O(n)</code>，但它有一个重要的<strong>限制</strong>：它只适用于<strong>整数</strong>，并且这些整数需要在一个<strong>相对较小的范围</strong>内。</p><h4 id="a-核心思想-4"><a href="#a-核心思想-4" class="headerlink" title="a. 核心思想"></a>a. 核心思想</h4><ol><li><strong>计数 (Counting)</strong>：找出待排序数组中最大和最小的元素，然后创建一个“计数数组”（或称为“桶”），其大小足以覆盖从最小到最大的整个整数范围。遍历待排序数组，将每个元素出现的次数记录在计数数组的相应位置上。</li><li><strong>累加 (Cumulative Sum)</strong>：修改计数数组，使其每个位置上的值是“小于或等于”该索引的元素总数。这样，计数数组就存储了每个元素在排序后应该出现的<strong>最终位置</strong>信息。</li><li><strong>排序 (Placing)</strong>：创建一个新的输出数组。<strong>反向遍历</strong>原始的待排序数组，根据计数数组中的位置信息，将每个元素直接放入输出数组的正确位置，同时更新计数数组中的计数值。</li></ol><hr><h3 id="2-图解示例-7"><a href="#2-图解示例-7" class="headerlink" title="2. 图解示例"></a>2. 图解示例</h3><p>我们用一个简单的例子 <code>[4, 2, 2, 8, 3, 3, 1]</code> 来演示计数排序的过程。</p><p><strong>1. 找出范围并创建计数数组</strong></p><ul><li>数组中的最大值是 <code>8</code>。</li><li>创建一个大小为 <code>8 + 1 = 9</code> 的计数数组 <code>count_arr</code>，索引从 0 到 8，初始值全为 0。<br><code>count_arr = [0, 0, 0, 0, 0, 0, 0, 0, 0]</code></li></ul><p><strong>2. 统计元素出现次数</strong></p><ul><li>遍历原始数组 <code>[4, 2, 2, 8, 3, 3, 1]</code>：<ul><li>遇到 <code>4</code>，<code>count_arr[4]</code> 加 1。</li><li>遇到 <code>2</code>，<code>count_arr[2]</code> 加 1。</li><li>…</li></ul></li><li>最终得到的计数数组为：<br><code>count_arr = [0, 1, 2, 2, 1, 0, 0, 0, 1]</code><br>(含义：数字1出现1次，2出现2次，3出现2次，4出现1次，8出现1次)</li></ul><p><strong>3. 计算累加和</strong></p><ul><li>修改 <code>count_arr</code>，让每个位置存储小于等于当前索引的元素总数。<ul><li><code>count_arr[1] += count_arr[0]</code> -&gt; <code>1 + 0 = 1</code></li><li><code>count_arr[2] += count_arr[1]</code> -&gt; <code>2 + 1 = 3</code></li><li><code>count_arr[3] += count_arr[2]</code> -&gt; <code>2 + 3 = 5</code></li><li><code>count_arr[4] += count_arr[3]</code> -&gt; <code>1 + 5 = 6</code></li><li>…</li></ul></li><li>最终得到的累加数组为：<br><code>count_arr = [0, 1, 3, 5, 6, 6, 6, 6, 7]</code><br>(含义：小于等于1的数有1个，小于等于2的数有3个，小于等于3的数有5个… 这个值减1就是该数字在排序后数组中的最后一次出现的位置索引)</li></ul><p><strong>4. 放置到输出数组 (反向遍历)</strong></p><ul><li><p>创建一个与原始数组等长的输出数组 <code>output_arr</code>。</p></li><li><p><strong>从后向前</strong>遍历原始数组 <code>[4, 2, 2, 8, 3, 3, 1]</code>：</p><ul><li><strong>元素 <code>1</code></strong>: <code>count_arr[1]</code> 是 <code>1</code>。将 <code>1</code> 放到 <code>output_arr</code> 的 <code>1-1=0</code> 索引处。然后 <code>count_arr[1]</code> 减 1。<br><code>output = [1, _, _, _, _, _, _]</code>, <code>count_arr[1]=0</code></li><li><strong>元素 <code>3</code> (第二个)</strong>: <code>count_arr[3]</code> 是 <code>5</code>。将 <code>3</code> 放到 <code>output_arr</code> 的 <code>5-1=4</code> 索引处。<code>count_arr[3]</code> 减 1。<br><code>output = [1, _, _, _, 3, _, _]</code>, <code>count_arr[3]=4</code></li><li><strong>元素 <code>3</code> (第一个)</strong>: <code>count_arr[3]</code> 是 <code>4</code>。将 <code>3</code> 放到 <code>output_arr</code> 的 <code>4-1=3</code> 索引处。<code>count_arr[3]</code> 减 1。<br><code>output = [1, _, _, 3, 3, _, _]</code>, <code>count_arr[3]=3</code></li><li><strong>元素 <code>8</code></strong>: <code>count_arr[8]</code> 是 <code>7</code>。将 <code>8</code> 放到 <code>output_arr</code> 的 <code>7-1=6</code> 索引处。<code>count_arr[8]</code> 减 1。<br><code>output = [1, _, _, 3, 3, _, 8]</code>, <code>count_arr[8]=6</code></li><li>… 以此类推 …</li></ul></li><li><p><strong>最终排序结果</strong>: <code>[1, 2, 2, 3, 3, 4, 8]</code></p></li></ul><p><strong>为什么要反向遍历？</strong><br>反向遍历是为了保证排序的<strong>稳定性</strong>。当遇到重复元素时（如两个3），原始数组中排在后面的<code>3</code>会先被放入输出数组的靠后位置，这样它们的相对顺序就保持不变了。</p><hr><h3 id="3-Python-代码实现-7"><a href="#3-Python-代码实现-7" class="headerlink" title="3. Python 代码实现"></a>3. Python 代码实现</h3><p>下面提供了两个版本的实现：一个基础版（只处理非负整数）和一个更通用的优化版（处理任意整数范围）。</p><h4 id="a-基础版-处理非负整数"><a href="#a-基础版-处理非负整数" class="headerlink" title="a. 基础版 (处理非负整数)"></a>a. 基础版 (处理非负整数)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">counting_sort_basic</span>(<span class="params">arr</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    计数排序基础版（只适用于非负整数）</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 1. 处理边界情况</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(arr) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. 找到最大值以确定计数数组的大小</span></span><br><span class="line">    max_val = <span class="built_in">max</span>(arr)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 3. 创建并填充计数数组</span></span><br><span class="line">    count_arr = [<span class="number">0</span>] * (max_val + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> arr:</span><br><span class="line">        count_arr[num] += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 4. 计算累加和</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(count_arr)):</span><br><span class="line">        count_arr[i] += count_arr[i-<span class="number">1</span>]</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 5. 创建输出数组并从后向前遍历原数组以放置元素</span></span><br><span class="line">    output_arr = [<span class="number">0</span>] * <span class="built_in">len</span>(arr)</span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> <span class="built_in">reversed</span>(arr):</span><br><span class="line">        <span class="comment"># 找到 num 在排序后应该在的位置</span></span><br><span class="line">        position = count_arr[num] - <span class="number">1</span></span><br><span class="line">        output_arr[position] = num</span><br><span class="line">        <span class="comment"># 处理重复数字，将下一个同样值的数字放在前一个位置</span></span><br><span class="line">        count_arr[num] -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> output_arr</span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 示例 ---</span></span><br><span class="line">my_list = [<span class="number">4</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>]</span><br><span class="line">sorted_list = counting_sort_basic(my_list)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;基础版排序后的列表:&quot;</span>, sorted_list) <span class="comment"># 输出: [1, 2, 2, 3, 3, 4, 8]</span></span><br></pre></td></tr></table></figure><h4 id="b-优化版-处理任意整数范围，包括负数"><a href="#b-优化版-处理任意整数范围，包括负数" class="headerlink" title="b. 优化版 (处理任意整数范围，包括负数)"></a>b. 优化版 (处理任意整数范围，包括负数)</h4><p>这个版本通过引入偏移量（<code>offset</code>）来处理负数或不从0开始的整数范围，从而节省空间。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">counting_sort_optimized</span>(<span class="params">arr</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    计数排序优化版（适用于任意整数范围）</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(arr) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 1. 找到最大值和最小值以确定范围</span></span><br><span class="line">    max_val = <span class="built_in">max</span>(arr)</span><br><span class="line">    min_val = <span class="built_in">min</span>(arr)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 2. 创建计数数组，大小为 (max - min + 1)</span></span><br><span class="line">    <span class="comment">#    offset 用于将原始数值映射到计数数组的索引 (0, 1, 2...)</span></span><br><span class="line">    offset = min_val</span><br><span class="line">    count_arr_size = max_val - min_val + <span class="number">1</span></span><br><span class="line">    count_arr = [<span class="number">0</span>] * count_arr_size</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 3. 填充计数数组</span></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> arr:</span><br><span class="line">        count_arr[num - offset] += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 4. 计算累加和</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, count_arr_size):</span><br><span class="line">        count_arr[i] += count_arr[i-<span class="number">1</span>]</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 5. 创建输出数组并放置元素</span></span><br><span class="line">    output_arr = [<span class="number">0</span>] * <span class="built_in">len</span>(arr)</span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> <span class="built_in">reversed</span>(arr):</span><br><span class="line">        position = count_arr[num - offset] - <span class="number">1</span></span><br><span class="line">        output_arr[position] = num</span><br><span class="line">        count_arr[num - offset] -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> output_arr</span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 示例 ---</span></span><br><span class="line">my_list_neg = [-<span class="number">5</span>, <span class="number">5</span>, -<span class="number">9</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">sorted_list_neg = counting_sort_optimized(my_list_neg)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;优化版排序后的列表:&quot;</span>, sorted_list_neg) <span class="comment"># 输出: [-9, -5, 0, 1, 1, 5, 10]</span></span><br></pre></td></tr></table></figure><hr><h3 id="4-算法分析-7"><a href="#4-算法分析-7" class="headerlink" title="4. 算法分析"></a>4. 算法分析</h3><ul><li><p><strong>时间复杂度</strong>: <code>O(n + k)</code></p><ul><li><code>n</code> 是待排序数组的元素个数。</li><li><code>k</code> 是整数的范围（即 <code>max_val - min_val + 1</code>）。</li><li>整个过程包括几次对大小为 <code>n</code> 或 <code>k</code> 的数组的线性扫描，所以是 <code>O(n + k)</code>。</li><li>当 <code>k</code> 的大小与 <code>n</code> 相当或更小时（<code>k = O(n)</code>），时间复杂度可以看作是<strong>线性时间 <code>O(n)</code></strong>，这比任何基于比较的排序算法 <code>O(n log n)</code> 都要快。</li></ul></li><li><p><strong>空间复杂度</strong>: <code>O(n + k)</code></p><ul><li>需要一个大小为 <code>k</code> 的 <code>count_arr</code> 和一个大小为 <code>n</code> 的 <code>output_arr</code>。</li></ul></li><li><p><strong>稳定性</strong>: 计数排序是<strong>稳定</strong>的，前提是正确实现（即在构建输出数组时反向遍历原始数组）。</p></li></ul><h3 id="5-小结-6"><a href="#5-小结-6" class="headerlink" title="5. 小结"></a>5. 小结</h3><p><strong>优点</strong>:</p><ul><li><strong>速度极快</strong>：在特定条件下，它是最快的排序算法之一。</li><li><strong>稳定性</strong>：是一种稳定的排序算法。</li></ul><p><strong>缺点</strong>:</p><ul><li><strong>适用范围窄</strong>：只能用于整数排序。</li><li><strong>空间浪费</strong>：当整数范围 <code>k</code> 远大于元素数量 <code>n</code> 时（例如，排序 <code>[1, 10, 1000000]</code>），会造成巨大的空间浪费，此时性能会急剧下降。</li></ul><p>因此，计数排序是一种非常特殊的、在特定场景下极为高效的算法，常被用作更复杂算法（如基数排序）的子过程。</p><hr><h2 id="九、总结"><a href="#九、总结" class="headerlink" title="九、总结"></a>九、总结</h2><h3 id="1-主流排序算法综合对比表"><a href="#1-主流排序算法综合对比表" class="headerlink" title="1. 主流排序算法综合对比表"></a>1. 主流排序算法综合对比表</h3><table><thead><tr><th align="left">特性 &#x2F; 算法</th><th align="left">冒泡排序 (Bubble)</th><th align="left">选择排序 (Selection)</th><th align="left">插入排序 (Insertion)</th><th align="left">希尔排序 (Shell)</th><th align="left">归并排序 (Merge)</th><th align="left">快速排序 (Quick)</th><th align="left">堆排序 (Heap)</th><th align="left">计数排序 (Counting)</th></tr></thead><tbody><tr><td align="left"><strong>时间复杂度 (平均)</strong></td><td align="left"><strong>O(n²)</strong></td><td align="left"><strong>O(n²)</strong></td><td align="left"><strong>O(n²)</strong></td><td align="left">O(n log n) ~ O(n²) ¹</td><td align="left"><strong>O(n log n)</strong></td><td align="left"><strong>O(n log n)</strong></td><td align="left"><strong>O(n log n)</strong></td><td align="left"><strong>O(n + k)</strong> ²</td></tr><tr><td align="left"><strong>时间复杂度 (最坏)</strong></td><td align="left">O(n²)</td><td align="left">O(n²)</td><td align="left">O(n²)</td><td align="left">O(n²) (取决于增量)</td><td align="left">O(n log n)</td><td align="left">O(n²) (需优化避免)</td><td align="left">O(n log n)</td><td align="left">O(n + k)</td></tr><tr><td align="left"><strong>时间复杂度 (最好)</strong></td><td align="left">O(n) (优化后)</td><td align="left">O(n²)</td><td align="left">O(n)</td><td align="left">O(n log n)</td><td align="left">O(n log n)</td><td align="left">O(n log n)</td><td align="left">O(n log n)</td><td align="left">O(n + k)</td></tr><tr><td align="left"><strong>空间复杂度</strong></td><td align="left"><strong>O(1)</strong></td><td align="left"><strong>O(1)</strong></td><td align="left"><strong>O(1)</strong></td><td align="left"><strong>O(1)</strong></td><td align="left"><strong>O(n)</strong></td><td align="left"><strong>O(log n)</strong> (平均)</td><td align="left"><strong>O(1)</strong></td><td align="left"><strong>O(n + k)</strong></td></tr><tr><td align="left"><strong>稳定性</strong></td><td align="left"><strong>稳定</strong></td><td align="left"><strong>不稳定</strong></td><td align="left"><strong>稳定</strong></td><td align="left"><strong>不稳定</strong></td><td align="left"><strong>稳定</strong></td><td align="left"><strong>不稳定</strong></td><td align="left"><strong>不稳定</strong></td><td align="left"><strong>稳定</strong></td></tr><tr><td align="left"><strong>排序方式</strong></td><td align="left">In-place (原地)</td><td align="left">In-place (原地)</td><td align="left">In-place (原地)</td><td align="left">In-place (原地)</td><td align="left">Out-of-place (非原地)</td><td align="left">In-place (原地)</td><td align="left">In-place (原地)</td><td align="left">Out-of-place (非原地)</td></tr><tr><td align="left"><strong>算法类型</strong></td><td align="left">比较排序</td><td align="left">比较排序</td><td align="left">比较排序</td><td align="left">比较排序</td><td align="left">比较排序 (分治)</td><td align="left">比较排序 (分治)</td><td align="left">比较排序 (选择)</td><td align="left"><strong>非比较排序</strong></td></tr><tr><td align="left"><strong>核心思想</strong></td><td align="left">相邻元素比较交换，最大值“冒泡”到末尾</td><td align="left">每次从未排序部分找最小元素放到已排序末尾</td><td align="left">将元素插入到已排序序列的正确位置</td><td align="left">分组的插入排序，逐步缩小增量</td><td align="left">分解成小数组，排序后合并</td><td align="left">选定基准，分区后递归排序</td><td align="left">构建最大堆，将堆顶与末尾交换并调整</td><td align="left">统计每个元素出现的次数来确定位置</td></tr><tr><td align="left"><strong>主要优点</strong></td><td align="left">实现简单，易于理解</td><td align="left">实现简单，交换次数少</td><td align="left">对小规模或几乎有序的数据效率高</td><td align="left">比 O(n²) 算法快，且为原地排序</td><td align="left">性能极为稳定，适用于链表和外部排序</td><td align="left"><strong>平均速度最快</strong>，常数因子小，原地排序</td><td align="left">保证 O(n log n) 最坏性能且为原地排序</td><td align="left"><strong>速度极快</strong>，可达线性时间</td></tr><tr><td align="left"><strong>主要缺点</strong></td><td align="left"><strong>效率极低</strong>，实际中不使用</td><td align="left"><strong>效率极低</strong>，无法利用数据初始顺序</td><td align="left">对大规模乱序数据效率低</td><td align="left">性能依赖增量序列，不稳定</td><td align="left">需要 O(n) 额外空间</td><td align="left">最坏情况性能差 (O(n²))，不稳定</td><td align="left">实际平均性能常数因子大于快速排序，不稳定</td><td align="left"><strong>适用范围窄</strong> (整数且范围k不能太大)，空间开销大</td></tr><tr><td align="left"><strong>适用场景</strong></td><td align="left">教学演示</td><td align="left">教学演示，或当数据交换成本极高时</td><td align="left">数据量小，或数据基本有序</td><td align="left">中等规模数据集，对内存要求严格</td><td align="left">内存充裕，需要稳定排序或处理外部数据</td><td align="left"><strong>通用场景</strong>，大多数情况下的首选</td><td align="left">需要可靠性能保证和低空间占用的场景</td><td align="left">整数排序，且数据范围 k 不比 n 大很多</td></tr></tbody></table><h3 id="2-表格注解与总结"><a href="#2-表格注解与总结" class="headerlink" title="2. 表格注解与总结"></a>2. 表格注解与总结</h3><p>¹ <strong>希尔排序的复杂度</strong>: 它的时间复杂度与所选的“增量序列”密切相关，分析非常复杂。虽然其最坏情况是 O(n²)，但在良好增量序列下，其性能远超一般 O(n²) 算法，接近 O(n log n)。</p><p>² <strong>k 的含义</strong>: 在计数排序中，<code>k</code> 代表待排序数据中最大值与最小值之差，即 <code>max(arr) - min(arr)</code>。</p><h3 id="3-如何选择排序算法？"><a href="#3-如何选择排序算法？" class="headerlink" title="3. 如何选择排序算法？"></a>3. 如何选择排序算法？</h3><ul><li><strong>追求极致性能，且不要求稳定性</strong>：<strong>快速排序</strong>通常是首选。现代编程语言的内置排序函数（如 Python 的 <code>sort()</code>）通常是基于快速排序的变体（如 IntroSort）或结合了多种排序思想的混合算法（如 Timsort）。</li><li><strong>需要稳定的排序结果</strong>：<strong>归并排序</strong>是最佳选择。例如，当你需要按多个字段排序时（先按年龄排，年龄相同时保持原始顺序），稳定性至关重要。</li><li><strong>关心最坏情况的性能和内存占用</strong>：<strong>堆排序</strong>能提供 O(n log n) 的最坏情况时间保证和 O(1) 的空间复杂度，非常可靠。</li><li><strong>数据规模非常小，或基本有序</strong>：<strong>插入排序</strong>的简单性和高效性使其成为理想选择。这也是 Timsort 等高级算法在处理小数据块时会切换到插入排序的原因。</li><li><strong>排序的是整数且范围不大</strong>：<strong>计数排序</strong>可以提供无与伦比的线性时间性能。它是基数排序等更复杂算法的基础。</li><li><strong>教学或理解算法思想</strong>：<strong>冒泡排序</strong>和<strong>选择排序</strong>虽然效率低下，但它们的逻辑简单直观，是学习排序算法的绝佳起点。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通信方式对比—UART/SPI/IIC</title>
      <link href="/2025/08/21/%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E5%AF%B9%E6%AF%94%E2%80%94UART-SPI-IIC/"/>
      <url>/2025/08/21/%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E5%AF%B9%E6%AF%94%E2%80%94UART-SPI-IIC/</url>
      
        <content type="html"><![CDATA[<h2 id="一、UART"><a href="#一、UART" class="headerlink" title="一、UART"></a>一、UART</h2><p>UART（Universal Asynchronous Receiver&#x2F;Transmitter，通用异步收发器）是一种非常基础且广泛使用的串行通信协议。它不是像SPI或I²C那样的“总线”，而通常是一种点对点的通信方式。几乎所有的微控制器和计算机都包含UART硬件，它也是我们最常接触到的调试接口（例如通过USB转串口模块在电脑上查看单片机的打印信息）。</p><hr><h3 id="1-UART的核心概念"><a href="#1-UART的核心概念" class="headerlink" title="1. UART的核心概念"></a>1. UART的核心概念</h3><ul><li><strong>通用（Universal）</strong>: 意味着它的通信参数（如速度、数据位、校验位等）是可配置的，可以与各种不同的设备进行通信。</li><li><strong>异步（Asynchronous）</strong>: 这是UART最核心的特点。与SPI和I²C不同，UART通信的双方<strong>没有共享的时钟线</strong>。发送方和接收方必须事先约定好相同的通信速率（波特率），接收方依靠数据信号本身的变化（起始位）来开始同步并按约定的速率接收数据。</li><li><strong>收发器（Receiver&#x2F;Transmitter）</strong>: UART硬件模块通常包含一个独立的接收器和一个独立的发送器，因此可以同时进行数据的接收和发送，实现 <strong>全双工（Full-Duplex）</strong> 通信。</li></ul><hr><h3 id="2-UART的硬件接口"><a href="#2-UART的硬件接口" class="headerlink" title="2. UART的硬件接口"></a>2. UART的硬件接口</h3><p><img src="/img_1/03.png" alt="UART连接示意图"></p><p>UART通信最少只需要两根线：</p><table><thead><tr><th align="left">引脚名称</th><th align="left">功能描述</th></tr></thead><tbody><tr><td align="left"><strong>TX (Transmit)</strong></td><td align="left"><strong>发送数据线</strong>。发送设备的数据从该引脚输出。</td></tr><tr><td align="left"><strong>RX (Receive)</strong></td><td align="left"><strong>接收数据线</strong>。接收设备的数据从该引脚输入。</td></tr></tbody></table><p><strong>连接方式</strong>:<br>为了实现双向通信，两台设备的连接方式是<strong>交叉连接</strong>：</p><ul><li>设备A的 <code>TX</code> 连接到 设备B的 <code>RX</code></li><li>设备A的 <code>RX</code> 连接到 设备B的 <code>TX</code></li><li>通常还需要一根 <strong>地线（GND）</strong> 来提供共同的参考电平，保证信号的正确识别。所以，<strong>最基本的UART通信是三线制（TX, RX, GND）</strong>。</li></ul><hr><h3 id="3-UART的数据帧格式（The-Protocol）"><a href="#3-UART的数据帧格式（The-Protocol）" class="headerlink" title="3. UART的数据帧格式（The Protocol）"></a>3. UART的数据帧格式（The Protocol）</h3><p>由于没有时钟线，UART通过一种标准的数据包结构（称为“帧”）来确保数据的正确解析。一个UART数据帧通常包含以下几个部分：</p><p><img src="/img_1/04.png" alt="UART的常用数据帧格式（无校验位）"></p><ol><li><strong>空闲状态（Idle State）</strong>: 在没有数据传输时，TX线保持在高电平。</li><li><strong>起始位（Start Bit）</strong>:<ul><li>通信的开始信号。</li><li>发送方将TX线从高电平拉低，并保持一个时钟周期的时间。</li><li>这个<strong>下降沿</strong>告诉接收方：“注意，数据要来了！”。接收方检测到这个下降沿后，会启动自己的内部时钟，准备在后续的特定时间点采样数据位。</li><li>起始位<strong>固定为1位</strong>，且<strong>电平为低（逻辑0）</strong>。</li></ul></li><li><strong>数据位（Data Bits）</strong>:<ul><li>这是真正要传输的有效数据。</li><li>数据位的长度是可配置的，通常为5、6、7、8位，最常见的是<strong>8位</strong>（一个字节）。</li><li>数据传输的顺序是<strong>最低有效位（LSB）在前，最高有效位（MSB）在后</strong>。例如，要发送字符’C’（ASCII码为<code>0x41</code>，二进制为<code>0100 0001</code>），发送的比特流顺序是 <code>1 0 0 0 0 0 1 0</code>。</li></ul></li></ol><p><img src="/img_1/05.png" alt="发送大写字母“A”"></p><ol start="4"><li><strong>校验位（Parity Bit） - 可选</strong>:<ul><li>一种简单的错误检测机制。</li><li>它的值取决于数据位中“1”的数量。</li><li><strong>无校验（None Parity）</strong>: 最常用，不使用校验位。</li><li><strong>偶校验（Even Parity）</strong>: 如果数据位中“1”的个数是奇数，则校验位置为1；如果是偶数，则校验位置为0。目标是使数据位+校验位中“1”的总数为偶数。</li><li><strong>奇校验（Odd Parity）</strong>: 与偶校验相反，目标是使数据位+校验位中“1”的总数为奇数。</li><li>校验位只能检测出奇数个位的错误，无法检测出偶数个位的错误，也无法纠正错误，因此是一种较弱的校验方式。</li></ul></li><li><strong>停止位（Stop Bit(s)）</strong>:<ul><li>标志着一个数据帧的结束。</li><li>发送方将TX线拉高，并保持至少一个时钟周期的时间。</li><li>停止位的长度可以是1位、1.5位或2位，最常用的是<strong>1位</strong>。</li><li>停止位确保了无论最后一个数据位是0还是1，总线在帧结束后都会回到高电平的空闲状态，为下一个起始位（下降沿）做准备。</li></ul></li></ol><hr><h3 id="4-UART的同步机制和波特率"><a href="#4-UART的同步机制和波特率" class="headerlink" title="4. UART的同步机制和波特率"></a>4. UART的同步机制和波特率</h3><ul><li><strong>波特率（Baud Rate）</strong>: 这是理解异步通信的关键。波特率表示每秒传输的**码元（符号）**数量。在UART中，一个码元就是一位（也就是一个高低电平，例如上面最常用的一帧数据帧是10位，也就是10个高低电平），所以波特率等同于比特率（bits per second, bps）。</li><li><strong>同步原理</strong>:<ol><li><strong>约定</strong>: 通信双方必须预先配置成<strong>完全相同</strong>的波特率（以及数据位、校验位、停止位配置）。常见的波特率有9600, 19200, 38400, 57600, 115200等。</li><li><strong>触发</strong>: 接收方持续监测RX线。当检测到从高到低的跳变（起始位）时，它启动一个内部定时器。</li><li><strong>采样</strong>: 接收方并不会在电平变化时立即采样，而是在每个位的<strong>中间时刻</strong>进行采样。它会等待起始位开始后的1.5个位周期时间（即第一个数据位的中心），采样D0。然后每隔1个位周期时间，依次采样D1, D2… 直到所有数据位和校验位都被采样。</li><li><strong>容错</strong>: 在位的中心采样可以最大程度地容忍发送方和接收方之间微小的时钟频率差异。只要在采样完整个帧的过程中，累积的误差不超过半个位周期，通信就能成功。</li></ol></li></ul><hr><h3 id="5-物理层标准：不仅仅是0和1"><a href="#5-物理层标准：不仅仅是0和1" class="headerlink" title="5. 物理层标准：不仅仅是0和1"></a>5. 物理层标准：不仅仅是0和1</h3><p>UART定义了协议层（数据帧格式），但没有严格规定物理层的电压标准。这导致了多种物理接口的存在：</p><ul><li><strong>TTL&#x2F;CMOS电平</strong>:<ul><li>这是微控制器（MCU）内部和板级通信最常用的电平。</li><li>逻辑’1’ ≈ VCC (例如 3.3V 或 5V)</li><li>逻辑’0’ ≈ GND (0V)</li><li>抗干扰能力差，传输距离短（通常在1米以内）。</li></ul></li></ul><p><img src="/img_1/06.png" alt="TTL电平"></p><ul><li><strong>RS-232</strong>:<ul><li>一种经典的串口标准，常见于旧式电脑的COM口和工业设备。</li><li>它使用<strong>负逻辑</strong>和更高的电压来增强抗干扰能力和传输距离（可达15米）。</li><li>逻辑’1’ (Mark) &#x3D; -3V 到 -15V</li><li>逻辑’0’ (Space) &#x3D; +3V 到 +15V</li><li>MCU的TTL电平UART要与RS-232设备通信，<strong>必须</strong>使用<strong>电平转换芯片</strong>（如 MAX232）。直接连接会损坏设备！</li></ul></li></ul><p><img src="/img_1/07.png" alt="RS232电平"></p><ul><li><strong>RS-485 &#x2F; RS-422</strong>:<ul><li>采用<strong>差分信号</strong>传输，抗共模干扰能力极强。</li><li>使用两根线（A和B）的电压差来表示逻辑。例如，V(A) &gt; V(B) 表示’1’，V(B) &gt; V(A) 表示’0’。</li><li><strong>RS-422</strong> 支持一点对多点（一个主发送，多个从接收）。</li><li><strong>RS-485</strong> 在RS-422基础上改进，支持多点对多点（总线上任何设备都可以成为主发送方），是真正的多机通信总线。</li><li>传输距离非常远（可达1200米），速率也很高。同样需要电平转换芯片（如 MAX485）。</li></ul></li></ul><p><img src="/img_1/08.png" alt="RS485的差分信号"><br><img src="/img_1/09.png" alt="三种接口对比"></p><hr><h3 id="6-UART的优缺点"><a href="#6-UART的优缺点" class="headerlink" title="6. UART的优缺点"></a>6. UART的优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol><li><strong>实现简单</strong>: 只需要两根线（不计地线），硬件和软件实现都非常简单。</li><li><strong>广泛支持</strong>: 几乎所有微控制器和处理器都内置了UART硬件。</li><li><strong>协议灵活</strong>: 通信参数可调，适应性强。</li><li><strong>无需时钟线</strong>: 节省了一个引脚，简化了布线。</li><li><strong>全双工通信</strong>: 可以同时收发数据。</li></ol><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol><li><strong>异步限制速度</strong>: 由于依赖内部时钟同步，波特率不能无限高，否则时钟误差累积会导致采样错误。</li><li><strong>协议开销</strong>: 每个字节都需要额外的起始位和停止位，降低了有效数据传输率。例如，传输8位数据至少需要10位（1起始+8数据+1停止），开销为20%。</li><li><strong>点对点通信</strong>: 标准UART不支持多设备总线（没有地址机制）。（注：RS-485物理层可以实现多点，但需要在应用层软件实现寻址和仲裁）。</li><li><strong>无硬件应答</strong>: 发送方不知道接收方是否成功接收了数据。可靠性需要上层协议来保证。</li><li><strong>错误检测能力弱</strong>: 奇偶校验只能检测部分错误，无法纠错。</li></ol><hr><h3 id="7-小结"><a href="#7-小结" class="headerlink" title="7. 小结"></a>7. 小结</h3><ul><li><p><strong>UART (Universal Asynchronous Receiver&#x2F;Transmitter - 通用异步收发器):</strong> 这是一个<strong>通信协议和硬件实现</strong>。它定义了数据是如何被打包成帧（起始位、数据位、奇偶校验位、停止位）进行异步传输的。UART 工作在逻辑电平（TTL&#x2F;CMOS），例如 0V 代表逻辑’0’，3.3V&#x2F;5V 代表逻辑’1’。它本身不定义电压、电流或连接器标准，主要用于芯片与芯片之间（板级）的通信。</p></li><li><p><strong>RS232 和 RS485 (Recommended Standard):</strong> 这两者是<strong>物理层电气标准</strong>。它们不关心数据帧的格式（那是 UART 的工作），而是定义了如何用<strong>电压信号</strong>来表示逻辑’0’和’1’，以及相关的电气特性（如电压、阻抗、线缆长度、速率等）。它们是用来将 UART 的逻辑信号转换为能够进行更长距离、更稳定传输的电信号。</p></li></ul><p><strong>简单比喻：</strong></p><ul><li><strong>UART</strong> 就像是你要说的<strong>语言和语法</strong>（例如，一句话要有主谓宾）。</li><li><strong>RS232</strong> 和 <strong>RS485</strong> 就像是你说话的<strong>方式</strong>：是通过电话大声说（RS232），还是通过对讲机系统让多个人听到（RS485）。</li></ul><p>它们经常协同工作：一个微控制器（MCU）的 <strong>UART</strong> 硬件生成数据帧，然后通过一个 <strong>RS232</strong> 或 <strong>RS485</strong> 收发器（Transceiver IC）转换成相应的电平信号，再通过线缆发送出去。</p><hr><h3 id="UART-vs-RS232-vs-RS485-详细对比表"><a href="#UART-vs-RS232-vs-RS485-详细对比表" class="headerlink" title="UART vs. RS232 vs. RS485 详细对比表"></a><strong>UART vs. RS232 vs. RS485 详细对比表</strong></h3><table><thead><tr><th align="left">特性 &#x2F; 类别</th><th align="left">UART (逻辑层)</th><th align="left">RS232 (物理层)</th><th align="left">RS485 (物理层)</th></tr></thead><tbody><tr><td align="left"><strong>基本定义</strong></td><td align="left"><strong>通信协议</strong>和硬件模块，定义数据帧格式</td><td align="left"><strong>物理层电气标准</strong>，定义信号电压和引脚</td><td align="left"><strong>物理层电气标准</strong>，定义差分信号和总线</td></tr><tr><td align="left"><strong>信号电平</strong></td><td align="left"><strong>逻辑电平 (TTL&#x2F;CMOS)</strong><br>• 逻辑 ‘0’: ~0V<br>• 逻辑 ‘1’: ~3.3V 或 5V</td><td align="left"><strong>单端、高电压、反逻辑</strong><br>• 逻辑 ‘0’ (Mark): +3V 到 +15V<br>• 逻辑 ‘1’ (Space): -3V 到 -15V</td><td align="left"><strong>差分信号</strong><br>• 逻辑 ‘1’: A-B &gt; +200mV<br>• 逻辑 ‘0’: A-B &lt; -200mV</td></tr><tr><td align="left"><strong>通信模式</strong></td><td align="left"><strong>点对点 (Point-to-Point)</strong><br>一个设备直接连接另一个设备</td><td align="left"><strong>点对点 (Point-to-Point)</strong><br>一个驱动器 (Driver) 连接一个接收器 (Receiver)</td><td align="left"><strong>多点 (Multi-Drop &#x2F; Multi-Point)</strong><br>多个设备可以挂在同一总线上</td></tr><tr><td align="left"><strong>双工模式</strong></td><td align="left"><strong>全双工 (Full-Duplex)</strong><br>独立的 TX 和 RX 线，可同时收发</td><td align="left"><strong>全双工 (Full-Duplex)</strong><br>独立的 TXD 和 RXD 线</td><td align="left"><strong>半双工 (Half-Duplex)</strong> (2线制，最常见)<br><strong>全双工 (Full-Duplex)</strong> (4线制)</td></tr><tr><td align="left"><strong>所需线缆数</strong> (最小)</td><td align="left"><strong>2根 + GND</strong><br>(TX, RX, GND)</td><td align="left"><strong>3根</strong><br>(TXD, RXD, GND)</td><td align="left"><strong>2根</strong> (半双工: A, B)<br><strong>4根</strong> (全双工: TX_A&#x2F;B, RX_A&#x2F;B)</td></tr><tr><td align="left"><strong>通信距离</strong></td><td align="left"><strong>非常短</strong><br>通常在同一块PCB上，最多数米</td><td align="left"><strong>较短</strong><br>标准为 15米 (50英尺) 左右</td><td align="left"><strong>非常长</strong><br>标准可达 <strong>1200米 (4000英尺)</strong></td></tr><tr><td align="left"><strong>通信速率</strong></td><td align="left">很高（板级），可达数 Mbps</td><td align="left"><strong>较低</strong><br>标准为 20 kbps，实际常用 115200 bps</td><td align="left"><strong>很高</strong><br>可达 10 Mbps 或更高 (速率与距离成反比)</td></tr><tr><td align="left"><strong>抗噪能力</strong></td><td align="left"><strong>差</strong><br>逻辑电平很容易受干扰</td><td align="left"><strong>一般</strong><br>比 TTL 好，但单端信号仍易受共模噪声影响</td><td align="left"><strong>极好</strong><br>差分信号能有效抵消共模噪声</td></tr><tr><td align="left"><strong>总线上的设备数</strong></td><td align="left"><strong>2个</strong> (1 对 1)</td><td align="left"><strong>2个</strong> (1个驱动器, 1个接收器)</td><td align="left"><strong>最多 32 个“单位负载”</strong><br>(现代收发器可支持128或256个节点)</td></tr><tr><td align="left"><strong>接地要求</strong></td><td align="left"><strong>必须共地</strong><br>信号以地为参考</td><td align="left"><strong>必须共地</strong><br>信号以地为参考</td><td align="left"><strong>需要信号地线</strong><br>以保证设备间的共模电压在允许范围内</td></tr><tr><td align="left"><strong>典型应用</strong></td><td align="left">• 芯片间通信<br>• 蓝牙模块<br>• GPS模块</td><td align="left">• PC COM 端口<br>• 工业仪表 (旧)<br>• 调试接口</td><td align="left">• <strong>工业自动化 (Modbus)</strong><br>• DMX512 舞台灯光<br>• 楼宇自控</td></tr><tr><td align="left"><strong>优点</strong></td><td align="left">• 硬件集成在MCU中<br>• 协议简单，易于实现</td><td align="left">• 简单，广泛支持<br>• 比TTL电平稳定</td><td align="left">• <strong>长距离传输</strong><br>• <strong>强大的抗干扰能力</strong><br>• <strong>支持多节点组网</strong></td></tr><tr><td align="left"><strong>缺点</strong></td><td align="left">• 距离短，抗噪差<br>• 不适合板外连接</td><td align="left">• 距离短，速度慢<br>• 抗噪能力一般<br>• <strong>不支持多点通信</strong></td><td align="left">• 需要外部收发器芯片<br>• 半双工需要控制收发方向<br>• 布线需要考虑阻抗匹配和终端电阻</td></tr></tbody></table><hr><ul><li><p><strong>当你需要在同一块电路板上的两个芯片之间通信时</strong>：<br>直接使用 <strong>UART</strong> 接口连接它们的 TX 和 RX 引脚。这是最简单、最直接的方式。</p></li><li><p><strong>当你的设备需要连接到一台旧式电脑的 COM 口，或者与一个只支持 RS232 的设备进行短距离（15米内）通信时</strong>：<br>在你的 MCU 的 UART 接口后面增加一个 <strong>RS232 收发器芯片</strong>（如 MAX232），它会将 UART 的 0&#x2F;5V 逻辑电平转换为 RS232 的 +&#x2F;- 12V 电平。</p></li><li><p><strong>当你需要构建一个通信网络，连接多个设备（超过2个），或者通信距离很远（几十到上千米），尤其是在有电磁干扰的工业环境中时</strong>：<br>在你的 MCU 的 UART 接口后面增加一个 <strong>RS485 收发器芯片</strong>（如 MAX485）。所有设备都并联到 A&#x2F;B 两条总线上，构成一个强大的多点通信网络。这是工业领域最常用的串行通信方式。</p></li></ul><h2 id="二、IIC"><a href="#二、IIC" class="headerlink" title="二、IIC"></a>二、IIC</h2><p>IIC（Inter-Integrated Circuit）总线，它也被广泛地称为 I2C。这是一种非常流行、简单而强大的串行通信协议。</p><hr><h3 id="1-IIC-是什么？-核心概念"><a href="#1-IIC-是什么？-核心概念" class="headerlink" title="1. IIC 是什么？- 核心概念"></a><strong>1. IIC 是什么？- 核心概念</strong></h3><p><strong>IIC (Inter-Integrated Circuit)</strong>，通常写作 <strong>I2C</strong>，是由飞利浦公司（现在的恩智浦 NXP）在20世纪80年代初设计的一种<strong>同步、多主控、多从机、半双工</strong>的串行通信总线。</p><ul><li><strong>同步 (Synchronous):</strong> 通信双方（主设备和从设备）共享一根时钟线（SCL）。数据的发送和接收都由这个时钟信号来协调，确保了数据传输的可靠性。</li><li><strong>多主控 (Multi-Master):</strong> 总线上可以有多个设备发起通信（充当主设备）。协议内建了“仲裁”机制，以解决多个主设备同时尝试控制总线的冲突。</li><li><strong>多从机 (Multi-Slave):</strong> 总线上可以挂载多个接收和响应命令的设备（从设备）。每个从设备都有一个唯一的地址，主设备通过这个地址来指定与哪个设备通信。理论上，7位地址模式下可以连接127个设备（地址0000000为广播地址）。</li><li><strong>半双工 (Half-Duplex):</strong> 数据可以在两个方向上传输（主到从，从到主），但不能在同一时刻进行。数据线（SDA）是双向的。</li><li><strong>串行 (Serial):</strong> 数据是一位一位地在单根数据线上进行传输。</li><li><strong>总线 (Bus):</strong> 意味着多个设备可以连接到同一组线上。</li></ul><p>最核心的特点是，它<strong>仅用两根线（SDA 和 SCL）</strong> 就可以实现设备间的复杂通信，极大地简化了电路板的布线和硬件设计。</p><h3 id="2-历史与背景"><a href="#2-历史与背景" class="headerlink" title="2. 历史与背景"></a><strong>2. 历史与背景</strong></h3><p>I2C 最初是为了简化电视机内部各个芯片之间的通信而设计的。在那个时代，芯片间通信通常需要大量的并行数据线，导致布线复杂、成本高昂。I2C 的出现，使得如微控制器（MCU）、EEPROM、实时时钟（RTC）、数模&#x2F;模数转换器（ADC&#x2F;DAC）等芯片可以非常方便地连接在一起，大大降低了系统设计的复杂度。</p><h3 id="3-物理层"><a href="#3-物理层" class="headerlink" title="3. 物理层"></a><strong>3. 物理层</strong></h3><p>I2C 总线在物理上由两根信号线和地线（GND）组成：</p><p><img src="/img_1/10.png" alt="IIC接线"></p><ul><li><p><strong>SCL (Serial Clock) - 串行时钟线:</strong></p><ul><li>由<strong>主设备</strong>产生和控制。</li><li>为数据传输提供同步时钟信号。SDA线上的数据在SCL为高电平时必须保持稳定，在SCL为低电平时才允许改变。</li></ul></li><li><p><strong>SDA (Serial Data) - 串行数据线:</strong></p><ul><li>双向数据线，用于传输数据。</li><li>无论是主设备还是从设备，都可以通过这条线发送或接收数据。</li></ul></li></ul><h4 id="开漏（Open-Drain）输出与上拉电阻"><a href="#开漏（Open-Drain）输出与上拉电阻" class="headerlink" title="开漏（Open-Drain）输出与上拉电阻"></a><strong>开漏（Open-Drain）输出与上拉电阻</strong></h4><p>这是 I2C 能够实现多设备共享总线的关键技术。</p><ul><li><strong>开漏输出:</strong> I2C 设备连接到 SCL 和 SDA 线的引脚都是开漏（或开集电极）结构。这意味着设备只能将总线<strong>拉低至低电平（GND）</strong>，但不能主动输出高电平。当设备想发送高电平时，它会“释放”总线，使其处于高阻态。</li><li><strong>上拉电阻 (Pull-up Resistors):</strong> 为了在总线被释放时能够恢复到高电平状态，SCL 和 SDA 线上必须各连接一个上拉电阻到电源（VCC）。当总线上所有设备都释放总线时，这两个电阻会将线路电压拉到高电平。</li></ul><p><strong>这个设计带来了两个巨大的好处：</strong></p><ol><li><strong>避免冲突：</strong> 如果两个设备同时尝试控制总线，一个拉低，一个释放（想输出高电平），总线最终表现为低电平，不会因为高低电平直接短路而损坏设备。</li><li><strong>实现“线与”逻辑 (Wired-AND):</strong> 只有当所有设备都释放总线时，总线才为高电平。只要有任何一个设备将总线拉低，总线就为低电平。这个特性是多主控仲裁机制的基础。</li></ol><h3 id="4-IIC-协议详解-通信的规则"><a href="#4-IIC-协议详解-通信的规则" class="headerlink" title="4. IIC 协议详解 - 通信的规则"></a><strong>4. IIC 协议详解 - 通信的规则</strong></h3><p>I2C 通信就像一场有严格规则的对话。</p><h4 id="起始（START）与停止（STOP）条件"><a href="#起始（START）与停止（STOP）条件" class="headerlink" title="起始（START）与停止（STOP）条件"></a><strong>起始（START）与停止（STOP）条件</strong></h4><p>通信的开始和结束由两种特殊信号定义，它们不属于数据传输的一部分。</p><p><img src="/img_1/12.png" alt="起始信号和停止信号"></p><ul><li><strong>起始条件 (START):</strong> 在 <strong>SCL 保持高电平</strong>期间，<strong>SDA 从高电平跳变为低电平</strong>。这标志着一次通信的开始，所有从设备都开始监听总线，准备接收地址。</li><li><strong>停止条件 (STOP):</strong> 在 <strong>SCL 保持高电平</strong>期间，<strong>SDA 从低电平跳变为高电平</strong>。这标志着一次通信的结束，总线被释放。</li></ul><h4 id="设备寻址（Addressing）"><a href="#设备寻址（Addressing）" class="headerlink" title="设备寻址（Addressing）"></a><strong>设备寻址（Addressing）</strong></h4><ul><li>START 条件之后，主设备发送的第一个字节是<strong>地址帧</strong>。</li><li>它由 <strong>7位从设备地址</strong> 和 <strong>1位读&#x2F;写控制位</strong> 组成。<ul><li><strong>读&#x2F;写位 (R&#x2F;W):</strong><ul><li><code>0</code> 表示<strong>写</strong>操作（主设备要向从设备发送数据）。</li><li><code>1</code> 表示<strong>读</strong>操作（主设备要从从设备请求数据）。</li></ul></li></ul></li><li>总线上所有的从设备都会接收这个地址帧，并与自己的地址进行比较。如果匹配，该从设备就被选中，准备后续的通信。</li></ul><h4 id="数据传输与应答（ACK-NACK）"><a href="#数据传输与应答（ACK-NACK）" class="headerlink" title="数据传输与应答（ACK&#x2F;NACK）"></a><strong>数据传输与应答（ACK&#x2F;NACK）</strong></h4><p><img src="/img_1/11.png" alt="在SCL为高电平期间，SDA上的数据始终为低电平，则表示逻辑0，始终为高电平则表示逻辑1"></p><ul><li><strong>数据有效性:</strong> 在 <strong>SCL 为高电平</strong>期间，SDA 上的数据必须保持稳定。数据的改变只能在 <strong>SCL 为低电平</strong>期间发生。</li><li><strong>数据传输:</strong> 数据以字节（8位）为单位进行传输，高位（MSB）在前。SCL 每产生一个脉冲，SDA 上就传输一位数据。</li><li><strong>应答 (Acknowledge, ACK):</strong> 每当主设备或从设备成功发送完一个字节（8位）的数据后，接收方必须在<strong>第9个时钟脉冲</strong>期间回复一个应答信号。<ul><li><strong>ACK (应答):</strong> 接收方将 <strong>SDA 拉低</strong>，表示“我已成功接收到数据，请继续”。</li><li><strong>NACK (非应答, Not Acknowledge):</strong> 接收方<strong>保持 SDA 为高电平</strong>，表示“我未接收到数据”或“我正忙”或“读操作结束”。<ul><li>在主设备读取数据时，主设备会在读取最后一个字节后发送一个 NACK，以告知从设备数据读取结束。</li></ul></li></ul></li></ul><h4 id="一个完整的通信时序"><a href="#一个完整的通信时序" class="headerlink" title="一个完整的通信时序"></a><strong>一个完整的通信时序</strong></h4><p><strong>A. 主设备向从设备写数据 (Master Write)</strong></p><p><img src="/img_1/13.png" alt="一个标准的写数据帧"></p><ol><li><strong>START:</strong> 主设备发送起始条件。</li><li><strong>Address Frame:</strong> 主设备发送 7位从机地址 + 写位(<code>0</code>)。</li><li><strong>ACK:</strong> 匹配的从设备回复一个 ACK。</li><li><strong>Data Frame 1:</strong> 主设备发送第一个数据字节。</li><li><strong>ACK:</strong> 从设备回复一个 ACK。</li><li><strong>Data Frame 2:</strong> 主设备发送第二个数据字节。</li><li><strong>ACK:</strong> 从设备回复一个 ACK。</li><li>… (可以继续发送更多数据) …</li><li><strong>STOP:</strong> 主设备发送停止条件，结束通信。</li></ol><p><strong>B. 主设备从从设备读数据 (Master Read)</strong></p><p><img src="/img_1/14.png" alt="一个标准的读数据帧"></p><ol><li><strong>START:</strong> 主设备发送起始条件。</li><li><strong>Address Frame:</strong> 主设备发送 7位从机地址 + 读位(<code>1</code>)。</li><li><strong>ACK:</strong> 匹配的从设备回复一个 ACK。</li><li><strong>Data from Slave:</strong> 从设备发送第一个数据字节。</li><li><strong>ACK from Master:</strong> 主设备回复一个 ACK，表示还想继续读。</li><li><strong>Data from Slave:</strong> 从设备发送第二个数据字节。</li><li><strong>ACK from Master:</strong> 主设备回复一个 ACK。</li><li>… (主设备继续接收，每次都回 ACK) …</li><li><strong>Data from Slave:</strong> 从设备发送最后一个数据字节。</li><li><strong>NACK from Master:</strong> 主设备回复一个 NACK，告知从设备“我读完了，不要再发了”。</li><li><strong>STOP:</strong> 主设备发送停止条件，结束通信。</li></ol><h3 id="5-高级特性"><a href="#5-高级特性" class="headerlink" title="5. 高级特性"></a><strong>5. 高级特性</strong></h3><h4 id="时钟拉伸（Clock-Stretching）"><a href="#时钟拉伸（Clock-Stretching）" class="headerlink" title="时钟拉伸（Clock Stretching）"></a><strong>时钟拉伸（Clock Stretching）</strong></h4><p>有时，从设备可能需要一些时间来处理接收到的数据或准备要发送的数据（例如，从EEPROM内部读取数据）。在这种情况下，从设备可以在接收完一个字节后，在回复ACK之前，将 <strong>SCL 线强行拉低</strong>。主设备会检测到 SCL 被拉低，并暂停发送下一个时钟脉冲，进入等待状态，直到从设备释放 SCL 线。这个机制给予了慢速从设备与快速主设备同步的能力。</p><h4 id="多主控（Multi-Master）与仲裁（Arbitration）"><a href="#多主控（Multi-Master）与仲裁（Arbitration）" class="headerlink" title="多主控（Multi-Master）与仲裁（Arbitration）"></a><strong>多主控（Multi-Master）与仲裁（Arbitration）</strong></h4><p>当两个或多个主设备同时尝试在总线上发起通信时，就会发生冲突。I2C 的仲裁机制可以优雅地解决这个问题：</p><ol><li>所有主设备在发送数据时都会同时监测 SDA 线。</li><li>由于“线与”逻辑，如果一个主设备想发送高电平（释放SDA）而另一个主设备发送低电平（拉低SDA），SDA线将最终呈现低电平。</li><li>想发送高电平的主设备会检测到 SDA 的实际电平与自己想发送的电平不符，它就知道自己“输掉”了仲裁，会立刻停止驱动总线，并转为从机模式等待总线空闲。</li><li>而发送低电平的主设备没有检测到冲突，它会继续它的通信。</li></ol><p>这个过程是<strong>非破坏性</strong>的，数据不会丢失，赢得仲裁的主设备可以无缝地完成它的通信。</p><h3 id="6-IIC-的速度模式"><a href="#6-IIC-的速度模式" class="headerlink" title="6. IIC 的速度模式"></a><strong>6. IIC 的速度模式</strong></h3><p>I2C 支持多种速度，以适应不同应用的需求：</p><ul><li><strong>Standard-mode (Sm):</strong> 100 kbit&#x2F;s</li><li><strong>Fast-mode (Fm):</strong> 400 kbit&#x2F;s</li><li><strong>Fast-mode Plus (Fm+):</strong> 1 Mbit&#x2F;s</li><li><strong>High-speed mode (Hs-mode):</strong> 3.4 Mbit&#x2F;s</li><li><strong>Ultra Fast-mode (UFm):</strong> 5 Mbit&#x2F;s (这是单向的，更像是推送协议)</li></ul><p>最常用的是 Standard-mode 和 Fast-mode。</p><h3 id="7-IIC-的优缺点"><a href="#7-IIC-的优缺点" class="headerlink" title="7. IIC 的优缺点"></a><strong>7. IIC 的优缺点</strong></h3><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a><strong>优点</strong></h4><ul><li><strong>接线少：</strong> 只需要两根信号线，大大简化了PCB布局和连接器设计。</li><li><strong>灵活性高：</strong> 很容易在总线上增加或移除设备，扩展性好。</li><li><strong>成本低：</strong> 硬件实现简单，许多MCU都内置了I2C控制器。</li><li><strong>有确认机制：</strong> ACK&#x2F;NACK 机制确保了数据传输的可靠性。</li><li><strong>支持多主控：</strong> 允许多个设备发起通信。</li></ul><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a><strong>缺点</strong></h4><ul><li><strong>速度受限：</strong> 相对于 SPI、USB 等协议，I2C 的速度较慢。</li><li><strong>物理距离短：</strong> 总线电容会随着线缆长度和设备数量的增加而增大，这会限制通信速度和距离，通常只适用于板级或设备内部通信。</li><li><strong>地址空间有限：</strong> 7位地址最多支持127个设备，虽然有10位地址扩展，但不如SPI那样通过片选线可以支持几乎无限的设备。</li><li><strong>协议相对复杂：</strong> 相比 UART，I2C 的协议状态（START&#x2F;STOP&#x2F;ACK&#x2F;NACK&#x2F;Addressing）更多，软件实现更复杂一些。</li></ul><h3 id="8-典型应用场景"><a href="#8-典型应用场景" class="headerlink" title="8. 典型应用场景"></a><strong>8. 典型应用场景</strong></h3><p>I2C 无处不在，特别是在嵌入式系统中：</p><ul><li><strong>传感器：</strong> 读取温度、湿度、压力、加速度、陀螺仪等传感器数据。</li><li><strong>存储器：</strong> 读写 EEPROM、FRAM 等非易失性存储器，用于保存配置信息。</li><li><strong>实时时钟 (RTC)：</strong> 设置和读取时间。</li><li><strong>显示驱动：</strong> 控制OLED或LCD小屏幕。</li><li><strong>I&#x2F;O 扩展器：</strong> 用一个I2C接口扩展出更多的GPIO口。</li><li><strong>电源管理芯片 (PMIC)：</strong> 配置和监控电池充电、电压调节等。</li><li><strong>音频编解码器 (Audio Codecs)：</strong> 设置音量、均衡器等参数。</li></ul><h2 id="三、SPI"><a href="#三、SPI" class="headerlink" title="三、SPI"></a>三、SPI</h2><h3 id="1-核心概念"><a href="#1-核心概念" class="headerlink" title="1. 核心概念"></a><strong>1. 核心概念</strong></h3><p><strong>SPI (Serial Peripheral Interface)</strong>，是由摩托罗拉（Motorola）公司在20世纪80年代中期开发的一种<strong>同步、全双工、主从式</strong>的串行通信总线。</p><ul><li><strong>同步 (Synchronous):</strong> 和 I2C 类似，通信双方共享一根时钟线（SCLK），所有的数据传输都由这个时钟信号进行同步。</li><li><strong>全双工 (Full-Duplex):</strong> 数据可以同时在两个方向上传输。主设备向从设备发送数据的同时，从设备也可以向主设备发送数据。这是通过两根独立的数据线（MOSI 和 MISO）实现的。</li><li><strong>主从式 (Master-Slave):</strong> SPI 网络中有一个<strong>主设备 (Master)</strong> 和一个或多个<strong>从设备 (Slave)</strong>。<ul><li><strong>主设备:</strong> 负责发起通信、生成时钟信号、并通过片选线选择与之通信的从设备。</li><li><strong>从设备:</strong> 只能被动地响应主设备的请求，使用主设备提供的时钟信号进行数据收发。</li></ul></li><li><strong>总线 (Bus):</strong> 多个从设备可以共享 SCLK、MOSI 和 MISO 这三条线，但每个从设备都需要一根独立的片选线。</li></ul><h3 id="2-历史与背景-1"><a href="#2-历史与背景-1" class="headerlink" title="2. 历史与背景"></a><strong>2. 历史与背景</strong></h3><p>SPI 的设计初衷是为了在微控制器和各种外围设备（如闪存、传感器、ADC等）之间提供一种简单、高速的点对点通信方式。与 I2C 的多主控复杂性不同，SPI 的协议非常简单，几乎没有协议开销（如地址、ACK&#x2F;NACK位），这使得它能够以非常高的速度传输数据。</p><h3 id="3-物理层-四线制的标准"><a href="#3-物理层-四线制的标准" class="headerlink" title="3. 物理层 - 四线制的标准"></a><strong>3. 物理层 - 四线制的标准</strong></h3><p>标准的 SPI 通信需要四根信号线：</p><p><img src="/img_1/15.png" alt="SPI接线"></p><ul><li><p><strong>SCLK (Serial Clock) - 串行时钟:</strong></p><ul><li>由<strong>主设备</strong>产生和控制。</li><li>为数据传输提供同步脉冲。数据的每一位都在时钟的一个特定边沿被发送和采样。</li></ul></li><li><p><strong>MOSI (Master Out, Slave In) - 主出从入:</strong></p><ul><li>数据从<strong>主设备</strong>流向<strong>从设备</strong>的通道。</li><li>也常被称为 <code>SDO</code> (Serial Data Out)、<code>DO</code> (Data Out) 在主设备端，或 <code>SDI</code> (Serial Data In)、<code>DI</code> (Data In) 在从设备端。</li></ul></li><li><p><strong>MISO (Master In, Slave Out) - 主入从出:</strong></p><ul><li>数据从<strong>从设备</strong>流向<strong>主设备</strong>的通道。</li><li>也常被称为 <code>SDI</code> (Serial Data In)、<code>DI</code> (Data In) 在主设备端，或 <code>SDO</code> (Serial Data Out)、<code>DO</code> (Data Out) 在从设备端。</li></ul></li><li><p><strong>CS &#x2F; SS (Chip Select &#x2F; Slave Select) - 片选:</strong></p><ul><li>由<strong>主设备</strong>控制，用于选择要通信的从设备。</li><li>通常是<strong>低电平有效</strong>。当主设备想与某个从设备通信时，会将其对应的 CS 线拉低。</li><li>总线上有多少个从设备，主设备就需要提供多少根独立的 CS 线（在标准模式下）。当某个从设备的 CS 线为高电平时，它会忽略 SCLK 信号并保持 MISO 线为高阻态，以免干扰总线。</li></ul></li></ul><h3 id="4-SPI-协议详解-通信的规则"><a href="#4-SPI-协议详解-通信的规则" class="headerlink" title="4. SPI 协议详解 - 通信的规则"></a><strong>4. SPI 协议详解 - 通信的规则</strong></h3><h4 id="主从架构-Master-Slave-Architecture"><a href="#主从架构-Master-Slave-Architecture" class="headerlink" title="主从架构 (Master-Slave Architecture)"></a><strong>主从架构 (Master-Slave Architecture)</strong></h4><p>通信永远由主设备发起。主设备是整个总线的“指挥官”，决定了通信的速率和时序。</p><h4 id="数据传输机制-环形移位寄存器"><a href="#数据传输机制-环形移位寄存器" class="headerlink" title="数据传输机制 - 环形移位寄存器"></a><strong>数据传输机制 - 环形移位寄存器</strong></h4><p>理解 SPI 数据传输最直观的方式是，想象主设备和从设备内部各有一个<strong>移位寄存器 (Shift Register)</strong>。</p><ol><li>当通信开始时（CS被拉低，部分设备也可能是拉高），这两个寄存器可以看作是头尾相连，形成一个环形。</li><li>主设备在 SCLK 的驱动下，将自己寄存器中的数据一位一位地通过 <strong>MOSI</strong> 线“推”入从设备的寄存器。</li><li><strong>同时</strong>，从设备寄存器中的数据也一位一位地通过 <strong>MISO</strong> 线“推”入主设备的寄存器。</li><li>经过8个（或16个，取决于数据长度）时钟周期后，主设备和从设备就完成了数据的<strong>交换</strong>。主设备的原始数据到了从设备，从设备的原始数据到了主设备。</li></ol><p>这个“交换”过程就是 SPI 全双工的本质。即使你只想写数据，你也必须完成整个交换过程，只是你会忽略从 MISO 线上收到的数据。同理，如果你只想读数据，你也必须通过 MOSI 发送一些“虚拟”数据（通常是全0或全1）来产生时钟，以“换回”你想要的数据。</p><h4 id="一个完整的通信时序-1"><a href="#一个完整的通信时序-1" class="headerlink" title="一个完整的通信时序"></a><strong>一个完整的通信时序</strong></h4><ol><li><strong>片选：</strong> 主设备将目标从设备的 CS 线从高电平拉至<strong>低电平</strong>。</li><li><strong>时钟生成：</strong> 主设备开始在 SCLK 线上产生时钟脉冲。</li><li><strong>数据交换：</strong> 在每个时钟周期，主设备在 MOSI 线上发送一位数据，同时在 MISO 线上接收一位数据。数据传输通常是高位（MSB）在前。</li><li><strong>通信结束：</strong> 当预定数量的数据（例如一个或多个字节）交换完毕后，主设备停止 SCLK 时钟。</li><li><strong>释放片选：</strong> 主设备将 CS 线重新拉回<strong>高电平</strong>，结束本次通信。从设备此时不再监听总线。</li></ol><h3 id="5-核心配置：CPOL-与-CPHA-SPI-的四种模式"><a href="#5-核心配置：CPOL-与-CPHA-SPI-的四种模式" class="headerlink" title="5. 核心配置：CPOL 与 CPHA - SPI 的四种模式"></a><strong>5. 核心配置：CPOL 与 CPHA - SPI 的四种模式</strong></h3><p>SPI 的灵活性在于主从设备必须在<strong>时钟极性 (CPOL)</strong> 和<strong>时钟相位 (CPHA)</strong> 上达成一致。</p><ul><li><p><strong>CPOL (Clock Polarity) - 时钟极性:</strong></p><ul><li>定义了 SCLK 在空闲状态（即 CS 为高电平时）的电平。</li><li><strong>CPOL &#x3D; 0:</strong> 空闲时 SCLK 为<strong>低电平</strong>。第一个时钟边沿是上升沿。</li><li><strong>CPOL &#x3D; 1:</strong> 空闲时 SCLK 为<strong>高电平</strong>。第一个时钟边沿是下降沿。</li></ul></li><li><p><strong>CPHA (Clock Phase) - 时钟相位:</strong></p><ul><li>定义了数据是在时钟的哪个边沿被<strong>采样</strong>（读取）。</li><li><strong>CPHA &#x3D; 0:</strong> 数据在时钟周期的<strong>第一个边沿</strong>被采样。</li><li><strong>CPHA &#x3D; 1:</strong> 数据在时钟周期的<strong>第二个边沿</strong>被采样。</li></ul></li></ul><h4 id="四种工作模式总结"><a href="#四种工作模式总结" class="headerlink" title="四种工作模式总结"></a><strong>四种工作模式总结</strong></h4><p>这两种配置组合起来，构成了 SPI 的四种标准工作模式：</p><p><img src="/img_1/16.png" alt="以Mode 0进行时钟采集"></p><table><thead><tr><th align="left">模式</th><th align="left">CPOL</th><th align="left">CPHA</th><th align="left">描述 (数据在哪个边沿被采样)</th></tr></thead><tbody><tr><td align="left"><strong>Mode 0</strong></td><td align="left">0</td><td align="left">0</td><td align="left">空闲时钟为低，在<strong>第一个边沿 (上升沿)</strong> 采样</td></tr><tr><td align="left"><strong>Mode 1</strong></td><td align="left">0</td><td align="left">1</td><td align="left">空闲时钟为低，在<strong>第二个边沿 (下降沿)</strong> 采样</td></tr><tr><td align="left"><strong>Mode 2</strong></td><td align="left">1</td><td align="left">0</td><td align="left">空闲时钟为高，在<strong>第一个边沿 (下降沿)</strong> 采样</td></tr><tr><td align="left"><strong>Mode 3</strong></td><td align="left">1</td><td align="left">1</td><td align="left">空闲时钟为高，在<strong>第二个边沿 (上升沿)</strong> 采样</td></tr></tbody></table><p><strong>Mode 0 是最常用、最普遍的模式。</strong> 在进行通信前，主设备必须配置成与目标从设备所支持的模式相匹配。</p><h3 id="6-多从设备配置-Multi-Slave-Configurations"><a href="#6-多从设备配置-Multi-Slave-Configurations" class="headerlink" title="6. 多从设备配置 (Multi-Slave Configurations)"></a><strong>6. 多从设备配置 (Multi-Slave Configurations)</strong></h3><h4 id="独立片选模式-Independent-Slave-Select"><a href="#独立片选模式-Independent-Slave-Select" class="headerlink" title="独立片选模式 (Independent Slave Select)"></a><strong>独立片选模式 (Independent Slave Select)</strong></h4><p>这是最常见的方式。主设备为每一个从设备都分配一个独立的 CS 引脚。SCLK、MOSI、MISO 线由所有设备共享。</p><ul><li><strong>优点:</strong> 逻辑简单直接，可以与任何一个从设备进行高速通信，互不干扰。</li><li><strong>缺点:</strong> 当从设备数量增多时，会消耗主设备大量的 GPIO 引脚。</li></ul><h4 id="菊花链模式-Daisy-Chain"><a href="#菊花链模式-Daisy-Chain" class="headerlink" title="菊花链模式 (Daisy-Chain)"></a><strong>菊花链模式 (Daisy-Chain)</strong></h4><p>这是一种节省引脚的方式。所有从设备的 CS 线可以并联到一根线上。</p><ul><li><strong>连接方式:</strong> 主设备的 MOSI 连接到第一个从设备的 MOSI，第一个从设备的 MISO 连接到第二个从设备的 MOSI，以此类推。最后一个从设备的 MISO 连接回主设备的 MISO。</li><li><strong>工作方式:</strong> 数据像贪吃蛇一样，从主设备发出，穿过每一个从设备，最后回到主设备。如果每个设备的数据长度是8位，要与3个设备通信，主设备就需要连续发送24个时钟脉冲，将数据“推”遍整个链条。</li><li><strong>优点:</strong> 无论有多少从设备，都只需要一根 CS 线。</li><li><strong>缺点:</strong><ul><li>通信速度受限于链条中最慢的设备。</li><li>如果链条中任何一个设备出现故障，整个链条都会失效。</li><li>软件实现更复杂，更新一个设备的数据需要重写整个链条。</li></ul></li></ul><h3 id="7-SPI-的优缺点"><a href="#7-SPI-的优缺点" class="headerlink" title="7. SPI 的优缺点"></a><strong>7. SPI 的优缺点</strong></h3><h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a><strong>优点</strong></h4><ul><li><strong>速度快:</strong> 协议简单，没有额外开销，时钟频率可以达到几十甚至上百 MHz。</li><li><strong>全双工通信:</strong> 可以同时收发数据，效率高。</li><li><strong>协议简单:</strong> 硬件实现（移位寄存器）和软件控制都非常简单。</li><li><strong>数据长度灵活:</strong> 不像 I2C 强制为8位，SPI 可以传输任意长度的数据帧。</li></ul><h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a><strong>缺点</strong></h4><ul><li><strong>占用引脚多:</strong> 每个从设备都需要一个额外的 CS 引脚。</li><li><strong>没有应答机制:</strong> 主设备无法知道从设备是否成功接收到数据（没有 ACK&#x2F;NACK），通信的可靠性依赖于硬件的稳定性。</li><li><strong>没有流控:</strong> 从设备无法像 I2C 那样通过时钟拉伸来告知主设备“请等一下”。</li><li><strong>只能单主控:</strong> 协议本身不支持多主控，总线上只能有一个主设备。</li><li><strong>通信距离短:</strong> 高速信号容易受干扰，通常只用于板级通信。</li></ul><h3 id="8-典型应用场景-1"><a href="#8-典型应用场景-1" class="headerlink" title="8. 典型应用场景"></a><strong>8. 典型应用场景</strong></h3><p>由于其高速特性，SPI 被广泛用于需要大量数据吞吐的场合：</p><ul><li><strong>存储器:</strong> SD卡、MMC卡、串行Flash（Nor&#x2F;NAND Flash）、FRAM。</li><li><strong>显示设备:</strong> LCD、OLED 显示屏的驱动。</li><li><strong>数据转换器:</strong> 高速 ADC (模数转换器) 和 DAC (数模转换器)。</li><li><strong>传感器:</strong> 特别是需要高采样率的传感器，如陀螺仪、加速度计、图像传感器。</li><li><strong>通信模块:</strong> 以太网控制器 (如 W5500)、无线模块 (如 nRF24L01)。</li></ul><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><h3 id="UART-vs-IIC-I2C-vs-SPI-综合对比表"><a href="#UART-vs-IIC-I2C-vs-SPI-综合对比表" class="headerlink" title="UART vs. IIC (I2C) vs. SPI 综合对比表"></a><strong>UART vs. IIC (I2C) vs. SPI 综合对比表</strong></h3><table><thead><tr><th align="left">特性 &#x2F; 维度</th><th align="left">SPI (Serial Peripheral Interface)</th><th align="left">IIC &#x2F; I2C (Inter-Integrated Circuit)</th><th align="left">UART (Universal Asynchronous Receiver&#x2F;Transmitter)</th></tr></thead><tbody><tr><td align="left"><strong>核心思想</strong></td><td align="left"><strong>高速数据流</strong>，主从同步，全双工数据交换</td><td align="left"><strong>多点总线控制</strong>，主从同步，半双工命令&#x2F;响应</td><td align="left"><strong>点对点异步</strong>，简单可靠的字符流传输</td></tr><tr><td align="left"><strong>通信方式</strong></td><td align="left"><strong>同步 (Synchronous)</strong></td><td align="left"><strong>同步 (Synchronous)</strong></td><td align="left"><strong>异步 (Asynchronous)</strong></td></tr><tr><td align="left"><strong>数据传输</strong></td><td align="left"><strong>全双工 (Full-Duplex)</strong><br>数据可同时收发</td><td align="left"><strong>半双工 (Half-Duplex)</strong><br>数据只能单向传输</td><td align="left"><strong>全双工 (Full-Duplex)</strong><br>独立的收发线</td></tr><tr><td align="left"><strong>时钟信号</strong></td><td align="left"><strong>有 (SCLK)</strong><br>由主设备产生</td><td align="left"><strong>有 (SCL)</strong><br>由主设备产生，从设备可“拉伸”</td><td align="left"><strong>无 (No Clock Line)</strong><br>双方约定波特率，通过起始&#x2F;停止位同步</td></tr><tr><td align="left"><strong>标准线数</strong></td><td align="left"><strong>4根</strong><br>(SCLK, MOSI, MISO, CS)</td><td align="left"><strong>2根</strong><br>(SDA, SCL)</td><td align="left"><strong>2根</strong><br>(TX, RX)</td></tr><tr><td align="left"><strong>连接拓扑</strong></td><td align="left"><strong>单主，多从</strong><br>(标准模式下)</td><td align="left"><strong>多主，多从</strong><br>(协议支持仲裁)</td><td align="left"><strong>点对点 (Point-to-Point)</strong></td></tr><tr><td align="left"><strong>设备选择</strong></td><td align="left"><strong>硬件片选线 (CS&#x2F;SS)</strong><br>每个从设备需要一根独立的CS线</td><td align="left"><strong>软件地址 (7位&#x2F;10位)</strong><br>通过总线发送地址来选择设备</td><td align="left"><strong>物理直连</strong><br>TX连RX，RX连TX，无选择机制</td></tr><tr><td align="left"><strong>总线设备数</strong></td><td align="left"><strong>受限于主设备GPIO数量</strong><br>(每个从设备消耗一个引脚)</td><td align="left"><strong>理论上多达127个</strong> (7位地址)<br>受总线电容限制</td><td align="left"><strong>2个</strong> (1对1)</td></tr><tr><td align="left"><strong>通信速度</strong></td><td align="left"><strong>非常快</strong><br>通常可达几十甚至上百 MHz</td><td align="left"><strong>中低速</strong><br>标准100kHz, 快速400kHz, 高速模式可达几MHz</td><td align="left"><strong>相对较慢</strong><br>常用9600~115200 bps, 最高可达几Mbps</td></tr><tr><td align="left"><strong>数据可靠性</strong></td><td align="left"><strong>较低</strong><br>无内置的应答(ACK)或流控机制</td><td align="left"><strong>较高</strong><br>有应答机制 (ACK&#x2F;NACK)，从机可时钟拉伸(流控)</td><td align="left"><strong>一般</strong><br>有奇偶校验位(Parity)可选，但无应答机制</td></tr><tr><td align="left"><strong>协议复杂度</strong></td><td align="left"><strong>硬件简单</strong><br>本质是移位寄存器，软件实现简单</td><td align="left"><strong>中等复杂</strong><br>需处理START&#x2F;STOP, 地址, ACK&#x2F;NACK, 仲裁等</td><td align="left"><strong>非常简单</strong><br>配置好参数(波特率等)后即可收发数据</td></tr><tr><td align="left"><strong>硬件实现</strong></td><td align="left">通常由MCU内置的SPI外设实现</td><td align="left">通常由MCU内置的I2C外设实现</td><td align="left">通常由MCU内置的UART&#x2F;USART外设实现</td></tr><tr><td align="left"><strong>功耗</strong></td><td align="left"><strong>较高</strong><br>通常使用推挽输出(Push-Pull)</td><td align="left"><strong>较低</strong><br>开漏(Open-Drain)结构 + 上拉电阻</td><td align="left"><strong>中等</strong><br>推挽输出(Push-Pull)</td></tr><tr><td align="left"><strong>优点</strong></td><td align="left">• <strong>速度最快</strong><br>• 全双工<br>• 协议简单，硬件开销小</td><td align="left">• <strong>接线最少 (2根)</strong><br>• 支持多主多从<br>• 有确认和流控机制，可靠性好</td><td align="left">• 协议和实现都非常简单<br>• 只需2根线<br>• 广泛应用，支持长距离(配合RS232&#x2F;485)</td></tr><tr><td align="left"><strong>缺点</strong></td><td align="left">• <strong>占用引脚多</strong><br>• 无应答和流控<br>• 只能单主控</td><td align="left">• 速度相对较慢<br>• 总线电容限制距离和设备数<br>• 协议比SPI&#x2F;UART复杂</td><td align="left">• <strong>异步，有同步开销</strong> (起始&#x2F;停止位)<br>• 速度受限<br>• 双方波特率必须精确匹配</td></tr><tr><td align="left"><strong>典型应用</strong></td><td align="left">• <strong>高速数据传输</strong><br>  - SD卡, Flash存储器<br>  - LCD&#x2F;OLED显示屏<br>  - 高速ADC&#x2F;DAC<br>  - 无线模块(nRF24L01)</td><td align="left">• <strong>板级设备管理和控制</strong><br>  - 传感器 (温度, 湿度, 加速度计)<br>  - EEPROM存储器<br>  - 实时时钟(RTC)<br>  - I&#x2F;O扩展器, 电源管理芯片</td><td align="left">• <strong>设备间调试与通信</strong><br>  - PC与MCU的串口调试<br>  - GPS, 蓝牙, GSM&#x2F;GPRS模块<br>  - 配合RS232&#x2F;RS485实现远距离工业控制</td></tr></tbody></table><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://www.bilibili.com/video/BV1y34y147s5/?spm_id_from=333.1365.top_right_bar_window_custom_collection.content.click&vd_source=58f3263b57ef9a6a30806fa51b07a5c1">超简单的一种通信，2分钟搞懂，串口通讯的工作原理！</a><br>[2] <a href="https://www.bilibili.com/video/BV1dg4y1H773/?spm_id_from=333.788.top_right_bar_window_custom_collection.content.click&vd_source=58f3263b57ef9a6a30806fa51b07a5c1">4分钟看懂！I2C通讯协议 最简单的总线通讯！</a><br>[3] <a href="https://www.bilibili.com/video/BV1F54y1M7e7/?spm_id_from=333.1365.top_right_bar_window_custom_collection.content.click&vd_source=58f3263b57ef9a6a30806fa51b07a5c1">深入理解SPI通讯协议，5分钟看懂！</a></p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>时间复杂度与空间复杂度分析</title>
      <link href="/2025/08/16/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/"/>
      <url>/2025/08/16/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>在算法竞赛和面试中，根据题目给出的数据量大小来推断所需算法的时间复杂度和空间复杂度，是一项至关重要的核心技能。它能迅速排除掉不切实际的暴力解法，将思考方向聚焦在可行的算法上。</p><hr><h3 id="一、核心原理：计算机的运算速度"><a href="#一、核心原理：计算机的运算速度" class="headerlink" title="一、核心原理：计算机的运算速度"></a>一、核心原理：计算机的运算速度</h3><p>这个推断方法的基石是对现代计算机运算速度的一个估算。在算法竞赛平台（如 LeetCode、Codeforces、牛客网等）上，评测机通常能在 <strong>1秒内执行大约 10^7 到 10^8 次计算操作</strong>。</p><p>为了保险起见，我们通常以 <strong>10^8</strong> 作为上限参考，但更稳妥的估算是 <strong>10^7</strong>。这意味着，如果你的算法总计算量超过了这个数量级，就很可能会“超时”（Time Limit Exceeded, TLE）。</p><p><strong>基本公式：<code>数据规模 N</code> 带入 <code>时间复杂度表达式</code> ≈ <code>总计算量</code> ≤ <code>10^8</code></strong></p><h3 id="二、时间复杂度-“速查表”-Cheat-Sheet"><a href="#二、时间复杂度-“速查表”-Cheat-Sheet" class="headerlink" title="二、时间复杂度 “速查表” (Cheat Sheet)"></a>二、时间复杂度 “速查表” (Cheat Sheet)</h3><p>这张表是解决算法问题的“第一直觉”，强烈建议记在心里。假设题目给出的主要数据规模是 <code>N</code>。</p><table><thead><tr><th>数据规模 N 的范围</th><th>可接受的时间复杂度</th><th>常见算法示例</th></tr></thead><tbody><tr><td>N ≤ 10~12</td><td>O(N!)、O(N * 2^N)</td><td><strong>阶乘&#x2F;指数级</strong>：全排列（Permutations）、子集生成（Subsets）、状压DP（Bitmask DP）。通常是涉及小规模暴力搜索的题目。</td></tr><tr><td>N ≤ 18~22</td><td>O(2^N)</td><td><strong>指数级</strong>：同上，状压DP、涉及所有子集的暴力搜索、折半搜索（Meet-in-the-middle）。</td></tr><tr><td>N ≤ 50</td><td>O(N^4)</td><td><strong>四次方</strong>：比较少见，可能出现在一些动态规划问题中，或者涉及四重循环的暴力解法。</td></tr><tr><td>N ≤ 100</td><td>O(N^3)</td><td><strong>三次方</strong>：Floyd-Warshall 所有点对最短路算法、三重循环的动态规划、一些涉及三维计算的几何问题。</td></tr><tr><td>N ≤ 2,000 ~ 5,000</td><td>O(N^2)</td><td><strong>二次方</strong>：基础的动态规划（如最长公共子序列）、双重循环的暴力枚举（如 Two Sum 暴力解）、Dijkstra&#x2F;Prim 的朴素版、图的邻接矩阵存储下的遍历。</td></tr><tr><td>N ≤ 10^5 ~ 10^6</td><td>O(N log N)</td><td><strong>线性对数级</strong>：这是最常见的复杂度要求。高效排序算法（快速排序、归并排序）、堆（优先队列）、二分查找（Binary Search）、线段树、树状数组、Dijkstra 的堆优化版。任何需要排序预处理的题目基本都是这个复杂度。</td></tr><tr><td>N ≤ 10^6 ~ 10^7</td><td>O(N)</td><td><strong>线性级</strong>：单次遍历（数组、字符串、链表）、双指针算法（Two Pointers）、哈希表（Hash Table）、广度优先搜索（BFS）、深度优先搜索（DFS）、KMP 算法、动态规划的优化（如单调队列优化）。</td></tr><tr><td>N ≤ 10^9 ~ 10^18 (及以上)</td><td>O(log N)、O(sqrt(N))、O(1)</td><td><strong>对数级&#x2F;根号级&#x2F;常数级</strong>：<br> <strong>O(log N)</strong>: 二分查找、快速幂、求最大公约数（GCD）。通常输入是一个很大的数字，而不是一个包含 N 个元素的数组。<br> <strong>O(sqrt(N))</strong>: 判断一个数是否为质数、分解质因数。<br> <strong>O(1)</strong>: 纯数学公式或位运算。</td></tr></tbody></table><hr><h3 id="三、如何进行分析：一个思考流程"><a href="#三、如何进行分析：一个思考流程" class="headerlink" title="三、如何进行分析：一个思考流程"></a>三、如何进行分析：一个思考流程</h3><p>当你拿到一道题时，遵循以下步骤：</p><ol><li><p><strong>立刻寻找数据范围</strong>：</p><ul><li>找到题目描述最后部分的 “Constraints” 或 “数据范围” 部分。</li><li>关注所有变量的上限，比如数组长度 <code>n</code>、查询次数 <code>q</code>、数值大小 <code>m</code> 等。</li></ul></li><li><p><strong>匹配速查表，确定复杂度上界</strong>：</p><ul><li>将最大的 <code>N</code> 值代入速查表，找到对应的“可接受的时间复杂度”。</li><li><strong>示例</strong>：如果题目说 <code>1 &lt;= n &lt;= 10^5</code>，你的大脑应该立刻响起警报：“<code>O(N^2)</code> 会超时，我必须寻找 <code>O(N log N)</code> 或 <code>O(N)</code> 的解法。”</li></ul></li><li><p><strong>考虑多个变量的情况</strong>：</p><ul><li>有时题目会有多个输入规模，如 <code>N</code> 和 <code>M</code>。</li><li>你需要将它们都考虑进去。例如，一个图论问题有 <code>V</code> 个顶点和 <code>E</code> 条边。<ul><li>如果算法是 <code>O(V * E)</code>，你需要计算 <code>V * E</code> 的最大值是否在 <code>10^8</code> 以内。</li><li>如果算法是 <code>O(V + E)</code>，你就计算 <code>V + E</code> 的最大值。</li></ul></li></ul></li><li><p><strong>从复杂度反推算法类型</strong>：</p><ul><li><strong><code>O(N log N)</code></strong> -&gt; 是不是需要先排序？是不是可以用二分查找？是不是可以用堆？</li><li><strong><code>O(N)</code></strong> -&gt; 是不是可以用哈希表来优化查找？是不是可以用双指针？</li><li><strong><code>O(log N)</code></strong> -&gt; 题目是不是具有单调性，可以用二分查找答案？是不是一个大数问题，需要用快速幂？</li><li><strong><code>O(2^N)</code></strong> -&gt; 是不是要枚举所有状态&#x2F;子集？是不是状压DP？</li><li><strong><code>O(N^2)</code></strong> -&gt; 是不是一个动态规划问题，<code>dp[i][j]</code> 表示某种状态？</li></ul></li></ol><hr><h3 id="四、空间复杂度分析"><a href="#四、空间复杂度分析" class="headerlink" title="四、空间复杂度分析"></a>四、空间复杂度分析</h3><p>空间复杂度的限制通常比时间宽松，但同样重要。</p><ul><li><strong>常见内存限制</strong>：64MB, 128MB, 256MB。</li><li><strong>估算方法</strong>：<ul><li>一个 <code>int</code> (32位) 或 <code>float</code> 占用 4 字节。</li><li>一个 <code>long long</code> (64位) 或 <code>double</code> 占用 8 字节。</li><li>一个 <code>char</code> 占用 1 字节。</li></ul></li><li><strong>快速估算</strong>：<ul><li>开一个 <code>int</code> 数组 <code>a[10^6]</code> 需要 <code>10^6 * 4</code> 字节 ≈ 4MB。</li><li>开一个 <code>int</code> 数组 <code>a[10^7]</code> 需要 <code>10^7 * 4</code> 字节 ≈ 40MB。</li><li>开一个 <code>int</code> 二维数组 <code>dp[5000][5000]</code> 需要 <code>5000 * 5000 * 4</code> 字节 ≈ 100MB。</li></ul></li></ul><p><strong>空间复杂度推断规则</strong>：</p><ul><li>如果 <code>N &lt;= 5000</code>，那么 <code>O(N^2)</code> 的空间（如 <code>dp[N][N]</code>）是可行的。</li><li>如果 <code>N &gt;= 10^5</code>，那么 <code>O(N^2)</code> 的空间<strong>绝对不可行</strong>。你必须寻找 <code>O(N)</code> 或 <code>O(log N)</code> 空间复杂度的算法。</li><li><strong>注意递归深度</strong>：DFS 或递归算法的栈空间也计入空间复杂度。如果递归深度达到 <code>N</code>，空间复杂度就是 <code>O(N)</code>。</li></ul><hr><h3 id="五、例题"><a href="#五、例题" class="headerlink" title="五、例题"></a>五、例题</h3><p><strong>例题 1：Two Sum (两数之和)</strong></p><ul><li><strong>题目</strong>：给定一个整数数组 <code>nums</code> 和一个目标值 <code>target</code>，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。</li><li><strong>数据范围</strong>：<code>2 &lt;= nums.length &lt;= 10^5</code>， <code>-10^9 &lt;= nums[i] &lt;= 10^9</code>。</li></ul><p><strong>分析</strong>：</p><ol><li><strong>数据量</strong>：<code>N</code> 最大为 <code>10^5</code>。</li><li><strong>匹配速查表</strong>：<code>N = 10^5</code> -&gt; 必须是 <code>O(N log N)</code> 或 <code>O(N)</code>。</li><li><strong>排除暴力解</strong>：<code>O(N^2)</code> 的双重循环解法 <code>(10^5)^2 = 10^{10}</code>，远超 <code>10^8</code>，必定超时。</li><li><strong>寻找高效解</strong>：<ul><li><code>O(N log N)</code> 的思路？可以先排序，然后使用双指针。这是一个可行解。</li><li><code>O(N)</code> 的思路？能否一次遍历就解决问题？我们需要快速查找 <code>target - nums[i]</code> 是否存在。什么数据结构查找快？哈希表！</li></ul></li><li><strong>结论</strong>：这道题的正解是使用哈希表，达到 <code>O(N)</code> 时间复杂度和 <code>O(N)</code> 空间复杂度。</li></ol><p><strong>例题 2：最长上升子序列</strong></p><ul><li><strong>题目</strong>：给定一个无序的整数数组，找到其中最长上升子序列的长度。</li><li><strong>数据范围</strong>：<code>1 &lt;= nums.length &lt;= 2500</code>。</li></ul><p><strong>分析</strong>：</p><ol><li><strong>数据量</strong>：<code>N</code> 最大为 <code>2500</code>。</li><li><strong>匹配速查表</strong>：<code>N = 2500</code> -&gt; <code>O(N^2)</code> 是可以接受的！<code>2500^2 = 6,250,000</code>，在 <code>10^7</code> ~ <code>10^8</code> 范围内。</li><li><strong>思考算法</strong>：<code>O(N^2)</code> 让我立刻想到基础的动态规划。<ul><li>定义 <code>dp[i]</code> 为以 <code>nums[i]</code> 结尾的最长上升子序列的长度。</li><li>状态转移方程：<code>dp[i] = max(dp[j]) + 1</code>，其中 <code>0 &lt;= j &lt; i</code> 且 <code>nums[j] &lt; nums[i]</code>。</li><li>这个 DP 解法正好是两重循环，时间复杂度为 <code>O(N^2)</code>。</li></ul></li><li><strong>结论</strong>：<code>O(N^2)</code> 的 DP 算法是这道题的可以通过的解法。</li></ol><ul><li><strong>进阶</strong>：如果这道题的数据范围扩大到 <code>N &lt;= 10^5</code> 呢？<ul><li><code>O(N^2)</code> 就会超时。</li><li>我们需要 <code>O(N log N)</code> 的解法。这就引导我们去思考更优化的方法，比如 “耐心排序法”（patience sorting）配合二分查找。</li></ul></li></ul><h3 id="六、常见算法和数据结构的时间与空间复杂度"><a href="#六、常见算法和数据结构的时间与空间复杂度" class="headerlink" title="六、常见算法和数据结构的时间与空间复杂度"></a>六、常见算法和数据结构的时间与空间复杂度</h3><p>表中使用的符号：</p><ul><li><strong>n</strong>: 输入数据的元素数量（例如数组的长度）</li><li><strong>k</strong>: 数据的范围或桶的数量（例如计数排序中的最大值）</li><li><strong>V</strong>: 图中顶点的数量 (Vertices)</li><li><strong>E</strong>: 图中边的数量 (Edges)</li><li><strong>log n</strong>: 通常指以 2 为底的对数</li></ul><h4 id="1-基础数据结构"><a href="#1-基础数据结构" class="headerlink" title="1. 基础数据结构"></a>1. 基础数据结构</h4><table><thead><tr><th>数据结构</th><th>操作</th><th>平均时间复杂度</th><th>最坏时间复杂度</th><th>空间复杂度</th><th>备注</th></tr></thead><tbody><tr><td><strong>数组 (Array &#x2F; Vector)</strong></td><td>访问 (Access)</td><td><code>O(1)</code></td><td><code>O(1)</code></td><td><code>O(n)</code></td><td>连续内存，通过索引直接访问</td></tr><tr><td></td><td>搜索 (Search)</td><td><code>O(n)</code></td><td><code>O(n)</code></td><td></td><td>需要线性扫描</td></tr><tr><td></td><td>插入&#x2F;删除 (末尾)</td><td><code>O(1)</code> (摊销)</td><td><code>O(n)</code></td><td></td><td>动态数组在扩容时为 <code>O(n)</code>，但摊销后为 <code>O(1)</code></td></tr><tr><td></td><td>插入&#x2F;删除 (中间)</td><td><code>O(n)</code></td><td><code>O(n)</code></td><td></td><td>需要移动后续元素</td></tr><tr><td><strong>链表 (Linked List)</strong></td><td>访问&#x2F;搜索</td><td><code>O(n)</code></td><td><code>O(n)</code></td><td><code>O(n)</code></td><td>需要从头节点开始遍历</td></tr><tr><td></td><td>插入&#x2F;删除 (头部)</td><td><code>O(1)</code></td><td><code>O(1)</code></td><td></td><td>只需修改头指针</td></tr><tr><td></td><td>插入&#x2F;删除 (尾部)</td><td><code>O(n)</code>&#x2F;<code>O(1)</code></td><td><code>O(n)</code>&#x2F;<code>O(1)</code></td><td></td><td>单链表需遍历到尾部(<code>O(n)</code>)，若有尾指针则为 <code>O(1)</code></td></tr><tr><td></td><td>插入&#x2F;删除 (中间)</td><td><code>O(1)</code></td><td><code>O(1)</code></td><td></td><td><strong>前提是已持有该节点的前驱指针</strong>，否则查找需要 <code>O(n)</code></td></tr><tr><td><strong>栈 (Stack)</strong> &#x2F; <strong>队列 (Queue)</strong></td><td>推入&#x2F;弹出 (Push&#x2F;Pop)</td><td><code>O(1)</code></td><td><code>O(1)</code></td><td><code>O(n)</code></td><td>通常基于数组或链表实现</td></tr><tr><td><strong>哈希表 (Hash Table)</strong></td><td>搜索&#x2F;插入&#x2F;删除</td><td><code>O(1)</code></td><td><code>O(n)</code></td><td><code>O(n)</code></td><td><strong>最坏情况</strong>发生在所有元素哈希冲突，退化为链表&#x2F;数组</td></tr><tr><td><strong>二叉搜索树 (BST)</strong></td><td>搜索&#x2F;插入&#x2F;删除</td><td><code>O(log n)</code></td><td><code>O(n)</code></td><td><code>O(n)</code></td><td><strong>平均情况</strong>对应树平衡，<strong>最坏情况</strong>对应树退化为链表</td></tr><tr><td><strong>平衡二叉搜索树 (AVL, Red-Black)</strong></td><td>搜索&#x2F;插入&#x2F;删除</td><td><code>O(log n)</code></td><td><code>O(log n)</code></td><td><code>O(n)</code></td><td>通过自平衡操作保证最坏情况下的对数时间复杂度</td></tr><tr><td><strong>堆 (Heap &#x2F; Priority Queue)</strong></td><td>插入 (Insert)</td><td><code>O(log n)</code></td><td><code>O(log n)</code></td><td><code>O(n)</code></td><td>将元素放入末尾再向上调整</td></tr><tr><td></td><td>查看最大&#x2F;小值 (Peek)</td><td><code>O(1)</code></td><td><code>O(1)</code></td><td></td><td>根节点即为最值</td></tr><tr><td></td><td>提取最大&#x2F;小值 (Pop)</td><td><code>O(log n)</code></td><td><code>O(log n)</code></td><td></td><td>交换头尾元素，再向下调整</td></tr><tr><td></td><td>建堆 (Heapify)</td><td><code>O(n)</code></td><td><code>O(n)</code></td><td></td><td>从非叶子节点开始向下调整，比逐个插入 <code>(O(n log n))</code> 更快</td></tr><tr><td><strong>字典树 (Trie &#x2F; Prefix Tree)</strong></td><td>搜索&#x2F;插入&#x2F;删除</td><td><code>O(L)</code></td><td><code>O(L)</code></td><td><code>O(N*Σ)</code></td><td><code>L</code>为单词长度, <code>N</code>为总词数, <code>Σ</code>为字符集大小。空间开销大</td></tr><tr><td><strong>并查集 (Disjoint Set Union)</strong></td><td>查找 (Find) &#x2F; 合并 (Union)</td><td><code>O(α(n))</code></td><td><code>O(α(n))</code></td><td><code>O(n)</code></td><td>使用路径压缩和按秩&#x2F;大小合并优化后，<code>α(n)</code>为反阿克曼函数，接近常数</td></tr></tbody></table><hr><h4 id="2-排序算法"><a href="#2-排序算法" class="headerlink" title="2. 排序算法"></a>2. 排序算法</h4><table><thead><tr><th>算法 (Algorithm)</th><th>最好时间复杂度</th><th>平均时间复杂度</th><th>最坏时间复杂度</th><th>空间复杂度</th><th>稳定性</th><th>备注</th></tr></thead><tbody><tr><td><strong>冒泡排序 (Bubble Sort)</strong></td><td><code>O(n)</code></td><td><code>O(n²)</code></td><td><code>O(n²)</code></td><td><code>O(1)</code></td><td>稳定</td><td>最好情况是已排序，只需遍历一次</td></tr><tr><td><strong>选择排序 (Selection Sort)</strong></td><td><code>O(n²)</code></td><td><code>O(n²)</code></td><td><code>O(n²)</code></td><td><code>O(1)</code></td><td>不稳定</td><td>交换操作可能打乱相同元素的相对顺序</td></tr><tr><td><strong>插入排序 (Insertion Sort)</strong></td><td><code>O(n)</code></td><td><code>O(n²)</code></td><td><code>O(n²)</code></td><td><code>O(1)</code></td><td>稳定</td><td>数据基本有序时效率很高</td></tr><tr><td><strong>归并排序 (Merge Sort)</strong></td><td><code>O(n log n)</code></td><td><code>O(n log n)</code></td><td><code>O(n log n)</code></td><td><code>O(n)</code></td><td>稳定</td><td>性能稳定，但需要额外空间</td></tr><tr><td><strong>快速排序 (Quick Sort)</strong></td><td><code>O(n log n)</code></td><td><code>O(n log n)</code></td><td><code>O(n²)</code></td><td><code>O(log n)</code></td><td>不稳定</td><td>最坏情况是 pivot 总是选到最大&#x2F;小值</td></tr><tr><td><strong>堆排序 (Heap Sort)</strong></td><td><code>O(n log n)</code></td><td><code>O(n log n)</code></td><td><code>O(n log n)</code></td><td><code>O(1)</code></td><td>不稳定</td><td></td></tr><tr><td><strong>希尔排序 (Shell Sort)</strong></td><td><code>O(n)</code></td><td><code>O(n^1.3)</code>~&#96;O(n²)&#96;</td><td><code>O(n²)</code></td><td><code>O(1)</code></td><td>不稳定</td><td>复杂度与步长序列选择有关</td></tr><tr><td><strong>计数排序 (Counting Sort)</strong></td><td><code>O(n+k)</code></td><td><code>O(n+k)</code></td><td><code>O(n+k)</code></td><td><code>O(n+k)</code></td><td>稳定</td><td><code>k</code>为整数范围，适合范围不大的整数排序</td></tr><tr><td><strong>桶排序 (Bucket Sort)</strong></td><td><code>O(n+k)</code></td><td><code>O(n+k)</code></td><td><code>O(n²)</code></td><td><code>O(n+k)</code></td><td>稳定</td><td>适用于数据均匀分布的情况</td></tr><tr><td><strong>基数排序 (Radix Sort)</strong></td><td><code>O(d*(n+k))</code></td><td><code>O(d*(n+k))</code></td><td><code>O(d*(n+k))</code></td><td><code>O(n+k)</code></td><td>稳定</td><td><code>d</code>为位数，<code>k</code>为基数</td></tr></tbody></table><hr><h4 id="3-搜索算法"><a href="#3-搜索算法" class="headerlink" title="3. 搜索算法"></a>3. 搜索算法</h4><table><thead><tr><th>算法 (Algorithm)</th><th>数据结构要求</th><th>时间复杂度</th><th>空间复杂度</th></tr></thead><tbody><tr><td><strong>线性搜索 (Linear Search)</strong></td><td>无</td><td><code>O(n)</code></td><td><code>O(1)</code></td></tr><tr><td><strong>二分搜索 (Binary Search)</strong></td><td>有序数组</td><td><code>O(log n)</code></td><td><code>O(1)</code></td></tr></tbody></table><hr><h4 id="4-图论算法"><a href="#4-图论算法" class="headerlink" title="4. 图论算法"></a>4. 图论算法</h4><p><strong>前提</strong>：图的表示方式会影响复杂度。以下复杂度主要基于 <strong>邻接表 (Adjacency List)</strong>，这是稀疏图（<code>E</code> 远小于 <code>V²</code>）的标准表示法。若使用邻接矩阵，复杂度中的 <code>E</code> 往往会变成 <code>V²</code>。</p><table><thead><tr><th>算法类别</th><th>算法 (Algorithm)</th><th>时间复杂度</th><th>空间复杂度</th></tr></thead><tbody><tr><td><strong>图遍历</strong></td><td><strong>广度优先搜索 (BFS)</strong></td><td><code>O(V+E)</code></td><td><code>O(V)</code></td></tr><tr><td></td><td><strong>深度优先搜索 (DFS)</strong></td><td><code>O(V+E)</code></td><td><code>O(V)</code></td></tr><tr><td><strong>单源最短路径</strong></td><td><strong>Dijkstra</strong> (堆优化)</td><td><code>O(E log V)</code></td><td><code>O(V)</code></td></tr><tr><td></td><td><strong>Bellman-Ford</strong></td><td><code>O(V*E)</code></td><td><code>O(V)</code></td></tr><tr><td></td><td><strong>SPFA</strong> (队列优化Bellman-Ford)</td><td>平均 <code>O(kE)</code>, 最坏 <code>O(V*E)</code></td><td><code>O(V)</code></td></tr><tr><td><strong>所有顶点对最短路径</strong></td><td><strong>Floyd-Warshall</strong></td><td><code>O(V³)</code></td><td><code>O(V²)</code></td></tr><tr><td><strong>最小生成树</strong></td><td><strong>Prim</strong> (堆优化)</td><td><code>O(E log V)</code></td><td><code>O(V)</code></td></tr><tr><td></td><td><strong>Kruskal</strong> (并查集)</td><td><code>O(E log E)</code> 或 <code>O(E log V)</code></td><td><code>O(V+E)</code></td></tr><tr><td><strong>拓扑排序</strong></td><td><strong>Kahn’s 算法</strong> (BFS)</td><td><code>O(V+E)</code></td><td><code>O(V)</code></td></tr><tr><td></td><td><strong>DFS</strong></td><td><code>O(V+E)</code></td><td><code>O(V)</code></td></tr></tbody></table><hr><h4 id="5-其他重要算法"><a href="#5-其他重要算法" class="headerlink" title="5. 其他重要算法"></a>5. 其他重要算法</h4><table><thead><tr><th>算法类别</th><th>算法 (Algorithm)</th><th>时间复杂度</th><th>空间复杂度</th><th>备注</th></tr></thead><tbody><tr><td><strong>动态规划 (Dynamic Programming)</strong></td><td><strong>斐波那契数列</strong></td><td><code>O(n)</code></td><td><code>O(n)</code>&#x2F;<code>O(1)</code></td><td><code>O(1)</code>空间可通过状态压缩实现</td></tr><tr><td></td><td><strong>0&#x2F;1 背包问题</strong></td><td><code>O(N*W)</code></td><td><code>O(N*W)</code>&#x2F;<code>O(W)</code></td><td><code>N</code>为物品数，<code>W</code>为背包容量。空间可压缩</td></tr><tr><td></td><td><strong>最长公共子序列 (LCS)</strong></td><td><code>O(N*M)</code></td><td><code>O(N*M)</code></td><td><code>N</code>,<code>M</code>为两字符串长度</td></tr><tr><td><strong>字符串匹配</strong></td><td><strong>暴力匹配</strong></td><td><code>O(N*M)</code></td><td><code>O(1)</code></td><td></td></tr><tr><td></td><td><strong>KMP</strong></td><td><code>O(N+M)</code></td><td><code>O(M)</code></td><td></td></tr><tr><td><strong>分治 (Divide and Conquer)</strong></td><td>(作为思想，见归并&#x2F;快排等)</td><td>通常 <code>O(n log n)</code></td><td>通常 <code>O(log n)</code>或<code>O(n)</code></td><td></td></tr><tr><td><strong>数论</strong></td><td><strong>求最大公约数 (GCD)</strong> - 欧几里得</td><td><code>O(log(min(a,b)))</code></td><td><code>O(1)</code></td><td></td></tr><tr><td></td><td><strong>素数筛 (Sieve of Eratosthenes)</strong></td><td><code>O(n log log n)</code></td><td><code>O(n)</code></td><td></td></tr><tr><td></td><td><strong>快速幂 (Exponentiation by Squaring)</strong></td><td><code>O(log n)</code></td><td><code>O(1)</code></td><td>计算 <code>a^n</code></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python中的装饰器</title>
      <link href="/2025/08/16/Python%E4%B8%AD%E7%9A%84%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
      <url>/2025/08/16/Python%E4%B8%AD%E7%9A%84%E8%A3%85%E9%A5%B0%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="1-开篇：为什么需要装饰器？"><a href="#1-开篇：为什么需要装饰器？" class="headerlink" title="1. 开篇：为什么需要装饰器？"></a>1. 开篇：为什么需要装饰器？</h3><p>装饰器的核心思想是<strong>在不修改被装饰对象（通常是函数或方法）的源代码和调用方式的前提下，为其增加额外的功能</strong>。</p><h4 id="一个简单的问题场景"><a href="#一个简单的问题场景" class="headerlink" title="一个简单的问题场景"></a>一个简单的问题场景</h4><p>假设我们有一个核心业务函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">business_logic</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;执行核心业务逻辑...&quot;</span>)</span><br></pre></td></tr></table></figure><p>现在，我们有一个新的需求：在每次执行这个函数前后，打印一条日志，记录函数的开始和结束。</p><h4 id="不使用装饰器的解决方案"><a href="#不使用装饰器的解决方案" class="headerlink" title="不使用装饰器的解决方案"></a>不使用装饰器的解决方案</h4><p><strong>方案一：直接修改函数代码（最差的方式）</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">business_logic</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;开始执行函数...&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;执行核心业务逻辑...&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;函数执行结束。&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li><strong>弊端</strong>：<ul><li><strong>违反了开放&#x2F;封闭原则</strong>：我们修改了函数的内部实现。</li><li><strong>代码冗余</strong>：如果有很多函数都需要这个日志功能，我们就得在每个函数里重复添加这些代码，违反了 DRY (Don’t Repeat Yourself) 原则。</li></ul></li></ul><p><strong>方案二：定义一个新的函数来包装（接近装饰器的思想）</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">logged_business_logic</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;开始执行函数...&quot;</span>)</span><br><span class="line">    business_logic()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;函数执行结束。&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用时需要用新的函数名</span></span><br><span class="line">logged_business_logic()</span><br></pre></td></tr></table></figure><ul><li><strong>弊端</strong>：<ul><li>我们必须使用一个新的函数名 (<code>logged_business_logic</code>)，所有原来调用 <code>business_logic</code> 的地方都需要修改，这在大型项目中是不可接受的。</li></ul></li></ul><p>我们需要一种方法，既能添加功能，又不改变 <code>business_logic</code> 的源码和调用方式。这就引出了装饰器的核心思想。</p><h3 id="2-核心前置知识：Python-函数是一等公民"><a href="#2-核心前置知识：Python-函数是一等公民" class="headerlink" title="2. 核心前置知识：Python 函数是一等公民"></a>2. 核心前置知识：Python 函数是一等公民</h3><p>在 Python 中，函数是“一等公民”（First-Class Citizens），这意味着它们可以像任何其他对象（如整数、字符串、列表）一样被对待。</p><h4 id="a-函数可以被赋值给变量"><a href="#a-函数可以被赋值给变量" class="headerlink" title="a. 函数可以被赋值给变量"></a>a. 函数可以被赋值给变量</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">say_hello</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello!&quot;</span>)</span><br><span class="line"></span><br><span class="line">greet = say_hello  <span class="comment"># 将函数对象赋值给变量 greet</span></span><br><span class="line">greet()            <span class="comment"># 通过 greet 调用函数，输出 &quot;Hello!&quot;</span></span><br></pre></td></tr></table></figure><h4 id="b-函数可以作为参数传递"><a href="#b-函数可以作为参数传递" class="headerlink" title="b. 函数可以作为参数传递"></a>b. 函数可以作为参数传递</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">process_data</span>(<span class="params">data, operation_func</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;开始处理数据...&quot;</span>)</span><br><span class="line">    result = operation_func(data)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;处理结果: <span class="subst">&#123;result&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">square</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">return</span> n * n</span><br><span class="line"></span><br><span class="line">process_data(<span class="number">5</span>, square) <span class="comment"># 将 square 函数作为参数传递</span></span><br><span class="line"><span class="comment"># 输出:</span></span><br><span class="line"><span class="comment"># 开始处理数据...</span></span><br><span class="line"><span class="comment"># 处理结果: 25</span></span><br></pre></td></tr></table></figure><h4 id="c-函数可以作为返回值（闭包）"><a href="#c-函数可以作为返回值（闭包）" class="headerlink" title="c. 函数可以作为返回值（闭包）"></a>c. 函数可以作为返回值（闭包）</h4><p>这是理解装饰器最关键的一点。一个函数可以定义在另一个函数内部，并且内部函数可以引用外部函数的变量。当外部函数返回内部函数时，就形成了一个<strong>闭包（Closure）</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">outer_function</span>(<span class="params">msg</span>):</span><br><span class="line">    message = msg</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner_function</span>():</span><br><span class="line">        <span class="comment"># inner_function 捕获了外部作用域的变量 message</span></span><br><span class="line">        <span class="built_in">print</span>(message)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> inner_function  <span class="comment"># 返回的是内部函数的对象，而不是调用结果</span></span><br><span class="line"></span><br><span class="line">hello_func = outer_function(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">goodbye_func = outer_function(<span class="string">&quot;Goodbye&quot;</span>)</span><br><span class="line"></span><br><span class="line">hello_func()   <span class="comment"># 输出: Hello</span></span><br><span class="line">goodbye_func() <span class="comment"># 输出: Goodbye</span></span><br></pre></td></tr></table></figure><p><code>hello_func</code> 和 <code>goodbye_func</code> 就是闭包，它们“记住”了创建它们时所处的环境（即 <code>message</code> 变量的值）。</p><h3 id="3-装饰器的诞生：从手动装饰到语法糖"><a href="#3-装饰器的诞生：从手动装饰到语法糖" class="headerlink" title="3. 装饰器的诞生：从手动装饰到语法糖"></a>3. 装饰器的诞生：从手动装饰到语法糖</h3><p>有了上面的知识，我们现在可以完美地解决第 1 节中的问题了。</p><h4 id="手动实现装饰器逻辑"><a href="#手动实现装饰器逻辑" class="headerlink" title="手动实现装饰器逻辑"></a>手动实现装饰器逻辑</h4><p>我们可以编写一个函数，它接收一个函数作为参数，并返回一个“增强版”的新函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">logger_decorator</span>(<span class="params">original_function</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;开始执行函数: <span class="subst">&#123;original_function.__name__&#125;</span>&quot;</span>)</span><br><span class="line">        original_function() <span class="comment"># 调用原始函数</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;函数 <span class="subst">&#123;original_function.__name__&#125;</span> 执行结束。&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> wrapper <span class="comment"># 返回包装后的新函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">business_logic</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;执行核心业务逻辑...&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这就是“装饰”的过程</span></span><br><span class="line">decorated_business_logic = logger_decorator(business_logic)</span><br><span class="line">decorated_business_logic()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出:</span></span><br><span class="line"><span class="comment"># 开始执行函数: business_logic</span></span><br><span class="line"><span class="comment"># 执行核心业务逻辑...</span></span><br><span class="line"><span class="comment"># 函数 business_logic 执行结束。</span></span><br></pre></td></tr></table></figure><p>我们成功了！但是，我们还是得调用一个新的函数名 <code>decorated_business_logic</code>。不过，我们可以利用“函数可以被赋值给变量”的特性：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">business_logic = logger_decorator(business_logic)</span><br><span class="line">business_logic() <span class="comment"># 现在可以直接调用原函数名，但它实际上已经是包装后的函数了</span></span><br></pre></td></tr></table></figure><p>这行 <code>business_logic = logger_decorator(business_logic)</code> 就是装饰器工作的<strong>核心原理</strong>。</p><h4 id="语法糖：让代码更优雅"><a href="#语法糖：让代码更优雅" class="headerlink" title="@ 语法糖：让代码更优雅"></a><code>@</code> 语法糖：让代码更优雅</h4><p>Python 提供了一个专门的语法糖 <code>@</code> 来简化这个赋值过程。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@logger_decorator</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">business_logic</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;这是一个处理核心业务的函数。&quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;执行核心业务逻辑...&quot;</span>)</span><br><span class="line"></span><br><span class="line">business_logic()</span><br></pre></td></tr></table></figure><p>上面这段代码和下面这句是<strong>完全等价的</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">business_logic</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;这是一个处理核心业务的函数。&quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;执行核心业务逻辑...&quot;</span>)</span><br><span class="line"></span><br><span class="line">business_logic = logger_decorator(business_logic)</span><br></pre></td></tr></table></figure><p><code>@decorator</code> 放在函数定义前，就表示在函数定义之后，立即将这个函数作为参数传递给 <code>decorator</code>，并将返回值重新赋给原函数名。</p><h3 id="4-构建一个通用的装饰器"><a href="#4-构建一个通用的装饰器" class="headerlink" title="4. 构建一个通用的装饰器"></a>4. 构建一个通用的装饰器</h3><p>我们上面的 <code>logger_decorator</code> 太简单了，它不能处理带参数和返回值的函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@logger_decorator</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">greet</span>(<span class="params">name, message=<span class="string">&quot;Hello&quot;</span></span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;<span class="subst">&#123;message&#125;</span>, <span class="subst">&#123;name&#125;</span>!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># greet(&quot;Alice&quot;) # 这会报错! TypeError: wrapper() takes 0 positional arguments but 1 was given</span></span><br></pre></td></tr></table></figure><h4 id="a-处理被装饰函数的参数-args-kwargs"><a href="#a-处理被装饰函数的参数-args-kwargs" class="headerlink" title="a. 处理被装饰函数的参数 (*args, **kwargs)"></a>a. 处理被装饰函数的参数 (<code>*args</code>, <code>**kwargs</code>)</h4><p>为了让我们的装饰器能够接受任意参数，我们需要在 <code>wrapper</code> 函数中使用 <code>*args</code> 和 <code>**kwargs</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">general_decorator</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;函数 <span class="subst">&#123;func.__name__&#125;</span> 即将执行，参数: args=<span class="subst">&#123;args&#125;</span>, kwargs=<span class="subst">&#123;kwargs&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="comment"># 将捕获的参数原封不动地传递给原始函数</span></span><br><span class="line">        func(*args, **kwargs)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;函数 <span class="subst">&#123;func.__name__&#125;</span> 执行完毕。&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@general_decorator</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">greet</span>(<span class="params">name, message=<span class="string">&quot;Hello&quot;</span></span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;message&#125;</span>, <span class="subst">&#123;name&#125;</span>!&quot;</span>)</span><br><span class="line"></span><br><span class="line">greet(<span class="string">&quot;Alice&quot;</span>)</span><br><span class="line">greet(<span class="string">&quot;Bob&quot;</span>, message=<span class="string">&quot;Hi&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="b-处理被装饰函数的返回值"><a href="#b-处理被装饰函数的返回值" class="headerlink" title="b. 处理被装饰函数的返回值"></a>b. 处理被装饰函数的返回值</h4><p>如果被装饰函数有返回值，我们的 <code>wrapper</code> 也应该将它返回。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">general_decorator_with_return</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;函数 <span class="subst">&#123;func.__name__&#125;</span> 即将执行...&quot;</span>)</span><br><span class="line">        result = func(*args, **kwargs) <span class="comment"># 调用原始函数并保存返回值</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;函数 <span class="subst">&#123;func.__name__&#125;</span> 执行完毕，返回值为: <span class="subst">&#123;result&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> result <span class="comment"># 将返回值传递出去</span></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@general_decorator_with_return</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line">sum_result = add(<span class="number">10</span>, <span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;最终结果: <span class="subst">&#123;sum_result&#125;</span>&quot;</span>)</span><br><span class="line"><span class="comment"># 输出:</span></span><br><span class="line"><span class="comment"># 函数 add 即将执行...</span></span><br><span class="line"><span class="comment"># 函数 add 执行完毕，返回值为: 15</span></span><br><span class="line"><span class="comment"># 最终结果: 15</span></span><br></pre></td></tr></table></figure><h3 id="5-functools-wraps：一个不可或缺的助手"><a href="#5-functools-wraps：一个不可或缺的助手" class="headerlink" title="5. functools.wraps：一个不可或缺的助手"></a>5. <code>functools.wraps</code>：一个不可或缺的助手</h3><p>到目前为止，我们的装饰器看起来很完美，但其实有一个隐藏的问题：它丢失了原函数的元信息（metadata），比如函数名、文档字符串（docstring）等。</p><h4 id="未使用-wraps-的问题"><a href="#未使用-wraps-的问题" class="headerlink" title="未使用 wraps 的问题"></a>未使用 <code>wraps</code> 的问题</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用上面的 general_decorator_with_return</span></span><br><span class="line"><span class="meta">@general_decorator_with_return</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">business_logic</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;这是一个处理核心业务的函数。&quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;执行核心业务逻辑...&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(business_logic.__name__) <span class="comment"># 输出: wrapper  (应该是 business_logic)</span></span><br><span class="line"><span class="built_in">print</span>(business_logic.__doc__)  <span class="comment"># 输出: None     (应该是 &quot;这是一个...&quot;)</span></span><br></pre></td></tr></table></figure><p>这是因为 <code>business_logic</code> 这个名字现在指向的是 <code>wrapper</code> 函数，它的元信息自然是 <code>wrapper</code> 的。这对于调试、文档生成和代码自省非常不利。</p><h4 id="wraps-的作用和用法"><a href="#wraps-的作用和用法" class="headerlink" title="@wraps 的作用和用法"></a><code>@wraps</code> 的作用和用法</h4><p><code>functools</code> 模块中的 <code>wraps</code> 本身也是一个装饰器，专门用来装饰我们的 <code>wrapper</code> 函数，它能将原始函数的元信息复制到 <code>wrapper</code> 函数上。</p><p><strong>最终、最规范的装饰器模板：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">perfect_decorator</span>(<span class="params">func</span>):</span><br><span class="line"><span class="meta">    @wraps(<span class="params">func</span>) </span><span class="comment"># 核心！将 func 的元信息复制到 wrapper</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;这是 wrapper 函数的文档字符串。&quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 前置操作</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;执行函数 &#x27;<span class="subst">&#123;func.__name__&#125;</span>&#x27; 之前...&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 后置操作</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;执行函数 &#x27;<span class="subst">&#123;func.__name__&#125;</span>&#x27; 之后...&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@perfect_decorator</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">business_logic</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;这是一个处理核心业务的函数。&quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;执行核心业务逻辑...&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(business_logic.__name__) <span class="comment"># 输出: business_logic (正确!)</span></span><br><span class="line"><span class="built_in">print</span>(business_logic.__doc__)  <span class="comment"># 输出: 这是一个处理核心业务的函数。 (正确!)</span></span><br><span class="line"><span class="built_in">help</span>(business_logic)           <span class="comment"># 也会显示 business_logic 的帮助信息</span></span><br></pre></td></tr></table></figure><p><strong>记住：编写任何装饰器时，都应该使用 <code>@functools.wraps</code>！</strong></p><h3 id="6-进阶装饰器"><a href="#6-进阶装饰器" class="headerlink" title="6. 进阶装饰器"></a>6. 进阶装饰器</h3><h4 id="a-带参数的装饰器"><a href="#a-带参数的装饰器" class="headerlink" title="a. 带参数的装饰器"></a>a. 带参数的装饰器</h4><p>如果我们想让装饰器本身可以接收参数，比如 <code>@repeat(3)</code>，让函数执行 3 次。</p><p>这就需要一个三层嵌套的结构：一个函数（工厂函数）接收参数，返回一个装饰器，这个装饰器再返回 <code>wrapper</code> 函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">repeat</span>(<span class="params">num_times</span>):</span><br><span class="line">    <span class="comment"># 1. 这是一个装饰器工厂，接收参数，返回一个真正的装饰器</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decorator_repeat</span>(<span class="params">func</span>):</span><br><span class="line">        <span class="comment"># 2. 这是我们熟悉的装饰器</span></span><br><span class="line"><span class="meta">        @wraps(<span class="params">func</span>)</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">            <span class="comment"># 3. 这是包装函数</span></span><br><span class="line">            total_result = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(num_times): <span class="comment"># 使用来自工厂的参数 num_times</span></span><br><span class="line">                total_result = func(*args, **kwargs)</span><br><span class="line">            <span class="keyword">return</span> total_result</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> decorator_repeat</span><br><span class="line"></span><br><span class="line"><span class="meta">@repeat(<span class="params">num_times=<span class="number">3</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">greet</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Hello, <span class="subst">&#123;name&#125;</span>!&quot;</span>)</span><br><span class="line"></span><br><span class="line">greet(<span class="string">&quot;World&quot;</span>)</span><br><span class="line"><span class="comment"># 输出:</span></span><br><span class="line"><span class="comment"># Hello, World!</span></span><br><span class="line"><span class="comment"># Hello, World!</span></span><br><span class="line"><span class="comment"># Hello, World!</span></span><br></pre></td></tr></table></figure><p><strong>执行过程分解</strong>：</p><ol><li><code>repeat(num_times=3)</code> 被首先调用。</li><li>它返回 <code>decorator_repeat</code> 函数。</li><li>Python 接着执行 <code>@decorator_repeat</code>，即 <code>greet = decorator_repeat(greet)</code>。</li><li><code>decorator_repeat</code> 返回 <code>wrapper</code> 函数，并赋值给 <code>greet</code>。</li></ol><p>所以，<code>@repeat(3)</code> 实际上是 <code>@(repeat(3))</code> 的效果。</p><h4 id="b-类装饰器"><a href="#b-类装饰器" class="headerlink" title="b. 类装饰器"></a>b. 类装饰器</h4><p>我们也可以用类来实现装饰器。这在需要维护状态时特别有用。一个类要成为装饰器，需要实现 <code>__init__</code> 和 <code>__call__</code> 方法。</p><ul><li><code>__init__</code>：接收被装饰的函数。</li><li><code>__call__</code>：实现 <code>wrapper</code> 的逻辑。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CallCounter</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, func</span>):</span><br><span class="line">        <span class="variable language_">self</span>.func = func</span><br><span class="line">        <span class="variable language_">self</span>.count = <span class="number">0</span></span><br><span class="line">        wraps(func)(<span class="variable language_">self</span>) <span class="comment"># 更新类的元信息，让其看起来像被包装的函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, *args, **kwargs</span>):</span><br><span class="line">        <span class="variable language_">self</span>.count += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;函数 &#x27;<span class="subst">&#123;self.func.__name__&#125;</span>&#x27; 已被调用 <span class="subst">&#123;self.count&#125;</span> 次。&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.func(*args, **kwargs)</span><br><span class="line"></span><br><span class="line"><span class="meta">@CallCounter</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">say_whee</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Whee!&quot;</span>)</span><br><span class="line"></span><br><span class="line">say_whee() <span class="comment"># 输出: 函数 &#x27;say_whee&#x27; 已被调用 1 次。 Whee!</span></span><br><span class="line">say_whee() <span class="comment"># 输出: 函数 &#x27;say_whee&#x27; 已被调用 2 次。 Whee!</span></span><br><span class="line">say_whee() <span class="comment"># 输出: 函数 &#x27;say_whee&#x27; 已被调用 3 次。 Whee!</span></span><br></pre></td></tr></table></figure><h4 id="c-装饰器栈（多个装饰器）"><a href="#c-装饰器栈（多个装饰器）" class="headerlink" title="c. 装饰器栈（多个装饰器）"></a>c. 装饰器栈（多个装饰器）</h4><p>一个函数可以被多个装饰器同时装饰。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decorator_1</span>(<span class="params">func</span>):</span><br><span class="line"><span class="meta">    @wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;进入 Decorator 1&quot;</span>)</span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;离开 Decorator 1&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decorator_2</span>(<span class="params">func</span>):</span><br><span class="line"><span class="meta">    @wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;进入 Decorator 2&quot;</span>)</span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;离开 Decorator 2&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@decorator_1</span></span><br><span class="line"><span class="meta">@decorator_2</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_function</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;执行 my_function&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>执行顺序</strong>：<br>装饰器的应用顺序是<strong>从下到上</strong>（靠近函数的先应用）。<br>所以 <code>my_function</code> 首先被 <code>decorator_2</code> 包装，然后这个结果再被 <code>decorator_1</code> 包装。<br><code>my_function = decorator_1(decorator_2(my_function))</code></p><p>而代码的<strong>执行顺序</strong>则是像洋葱一样，从外到内，再从内到外。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">my_function()</span><br><span class="line"><span class="comment"># 输出:</span></span><br><span class="line"><span class="comment"># 进入 Decorator 1</span></span><br><span class="line"><span class="comment"># 进入 Decorator 2</span></span><br><span class="line"><span class="comment"># 执行 my_function</span></span><br><span class="line"><span class="comment"># 离开 Decorator 2</span></span><br><span class="line"><span class="comment"># 离开 Decorator 1</span></span><br></pre></td></tr></table></figure><h3 id="7-实际应用场景"><a href="#7-实际应用场景" class="headerlink" title="7. 实际应用场景"></a>7. 实际应用场景</h3><ul><li><strong>日志记录 (Logging)</strong>：在函数执行前后记录日志信息，如我们最初的例子。</li><li><strong>性能计时 (Timing)</strong>：记录函数执行所需的时间。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">timer</span>(<span class="params">func</span>):</span><br><span class="line"><span class="meta">    @wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        start_time = time.perf_counter()</span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        end_time = time.perf_counter()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;&#x27;<span class="subst">&#123;func.__name__&#125;</span>&#x27; took <span class="subst">&#123;end_time - start_time:<span class="number">.4</span>f&#125;</span> seconds.&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure></li><li><strong>权限校验 (Authorization)</strong>：在 Web 框架（如 Flask, Django）中，检查用户是否登录或有特定权限。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Flask 示例</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">login_required</span>(<span class="params">f</span>):</span><br><span class="line"><span class="meta">    @wraps(<span class="params">f</span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decorated_function</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        <span class="keyword">if</span> g.user <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> redirect(url_for(<span class="string">&#x27;login&#x27;</span>, <span class="built_in">next</span>=request.url))</span><br><span class="line">        <span class="keyword">return</span> f(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> decorated_function</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/secret&#x27;</span></span>)</span></span><br><span class="line"><span class="meta">@login_required</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">secret_page</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;这是秘密页面!&quot;</span></span><br></pre></td></tr></table></figure></li><li><strong>缓存 (Caching &#x2F; Memoization)</strong>：对于计算成本高的函数，缓存其结果。Python 3.9+ 提供了 <code>functools.cache</code>。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="meta">@functools.cache</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fibonacci</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    time.sleep(<span class="number">0.1</span>) <span class="comment"># 模拟耗时计算</span></span><br><span class="line">    <span class="keyword">return</span> fibonacci(n-<span class="number">1</span>) + fibonacci(n-<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一次调用会很慢</span></span><br><span class="line"><span class="built_in">print</span>(fibonacci(<span class="number">10</span>))</span><br><span class="line"><span class="comment"># 第二次调用会立刻返回结果，因为结果被缓存了</span></span><br><span class="line"><span class="built_in">print</span>(fibonacci(<span class="number">10</span>))</span><br></pre></td></tr></table></figure></li><li><strong>输入验证 (Input Validation)</strong>：在函数执行前检查输入参数是否合法。</li></ul><h3 id="8-总结"><a href="#8-总结" class="headerlink" title="8. 总结"></a>8. 总结</h3><ul><li><strong>核心思想</strong>：装饰器是一个函数，它接收一个函数作为输入，并返回一个新的函数，旨在不修改原函数代码的情况下为其添加功能。</li><li><strong>语法糖</strong>：<code>@decorator</code> 是 <code>my_func = decorator(my_func)</code> 的简写。</li><li><strong>基础模板</strong>：装饰器内部通常定义一个 <code>wrapper</code> 函数，使用 <code>*args, **kwargs</code> 来处理任意参数，并确保返回原函数的计算结果。</li><li><strong>最佳实践</strong>：<strong>务必</strong>使用 <code>@functools.wraps</code> 来保留原函数的元信息。</li><li><strong>灵活性</strong>：装饰器可以通过带参数、使用类、或层叠使用来满足复杂的需求。</li><li><strong>强大功能</strong>：它们是 Python 中实现横切关注点（如日志、权限、缓存）的强大工具，让业务代码保持纯净和专注。</li></ul>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python中的全局变量与局部变量</title>
      <link href="/2025/08/16/Python%E4%B8%AD%E7%9A%84%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F/"/>
      <url>/2025/08/16/Python%E4%B8%AD%E7%9A%84%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="核心概念：作用域（Scope）"><a href="#核心概念：作用域（Scope）" class="headerlink" title="核心概念：作用域（Scope）"></a>核心概念：作用域（Scope）</h3><p>在理解变量之前，必须先理解<strong>作用域</strong>。作用域就是一个变量能够被访问（可被读取和写入）的区域。把它想象成一个房子的不同房间：</p><ul><li><strong>全局作用域（Global Scope）</strong>：就像房子的<strong>客厅</strong>。所有房间的人都能看到客厅里的东西。在 Python 中，这是在所有函数之外的顶层代码区域。</li><li><strong>局部作用域（Local Scope）</strong>：就像房子的<strong>卧室</strong>。只有在卧室里的人才能看到和使用卧室里的东西。在 Python 中，这通常是指一个函数内部的区域。</li></ul><hr><h3 id="1-局部变量-Local-Variables"><a href="#1-局部变量-Local-Variables" class="headerlink" title="1. 局部变量 (Local Variables)"></a>1. 局部变量 (Local Variables)</h3><p><strong>定义</strong>：<br>在一个函数<strong>内部</strong>创建（首次赋值）的变量，就是局部变量。</p><p><strong>特性</strong>：</p><ul><li><strong>生命周期</strong>：当函数被调用时，局部变量被创建；当函数执行完毕返回时，局部变量就被销毁。</li><li><strong>访问范围</strong>：它只能在其被定义的函数内部被访问。在函数外部尝试访问它会导致 <code>NameError</code>。</li></ul><p><strong>示例：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">my_function</span>():</span><br><span class="line">    <span class="comment"># &#x27;message&#x27; 是一个局部变量，它在 my_function 内部被创建</span></span><br><span class="line">    message = <span class="string">&quot;Hello from inside the function&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(message)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用函数，函数内部可以正常访问 message</span></span><br><span class="line">my_function() </span><br><span class="line"><span class="comment"># 输出: Hello from inside the function</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 尝试在函数外部访问 message</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(message)</span><br><span class="line"><span class="keyword">except</span> NameError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)</span><br><span class="line"><span class="comment"># 输出: name &#x27;message&#x27; is not defined</span></span><br></pre></td></tr></table></figure><p>在这个例子中，<code>message</code> 变量只存在于 <code>my_function</code> 的“卧室”里。一旦函数执行结束，这个“卧室”就消失了，<code>message</code> 也随之消失。</p><hr><h3 id="2-全局变量-Global-Variables"><a href="#2-全局变量-Global-Variables" class="headerlink" title="2. 全局变量 (Global Variables)"></a>2. 全局变量 (Global Variables)</h3><p><strong>定义</strong>：<br>在所有函数<strong>之外</strong>（即在脚本的顶层）定义的变量，就是全局变量。</p><p><strong>特性</strong>：</p><ul><li><strong>生命周期</strong>：从被创建开始，直到整个程序结束，全局变量都存在。</li><li><strong>访问范围</strong>：它可以在程序的任何地方被<strong>读取</strong>，包括任何函数内部。</li></ul><p><strong>示例（读取全局变量）：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># &#x27;app_name&#x27; 是一个全局变量</span></span><br><span class="line">app_name = <span class="string">&quot;My Awesome App&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_app_name</span>():</span><br><span class="line">    <span class="comment"># 在函数内部，我们可以直接读取全局变量</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Welcome to&quot;</span>, app_name)</span><br><span class="line"></span><br><span class="line">print_app_name()</span><br><span class="line"><span class="comment"># 输出: Welcome to My Awesome App</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The application is called:&quot;</span>, app_name)</span><br><span class="line"><span class="comment"># 输出: The application is called: My Awesome App</span></span><br></pre></td></tr></table></figure><p><code>app_name</code> 就像客厅里的电视，<code>print_app_name</code> 这个函数（卧室）里的人可以探出头来看电视。</p><hr><h3 id="3-修改全局变量：global-关键字"><a href="#3-修改全局变量：global-关键字" class="headerlink" title="3. 修改全局变量：global 关键字"></a>3. 修改全局变量：<code>global</code> 关键字</h3><p>这是一个非常关键且容易混淆的点。</p><p><strong>问题</strong>：如果你在函数内部尝试<strong>修改</strong>一个全局变量会发生什么？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">count = <span class="number">0</span>  <span class="comment"># 全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">increment</span>():</span><br><span class="line">    <span class="comment"># 我们想让全局的 count 增加 1</span></span><br><span class="line">    count = count + <span class="number">1</span>  <span class="comment"># 这一行会报错！</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Inside function:&quot;</span>, count)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    increment()</span><br><span class="line"><span class="keyword">except</span> UnboundLocalError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)</span><br><span class="line"><span class="comment"># 输出: local variable &#x27;count&#x27; referenced before assignment</span></span><br></pre></td></tr></table></figure><p><strong>为什么会报错？</strong><br>Python 有一个重要规则：<strong>当你在函数内部对一个变量进行赋值操作时，Python 会默认这个变量是局部变量。</strong></p><p>所以在 <code>increment</code> 函数里，<code>count = ...</code> 这行代码让 Python 认为 <code>count</code> 是一个<strong>新的局部变量</strong>。但是，在赋值号的右边 <code>... = count + 1</code>，它又试图去读取这个（还不存在的）局部变量 <code>count</code> 的值，因此就抛出了 <code>UnboundLocalError</code>。</p><p><strong>解决方案</strong>：使用 <code>global</code> 关键字。<br><code>global</code> 关键字的作用是明确告诉 Python：“我现在要操作的这个变量，不是新的局部变量，而是那个在全局作用域里的变量。”</p><p><strong>正确示例：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">count = <span class="number">0</span>  <span class="comment"># 全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">increment</span>():</span><br><span class="line">    <span class="comment"># 告诉 Python，我们要修改的是全局变量 count</span></span><br><span class="line">    <span class="keyword">global</span> count</span><br><span class="line">    count = count + <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Inside function:&quot;</span>, count)</span><br><span class="line"></span><br><span class="line">increment()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Outside function:&quot;</span>, count)</span><br><span class="line"></span><br><span class="line">increment()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Outside function:&quot;</span>, count)</span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Inside function: 1</span><br><span class="line">Outside function: 1</span><br><span class="line">Inside function: 2</span><br><span class="line">Outside function: 2</span><br></pre></td></tr></table></figure><p>现在，每次调用 <code>increment()</code> 都会正确地修改全局的 <code>count</code> 变量。</p><hr><h3 id="4-LEGB-作用域解析规则"><a href="#4-LEGB-作用域解析规则" class="headerlink" title="4. LEGB 作用域解析规则"></a>4. LEGB 作用域解析规则</h3><p>Python 查找一个变量时，会遵循一个顺序，这个顺序被称为 <strong>LEGB 规则</strong>：</p><ol><li><strong>L (Local)</strong>：局部作用域。首先在函数内部查找。</li><li><strong>E (Enclosing)</strong>：闭包函数外的函数作用域。用于嵌套函数，即一个函数包裹着另一个函数。</li><li><strong>G (Global)</strong>：全局作用域。在模块的顶层查找。</li><li><strong>B (Built-in)</strong>：内建作用域。Python 预先定义的变量，如 <code>len()</code>, <code>print()</code>, <code>str</code> 等。</li></ol><p>Python 解释器会从 L -&gt; E -&gt; G -&gt; B 的顺序依次查找，一旦找到，就停止搜索。</p><hr><h3 id="5-嵌套函数和-nonlocal-关键字"><a href="#5-嵌套函数和-nonlocal-关键字" class="headerlink" title="5. 嵌套函数和 nonlocal 关键字"></a>5. 嵌套函数和 <code>nonlocal</code> 关键字</h3><p>当函数嵌套时，就出现了 “Enclosing” 作用域。</p><p><strong>问题</strong>：如何在内层函数中，修改外层（但非全局）函数的变量？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">outer_function</span>():</span><br><span class="line">    level = <span class="string">&quot;outer&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner_function</span>():</span><br><span class="line">        <span class="comment"># 我们想修改外层函数的 level 变量</span></span><br><span class="line">        level = <span class="string">&quot;inner&quot;</span> <span class="comment"># 这实际上创建了一个新的、属于 inner_function 的局部变量</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Inner level:&quot;</span>, level)</span><br><span class="line">        </span><br><span class="line">    inner_function()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Outer level:&quot;</span>, level)</span><br><span class="line"></span><br><span class="line">outer_function()</span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Inner level: inner</span><br><span class="line">Outer level: outer</span><br></pre></td></tr></table></figure><p>可以看到，<code>inner_function</code> 并没有修改 <code>outer_function</code> 的 <code>level</code> 变量，而是创建了自己的局部变量。</p><p><strong>解决方案</strong>：使用 <code>nonlocal</code> 关键字。<br><code>nonlocal</code> 关键字用于告诉 Python，要操作的变量是**最近的外层（非全局）**作用域中的变量。</p><p><strong>正确示例：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">outer_function</span>():</span><br><span class="line">    level = <span class="string">&quot;outer&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner_function</span>():</span><br><span class="line">        <span class="comment"># 告诉 Python，我们要修改的是外层函数的 level 变量</span></span><br><span class="line">        <span class="keyword">nonlocal</span> level</span><br><span class="line">        level = <span class="string">&quot;inner&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Inner level:&quot;</span>, level)</span><br><span class="line">        </span><br><span class="line">    inner_function()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Outer level:&quot;</span>, level)</span><br><span class="line"></span><br><span class="line">outer_function()</span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Inner level: inner</span><br><span class="line">Outer level: inner</span><br></pre></td></tr></table></figure><p>这次，<code>outer_function</code> 的 <code>level</code> 变量被成功修改了。</p><hr><h3 id="6-最佳实践与注意事项"><a href="#6-最佳实践与注意事项" class="headerlink" title="6. 最佳实践与注意事项"></a>6. 最佳实践与注意事项</h3><ol><li><p><strong>尽量避免使用 <code>global</code></strong>：滥用全局变量会使代码变得难以理解和维护。变量的来源和修改变得不可预测，容易产生“幽灵般的行为”（Spooky Action at a Distance），即一个地方的修改意外地影响了另一个完全不相关的地方。</p></li><li><p><strong>优先使用函数参数和返回值</strong>：传递状态的最好方式是通过函数参数和返回值。这使得函数成为一个独立的、可预测的单元。</p><p><strong>不推荐的写法 (使用 global):</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">value = <span class="number">10</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_five</span>():</span><br><span class="line">    <span class="keyword">global</span> value</span><br><span class="line">    value += <span class="number">5</span></span><br><span class="line">add_five()</span><br><span class="line"><span class="built_in">print</span>(value) <span class="comment"># 15</span></span><br></pre></td></tr></table></figure><p><strong>推荐的写法 (使用参数和返回):</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add_five</span>(<span class="params">num</span>):</span><br><span class="line">    <span class="keyword">return</span> num + <span class="number">5</span></span><br><span class="line"></span><br><span class="line">value = <span class="number">10</span></span><br><span class="line">value = add_five(value)</span><br><span class="line"><span class="built_in">print</span>(value) <span class="comment"># 15</span></span><br></pre></td></tr></table></figure><p>第二种写法更清晰，<code>add_five</code> 函数也更通用、更易于测试。</p></li><li><p><strong>全局变量用于常量</strong>：使用全局变量来定义<strong>常量</strong>（程序运行期间不会改变值的变量）是一个很好的实践。按照惯例，常量名通常用全大写字母表示。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PI = <span class="number">3.14159</span></span><br><span class="line">API_KEY = <span class="string">&quot;YOUR_SECRET_KEY&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calculate_area</span>(<span class="params">radius</span>):</span><br><span class="line">    <span class="keyword">return</span> PI * radius * radius</span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table><thead><tr><th align="left">特性</th><th align="left">局部变量 (Local)</th><th align="left">全局变量 (Global)</th><th align="left">外层变量 (Nonlocal)</th></tr></thead><tbody><tr><td align="left"><strong>定义位置</strong></td><td align="left">函数内部</td><td align="left">所有函数外部</td><td align="left">外层函数内部</td></tr><tr><td align="left"><strong>作用域</strong></td><td align="left">定义它的函数内部</td><td align="left">整个模块&#x2F;脚本</td><td align="left">从定义处到嵌套函数结束</td></tr><tr><td align="left"><strong>生命周期</strong></td><td align="left">函数调用开始到结束</td><td align="left">程序运行开始到结束</td><td align="left">外层函数调用开始到结束</td></tr><tr><td align="left"><strong>修改关键字</strong></td><td align="left">无</td><td align="left"><code>global 变量名</code></td><td align="left"><code>nonlocal 变量名</code></td></tr><tr><td align="left"><strong>最佳实践</strong></td><td align="left">用于函数内部的临时计算和状态</td><td align="left">用于定义常量</td><td align="left">用于编写闭包和装饰器</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CPP学习笔记—lambda表达式</title>
      <link href="/2025/08/16/CPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2025/08/16/CPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>Lambda 表达式是 C++11 引入的一项革命性特性，它极大地改变了 C++ 的编程风格，尤其是在与标准模板库（STL）配合使用时。它允许我们在代码中需要一个函数的地方，直接定义一个匿名的、临时的函数对象。</p><hr><h3 id="1-什么是-Lambda-表达式？"><a href="#1-什么是-Lambda-表达式？" class="headerlink" title="1. 什么是 Lambda 表达式？"></a>1. 什么是 Lambda 表达式？</h3><p>简单来说，Lambda 表达式就是一个<strong>可调用的代码单元</strong>，可以把它理解为一个<strong>匿名的内联函数</strong>。与普通函数不同，它可以在函数内部定义，并且可以“捕获”其所在作用域中的变量。</p><h3 id="2-为什么需要-Lambda-表达式？"><a href="#2-为什么需要-Lambda-表达式？" class="headerlink" title="2. 为什么需要 Lambda 表达式？"></a>2. 为什么需要 Lambda 表达式？</h3><p>在 C++11 之前，如果想向一个算法（如 <code>std::sort</code>）传递一个简单的、一次性的比较逻辑，通常需要：</p><ol><li><strong>定义一个全局函数或静态成员函数</strong>：这会污染命名空间，并且逻辑与使用它的地方相隔甚远。</li><li><strong>定义一个函数对象（Functor）</strong>：需要编写一个完整的类，重载 <code>operator()</code>。这非常繁琐。</li></ol><p><strong>Lambda 的优势：</strong></p><ul><li><strong>代码局部性</strong>：将逻辑直接写在使用它的地方，代码更紧凑，可读性更高。</li><li><strong>简洁性</strong>：避免了编写独立的函数或函数对象类的样板代码。</li><li><strong>状态捕获</strong>：可以方便地访问和使用其定义作用域内的变量，这是普通函数难以做到的。</li></ul><hr><h3 id="3-Lambda-表达式的完整语法"><a href="#3-Lambda-表达式的完整语法" class="headerlink" title="3. Lambda 表达式的完整语法"></a>3. Lambda 表达式的完整语法</h3><p>一个完整的 Lambda 表达式的语法结构如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[capture_list] (parameters) <span class="keyword">mutable</span> <span class="keyword">noexcept</span> -&gt; return_type &#123;</span><br><span class="line">    <span class="comment">// function body</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-1-捕获列表-Capture-Clause"><a href="#3-1-捕获列表-Capture-Clause" class="headerlink" title="3.1. 捕获列表 [] (Capture Clause)"></a>3.1. 捕获列表 <code>[]</code> (Capture Clause)</h4><p>这是 Lambda 最重要和最强大的部分。它决定了 Lambda 函数体内部可以访问哪些外部变量，以及如何访问它们。</p><ul><li><p><code>[]</code>：<strong>不捕获任何外部变量</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[]() &#123; std::cout &lt;&lt; <span class="string">&quot;Hello from Lambda!&quot;</span> &lt;&lt; std::endl; &#125;</span><br></pre></td></tr></table></figure></li><li><p><code>[=]</code>：<strong>按值捕获</strong>所有外部变量。在 Lambda 内部，得到的是外部变量的一份<strong>拷贝</strong>。修改它们不会影响外部的原始变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">auto</span> myLambda = [=]() &#123;</span><br><span class="line">    <span class="comment">// x 在这里是 10 的一份拷贝</span></span><br><span class="line">    std::cout &lt;&lt; x &lt;&lt; std::endl; <span class="comment">// 合法</span></span><br><span class="line">    <span class="comment">// x = 20; // 编译错误！因为拷贝是 const 的</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><code>[&amp;]</code>：<strong>按引用捕获</strong>所有外部变量。在 Lambda 内部，得到的是外部变量的<strong>引用</strong>。修改它们会直接影响外部的原始变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">auto</span> myLambda = [&amp;]() &#123;</span><br><span class="line">    x = <span class="number">20</span>; <span class="comment">// 合法，外部的 x 会被修改为 20</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">myLambda</span>();</span><br><span class="line">std::cout &lt;&lt; x; <span class="comment">// 输出 20</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>警告</strong>：按引用捕获要非常小心<strong>悬挂引用</strong>的问题！如果 Lambda 的生命周期超过了它所引用的局部变量，调用这个 Lambda 将导致未定义行为。</p></blockquote></li><li><p><code>[this]</code>：捕获当前对象的 <code>this</code> 指针。这允许你在 Lambda 内部访问类的成员变量和成员函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> factor = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">auto</span> task = [<span class="keyword">this</span>, factor](<span class="type">int</span> value) &#123;</span><br><span class="line">            <span class="comment">// this-&gt;member_var_ 是通过 this 指针访问的</span></span><br><span class="line">            <span class="keyword">return</span> value * factor * <span class="keyword">this</span>-&gt;member_var_;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">int</span> result = <span class="built_in">task</span>(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> member_var_ = <span class="number">10</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>指定捕获</strong>：可以精确控制捕获哪些变量以及如何捕获。</p><ul><li><code>[x, &amp;y]</code>：变量 <code>x</code> 按值捕获，变量 <code>y</code> 按引用捕获。</li><li><code>[=, &amp;y]</code>：除了 <code>y</code> 按引用捕获，其他所有变量都按值捕获。</li><li><code>[&amp;, x]</code>：除了 <code>x</code> 按值捕获，其他所有变量都按引用捕获。</li></ul></li></ul><h4 id="3-2-参数列表-Parameter-List"><a href="#3-2-参数列表-Parameter-List" class="headerlink" title="3.2. 参数列表 () (Parameter List)"></a>3.2. 参数列表 <code>()</code> (Parameter List)</h4><p>和普通函数的参数列表一样，用于接收传递给 Lambda 的参数。如果不需要参数，<code>()</code> 可以省略。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> add = [](<span class="type">int</span> a, <span class="type">int</span> b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> sum = <span class="built_in">add</span>(<span class="number">3</span>, <span class="number">4</span>); <span class="comment">// sum is 7</span></span><br></pre></td></tr></table></figure><h4 id="3-3-mutable-关键字"><a href="#3-3-mutable-关键字" class="headerlink" title="3.3. mutable 关键字"></a>3.3. <code>mutable</code> 关键字</h4><p>默认情况下，对于按值捕获的变量，Lambda 内部不能修改它们（它们是 <code>const</code> 的）。如果你希望在 Lambda 内部可以修改这些<strong>拷贝</strong>，就需要使用 <code>mutable</code> 关键字。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">auto</span> myLambda = [=]() <span class="keyword">mutable</span> &#123;</span><br><span class="line">    x = <span class="number">20</span>; <span class="comment">// 合法，但修改的是内部的拷贝</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Inside lambda, x = &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">myLambda</span>();</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Outside lambda, x = &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Inside lambda, x = 20</span><br><span class="line">Outside lambda, x = 10</span><br></pre></td></tr></table></figure><h4 id="3-4-异常说明-noexcept"><a href="#3-4-异常说明-noexcept" class="headerlink" title="3.4. 异常说明 noexcept"></a>3.4. 异常说明 <code>noexcept</code></h4><p>和普通函数一样，你可以用 <code>noexcept</code> 来指明该 Lambda 不会抛出异常，这有助于编译器进行优化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = []() <span class="keyword">noexcept</span> &#123; <span class="comment">/* ... */</span> &#125;;</span><br></pre></td></tr></table></figure><h4 id="3-5-返回类型-return-type-Trailing-Return-Type"><a href="#3-5-返回类型-return-type-Trailing-Return-Type" class="headerlink" title="3.5. 返回类型 -&gt; return_type (Trailing Return Type)"></a>3.5. 返回类型 <code>-&gt; return_type</code> (Trailing Return Type)</h4><ul><li><strong>自动推导</strong>：在大多数情况下，编译器可以根据 <code>return</code> 语句自动推导出 Lambda 的返回类型，所以 <code>-&gt; return_type</code> 是<strong>可选的</strong>。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> add = [](<span class="type">int</span> a, <span class="type">int</span> b) &#123; <span class="keyword">return</span> a + b; &#125;; <span class="comment">// 编译器推导出返回类型为 int</span></span><br></pre></td></tr></table></figure></li><li><strong>显式指定</strong>：如果 Lambda 函数体中有多个返回语句，且它们的类型不同，或者你希望强制返回一个特定类型（例如，<code>return 0;</code> 本应推导为 <code>int</code>，但你希望返回 <code>long</code>），则必须显式指定返回类型。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = [](<span class="type">double</span> d) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (d &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(d); <span class="comment">// 返回 int</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 返回 int</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-6-函数体-Function-Body"><a href="#3-6-函数体-Function-Body" class="headerlink" title="3.6. 函数体 {} (Function Body)"></a>3.6. 函数体 <code>{}</code> (Function Body)</h4><p>Lambda 的执行逻辑，和普通函数的函数体一样。</p><hr><h3 id="4-高级用法"><a href="#4-高级用法" class="headerlink" title="4. 高级用法"></a>4. 高级用法</h3><h4 id="4-1-泛型-Lambda-Generic-Lambdas-C-14"><a href="#4-1-泛型-Lambda-Generic-Lambdas-C-14" class="headerlink" title="4.1. 泛型 Lambda (Generic Lambdas, C++14)"></a>4.1. 泛型 Lambda (Generic Lambdas, C++14)</h4><p>通过在参数列表中使用 <code>auto</code> 关键字，可以创建泛型 Lambda。这实际上是创建了一个函数模板。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> add = [](<span class="keyword">auto</span> a, <span class="keyword">auto</span> b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = <span class="built_in">add</span>(<span class="number">3</span>, <span class="number">4</span>);           <span class="comment">// a, b 推导为 int</span></span><br><span class="line"><span class="type">double</span> d = <span class="built_in">add</span>(<span class="number">3.5</span>, <span class="number">4.5</span>);   <span class="comment">// a, b 推导为 double</span></span><br><span class="line">std::string s = <span class="built_in">add</span>(std::<span class="built_in">string</span>(<span class="string">&quot;hello&quot;</span>), std::<span class="built_in">string</span>(<span class="string">&quot; world&quot;</span>)); <span class="comment">// a, b 推导为 std::string</span></span><br></pre></td></tr></table></figure><h4 id="4-2-初始化捕获-广义捕获-Init-Capture-C-14"><a href="#4-2-初始化捕获-广义捕获-Init-Capture-C-14" class="headerlink" title="4.2. 初始化捕获 &#x2F; 广义捕获 (Init Capture, C++14)"></a>4.2. 初始化捕获 &#x2F; 广义捕获 (Init Capture, C++14)</h4><p>这极大地增强了捕获列表的功能，允许你在捕获时进行初始化。语法是 <code>[identifier = expression]</code>。</p><p><strong>用途：</strong></p><ol><li><p><strong>创建仅在 Lambda 内部可见的新变量</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">auto</span> myLambda = [y = x + <span class="number">5</span>]() &#123;</span><br><span class="line">    <span class="comment">// y 是在捕获列表中创建的，值为 15</span></span><br><span class="line">    <span class="comment">// x 在这里是不可见的</span></span><br><span class="line">    std::cout &lt;&lt; y &lt;&lt; std::endl; <span class="comment">// 输出 15</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>移动捕获（Move Capture）</strong>：对于只能移动不能拷贝的类型（如 <code>std::unique_ptr</code>），这是捕获它们的唯一方式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> ptr = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">auto</span> myLambda = [p = std::<span class="built_in">move</span>(ptr)]() &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value from unique_ptr: &quot;</span> &lt;&lt; *p &lt;&lt; std::endl;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">myLambda</span>();</span><br><span class="line"><span class="comment">// 此时 ptr 已经是 nullptr 了</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="4-3-constexpr-Lambda-C-17"><a href="#4-3-constexpr-Lambda-C-17" class="headerlink" title="4.3. constexpr Lambda (C++17)"></a>4.3. <code>constexpr</code> Lambda (C++17)</h4><p>如果一个 Lambda 满足 <code>constexpr</code> 函数的所有要求，你可以在其前面加上 <code>constexpr</code> 关键字，使其可以在编译时求值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> add = [](<span class="type">int</span> a, <span class="type">int</span> b) &#123; <span class="keyword">return</span> a + b; &#125;;</span><br><span class="line"><span class="built_in">static_assert</span>(<span class="built_in">add</span>(<span class="number">2</span>, <span class="number">3</span>) == <span class="number">5</span>, <span class="string">&quot;Compile-time check failed&quot;</span>);</span><br></pre></td></tr></table></figure><hr><h3 id="5-实际应用场景"><a href="#5-实际应用场景" class="headerlink" title="5. 实际应用场景"></a>5. 实际应用场景</h3><h4 id="5-1-与-STL-算法结合"><a href="#5-1-与-STL-算法结合" class="headerlink" title="5.1. 与 STL 算法结合"></a>5.1. 与 STL 算法结合</h4><p>这是 Lambda 最常见的用途。</p><ul><li><p><strong><code>std::sort</code></strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">std::<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), [](<span class="type">int</span> a, <span class="type">int</span> b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b; <span class="comment">// 实现降序排序</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p><strong><code>std::for_each</code></strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">std::for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), [&amp;sum](<span class="type">int</span> n) &#123;</span><br><span class="line">    sum += n;</span><br><span class="line">&#125;); <span class="comment">// sum 最终为 6</span></span><br></pre></td></tr></table></figure></li><li><p><strong><code>std::find_if</code></strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;std::string&gt; names = &#123;<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Charlie&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> it = std::<span class="built_in">find_if</span>(names.<span class="built_in">begin</span>(), names.<span class="built_in">end</span>(), [](<span class="type">const</span> std::string&amp; name) &#123;</span><br><span class="line">    <span class="keyword">return</span> name.<span class="built_in">length</span>() &gt; <span class="number">4</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">if</span> (it != names.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Found: &quot;</span> &lt;&lt; *it &lt;&lt; std::endl; <span class="comment">// 输出 &quot;Found: Alice&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="5-2-作为-std-function-的实现"><a href="#5-2-作为-std-function-的实现" class="headerlink" title="5.2. 作为 std::function 的实现"></a>5.2. 作为 <code>std::function</code> 的实现</h4><p><code>std::function</code> 是一个通用的可调用对象包装器。Lambda 可以被用来初始化 <code>std::function</code> 对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">std::function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; operation;</span><br><span class="line"><span class="type">int</span> choice = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (choice == <span class="number">1</span>) &#123;</span><br><span class="line">    operation = [](<span class="type">int</span> a, <span class="type">int</span> b) &#123; <span class="keyword">return</span> a + b; &#125;;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    operation = [](<span class="type">int</span> a, <span class="type">int</span> b) &#123; <span class="keyword">return</span> a * b; &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> result = <span class="built_in">operation</span>(<span class="number">5</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><h4 id="5-3-多线程编程"><a href="#5-3-多线程编程" class="headerlink" title="5.3. 多线程编程"></a>5.3. 多线程编程</h4><p>在创建线程时，Lambda 提供了一种非常方便的方式来定义线程要执行的任务。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::string message = <span class="string">&quot;Hello from thread&quot;</span>;</span><br><span class="line"><span class="function">std::thread <span class="title">t</span><span class="params">([message]() &#123; <span class="comment">// 按值捕获 message，避免数据竞争</span></span></span></span><br><span class="line"><span class="params"><span class="function">    std::cout &lt;&lt; message &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;)</span></span>;</span><br><span class="line">t.<span class="built_in">join</span>();</span><br></pre></td></tr></table></figure><hr><h3 id="6-底层原理-Lambda-是如何工作的"><a href="#6-底层原理-Lambda-是如何工作的" class="headerlink" title="6. 底层原理 (Lambda 是如何工作的)"></a>6. 底层原理 (Lambda 是如何工作的)</h3><p>在编译时，编译器会将每个 Lambda 表达式转换成一个<strong>唯一的、匿名的类类型</strong>，这个类被称为<strong>闭包类型（Closure Type）</strong>。</p><p>一个 Lambda 表达式 <code>[...] (...) {...}</code> 基本上等同于：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">__UniqueLambdaName</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 1. 捕获的变量成为类的成员变量</span></span><br><span class="line">    <span class="comment">//    按值捕获是普通成员，按引用捕获是引用成员</span></span><br><span class="line">    <span class="comment">//    例如，[x, &amp;y]</span></span><br><span class="line">    <span class="type">int</span> m_x;</span><br><span class="line">    <span class="type">int</span>&amp; m_y;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 构造函数用于初始化捕获的成员</span></span><br><span class="line">    __UniqueLambdaName(<span class="type">int</span> x, <span class="type">int</span>&amp; y) : <span class="built_in">m_x</span>(x), <span class="built_in">m_y</span>(y) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. operator() 被重载，其函数体就是 Lambda 的函数体</span></span><br><span class="line">    <span class="comment">//    默认是 const 方法，除非使用了 mutable</span></span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="comment">/* parameters */</span>)</span> <span class="type">const</span> </span>&#123; <span class="comment">// 或 mutable 时为非 const</span></span><br><span class="line">        <span class="comment">// ... Lambda 的函数体 ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当你定义一个 Lambda 时，编译器会创建这个类的一个实例，这个实例就是<strong>闭包对象（Closure Object）</strong>。这就是为什么 Lambda 可以存储状态（通过捕获的成员变量）并且可以被调用的原因。</p><hr><h3 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h3><table><thead><tr><th align="left">特性</th><th align="left">语法&#x2F;关键字</th><th align="left">描述</th><th align="left">引入版本</th></tr></thead><tbody><tr><td align="left"><strong>基本 Lambda</strong></td><td align="left"><code>[](){}</code></td><td align="left">创建匿名函数对象</td><td align="left">C++11</td></tr><tr><td align="left"><strong>值捕获</strong></td><td align="left"><code>[=]</code>, <code>[x]</code></td><td align="left">拷贝外部变量</td><td align="left">C++11</td></tr><tr><td align="left"><strong>引用捕获</strong></td><td align="left"><code>[&amp;]</code>, <code>[&amp;x]</code></td><td align="left">引用外部变量</td><td align="left">C++11</td></tr><tr><td align="left"><strong>修改值捕获</strong></td><td align="left"><code>mutable</code></td><td align="left">允许修改按值捕获的拷贝</td><td align="left">C++11</td></tr><tr><td align="left"><strong>泛型 Lambda</strong></td><td align="left"><code>[](auto p){}</code></td><td align="left">参数类型自动推导，类似模板</td><td align="left">C++14</td></tr><tr><td align="left"><strong>初始化捕获</strong></td><td align="left"><code>[x=expr]</code></td><td align="left">在捕获时创建并初始化变量</td><td align="left">C++14</td></tr><tr><td align="left"><strong>编译时求值</strong></td><td align="left"><code>constexpr</code></td><td align="left">允许 Lambda 在编译时执行</td><td align="left">C++17</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分查找</title>
      <link href="/2025/07/28/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
      <url>/2025/07/28/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<p>二分法是一种较为简单通用的搜索算法，但是在实际动手写时，却经常因为细节问题导致无法一次性写对，这里整理出了现代二分法的最佳实践写法，即红蓝染色&#x2F;边界搜索算法，理解该方法后对于各种二分变种问题都能一次写对。</p><p><img src="/img_1/20.png" alt="红蓝染色&#x2F;边界搜索算法"></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">题目描述：</span></span><br><span class="line"><span class="string">给定数组nums = [1, 3, 6, 6, 6, 12, 16, 19, 20]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">target = 6</span></span><br><span class="line"><span class="string">若数组中包含target，则返回数组下标，否则返回-1</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 采用红蓝染色/边界查找法，现代二分法的最佳实践</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">binary_search_lower_bound</span>(<span class="params">nums, target</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;lower_bound问题的二分搜索写法&quot;&quot;&quot;</span></span><br><span class="line">    left, right = -<span class="number">1</span>, <span class="built_in">len</span>(nums)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> left + <span class="number">1</span> != right:</span><br><span class="line">        middle = left + (right - left) // <span class="number">2</span></span><br><span class="line">        <span class="comment"># 如果middle指针在蓝色区域</span></span><br><span class="line">        <span class="keyword">if</span> nums[middle] &lt; target:</span><br><span class="line">            left = middle</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            right = middle</span><br><span class="line">    <span class="comment"># 可自己根据实际问题返回左指针或右指针</span></span><br><span class="line">    <span class="keyword">return</span> right</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">binary_search_upper_bound</span>(<span class="params">nums, target</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;upper_bound问题的二分搜索写法&quot;&quot;&quot;</span></span><br><span class="line">    left, right = -<span class="number">1</span>, <span class="built_in">len</span>(nums)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> left + <span class="number">1</span> != right:</span><br><span class="line">        middle = left + (right - left) // <span class="number">2</span></span><br><span class="line">        <span class="comment"># 如果middle指针在蓝色区域</span></span><br><span class="line">        <span class="keyword">if</span> nums[middle] &lt;= target:</span><br><span class="line">            left = middle</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            right = middle</span><br><span class="line">    <span class="comment"># 可自己根据实际问题返回左指针或右指针</span></span><br><span class="line">    <span class="keyword">return</span> right</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    nums = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">12</span>, <span class="number">16</span>, <span class="number">19</span>, <span class="number">20</span>]</span><br><span class="line">    target = <span class="number">6</span></span><br><span class="line">    <span class="comment"># 注意使用二分法的前提是数组必须是有序的</span></span><br><span class="line">    nums.sort()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># # 检查索引是否越界，以及该位置的元素是否等于target</span></span><br><span class="line">    <span class="comment"># if index &lt; len(nums) and nums[index] == target:</span></span><br><span class="line">    <span class="comment">#     return index  # 找到了，返回索引</span></span><br><span class="line">    <span class="comment"># else:</span></span><br><span class="line">    <span class="comment">#     return -1  # 未找到</span></span><br><span class="line">    <span class="built_in">print</span>(binary_search_lower_bound(nums, target))</span><br><span class="line">    <span class="built_in">print</span>(binary_search_upper_bound(nums, target))</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">输出结果为：</span></span><br><span class="line"><span class="string">2</span></span><br><span class="line"><span class="string">5</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><hr><p>C++20 <code>std::ranges</code> 中的 <code>lower_bound</code>、<code>upper_bound</code> 与 Python <code>bisect</code> 模块中的 <code>bisect_left</code>、<code>bisect_right</code>，这四个函数本质上都做同一件事：<strong>在一个已排序的序列中，使用二分查找算法来高效地找到一个合适的位置</strong>。它们的核心目的不是简单地“查找”一个元素是否存在，而是确定一个值应该被<strong>插入</strong>到序列的哪个位置，才能继续保持序列的有序性。</p><hr><h3 id="核心概念理解"><a href="#核心概念理解" class="headerlink" title="核心概念理解"></a><strong>核心概念理解</strong></h3><p>在深入细节之前，我们先统一理解两个核心概念：<code>lower_bound</code>（或 <code>left</code>）和 <code>upper_bound</code>（或 <code>right</code>）。</p><p>假设你有一个已排序的序列，比如 <code>[10, 20, 30, 30, 30, 40, 50]</code>，现在你想查找值 <code>30</code>。</p><ol><li><p><strong><code>lower_bound</code> &#x2F; <code>bisect_left</code> (寻找下界&#x2F;左边界)</strong></p><ul><li>它会找到序列中<strong>第一个可以插入 <code>30</code> 而不破坏排序</strong>的位置。</li><li>换句话说，它返回的是第一个<strong>不小于（大于或等于）</strong><code>30</code> 的元素的位置。</li><li>在 <code>[10, 20, **30**, 30, 30, 40, 50]</code> 中，这个位置是第一个 <code>30</code> 所在的位置（索引 2）。</li></ul></li><li><p><strong><code>upper_bound</code> &#x2F; <code>bisect_right</code> (寻找上界&#x2F;右边界)</strong></p><ul><li>它会找到序列中<strong>最后一个可以插入 <code>30</code> 而不破坏排序</strong>的位置。</li><li>换句话说，它返回的是第一个<strong>严格大于</strong><code>30</code> 的元素的位置。</li><li>在 <code>[10, 20, 30, 30, 30, **40**, 50]</code> 中，这个位置是 <code>40</code> 所在的位置（索引 5）。</li></ul></li></ol><p><strong>一个关键的记忆技巧：</strong></p><ul><li><code>_left</code> &#x2F; <code>lower_</code> 会把新元素插入到现有相同元素的<strong>左边</strong>。</li><li><code>_right</code> &#x2F; <code>upper_</code> 会把新元素插入到现有相同元素的<strong>右边</strong>。</li></ul><hr><h3 id="第一部分：C-std-ranges-lower-bound-和-std-ranges-upper-bound"><a href="#第一部分：C-std-ranges-lower-bound-和-std-ranges-upper-bound" class="headerlink" title="第一部分：C++ std::ranges::lower_bound 和 std::ranges::upper_bound"></a><strong>第一部分：C++ <code>std::ranges::lower_bound</code> 和 <code>std::ranges::upper_bound</code></strong></h3><p>这些是 C++20 <code>ranges</code> 库的一部分，相比于 C++17 及之前的 <code>std::lower_bound</code>，它们提供了更现代化、更简洁的接口。</p><p><strong>前提条件</strong>：操作的范围（range）必须已经根据所用的比较操作排好序。</p><p><strong>返回值</strong>：返回一个<strong>迭代器（iterator）</strong>，指向找到的位置。如果找不到符合条件的位置（例如，查找的值比所有元素都大），则返回范围的 <code>end()</code> 迭代器。</p><h4 id="1-std-ranges-lower-bound"><a href="#1-std-ranges-lower-bound" class="headerlink" title="1. std::ranges::lower_bound"></a><strong>1. <code>std::ranges::lower_bound</code></strong></h4><p><strong>签名 (简化版):</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;forward_range R, <span class="keyword">class</span> T, <span class="keyword">class</span> Proj </span>= identity, <span class="keyword">class</span> <span class="title class_">Comp</span> = ranges::less&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">borrowed_iterator_t</span>&lt;R&gt;</span><br><span class="line">    <span class="built_in">lower_bound</span>(R&amp;&amp; r, <span class="type">const</span> T&amp; value, Comp comp = &#123;&#125;, Proj proj = &#123;&#125;);</span><br></pre></td></tr></table></figure><ul><li><code>R&amp;&amp; r</code>: 一个范围，例如 <code>std::vector</code>、<code>std::array</code> 或 <code>std::string_view</code>。</li><li><code>const T&amp; value</code>: 要查找的值。</li><li><code>Comp comp</code> (可选): 自定义比较函数对象。默认是 <code>std::ranges::less</code>，即 <code>&lt;</code> 运算符。</li><li><code>Proj proj</code> (可选): 投影函数。在比较之前，会对范围中的每个元素应用这个函数。这是一个非常强大的功能。</li></ul><p><strong>详细解释：</strong><br>它返回一个迭代器 <code>it</code>，指向范围 <code>r</code> 中第一个满足 <code>!comp(proj(*it), value)</code> 的元素。<br>如果使用默认的 <code>comp</code> (<code>&lt;</code>) 和 <code>proj</code> (无操作)，这个条件就等价于 <code>!(*it &lt; value)</code>，也就是 <code>*it &gt;= value</code>。</p><p><strong>代码示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ranges&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_pos</span><span class="params">(<span class="type">const</span> std::string&amp; func_name, <span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; vec, std::vector&lt;<span class="type">int</span>&gt;::iterator it)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; func_name &lt;&lt; <span class="string">&quot;: &quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (it == vec.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Element should be inserted at the end (index &quot;</span> &lt;&lt; vec.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot;)\n&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">auto</span> index = std::<span class="built_in">distance</span>(vec.<span class="built_in">begin</span>(), it);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Found at index &quot;</span> &lt;&lt; index &lt;&lt; <span class="string">&quot;, value is &quot;</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">30</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 查找一个存在且重复的元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Searching for 30:\n&quot;</span>;</span><br><span class="line">    <span class="keyword">auto</span> it_lower = std::ranges::<span class="built_in">lower_bound</span>(v, <span class="number">30</span>);</span><br><span class="line">    <span class="built_in">print_pos</span>(<span class="string">&quot;lower_bound&quot;</span>, v, it_lower); <span class="comment">// 指向第一个 30 (索引 2)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 查找一个不存在的元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nSearching for 25:\n&quot;</span>;</span><br><span class="line">    it_lower = std::ranges::<span class="built_in">lower_bound</span>(v, <span class="number">25</span>);</span><br><span class="line">    <span class="built_in">print_pos</span>(<span class="string">&quot;lower_bound&quot;</span>, v, it_lower); <span class="comment">// 指向第一个 30 (索引 2)，因为 30 是第一个 &gt;= 25 的元素</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 查找一个比所有元素都大的元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nSearching for 60:\n&quot;</span>;</span><br><span class="line">    it_lower = std::ranges::<span class="built_in">lower_bound</span>(v, <span class="number">60</span>);</span><br><span class="line">    <span class="built_in">print_pos</span>(<span class="string">&quot;lower_bound&quot;</span>, v, it_lower); <span class="comment">// 指向 end()</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 查找一个比所有元素都小的元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nSearching for 5:\n&quot;</span>;</span><br><span class="line">    it_lower = std::ranges::<span class="built_in">lower_bound</span>(v, <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">print_pos</span>(<span class="string">&quot;lower_bound&quot;</span>, v, it_lower); <span class="comment">// 指向第一个元素 10 (索引 0)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-std-ranges-upper-bound"><a href="#2-std-ranges-upper-bound" class="headerlink" title="2. std::ranges::upper_bound"></a><strong>2. <code>std::ranges::upper_bound</code></strong></h4><p><strong>签名 (与 <code>lower_bound</code> 类似):</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;forward_range R, <span class="keyword">class</span> T, <span class="keyword">class</span> Proj </span>= identity, <span class="keyword">class</span> <span class="title class_">Comp</span> = ranges::less&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">borrowed_iterator_t</span>&lt;R&gt;</span><br><span class="line">    <span class="built_in">upper_bound</span>(R&amp;&amp; r, <span class="type">const</span> T&amp; value, Comp comp = &#123;&#125;, Proj proj = &#123;&#125;);</span><br></pre></td></tr></table></figure><p><strong>详细解释：</strong><br>它返回一个迭代器 <code>it</code>，指向范围 <code>r</code> 中第一个满足 <code>comp(value, proj(*it))</code> 的元素。<br>如果使用默认的 <code>comp</code> 和 <code>proj</code>，这个条件就等价于 <code>value &lt; *it</code>，也就是 <code>*it &gt; value</code>。</p><p><strong>代码示例 (续上):</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ranges&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ... print_pos function from above ...</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">30</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 查找一个存在且重复的元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Searching for 30:\n&quot;</span>;</span><br><span class="line">    <span class="keyword">auto</span> it_upper = std::ranges::<span class="built_in">upper_bound</span>(v, <span class="number">30</span>);</span><br><span class="line">    <span class="built_in">print_pos</span>(<span class="string">&quot;upper_bound&quot;</span>, v, it_upper); <span class="comment">// 指向 40 (索引 5)，因为 40 是第一个 &gt; 30 的元素</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 查找一个不存在的元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nSearching for 25:\n&quot;</span>;</span><br><span class="line">    it_upper = std::ranges::<span class="built_in">upper_bound</span>(v, <span class="number">25</span>);</span><br><span class="line">    <span class="built_in">print_pos</span>(<span class="string">&quot;upper_bound&quot;</span>, v, it_upper); <span class="comment">// 指向第一个 30 (索引 2)，因为 30 是第一个 &gt; 25 的元素</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 查找一个比所有元素都大的元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nSearching for 60:\n&quot;</span>;</span><br><span class="line">    it_upper = std::ranges::<span class="built_in">upper_bound</span>(v, <span class="number">60</span>);</span><br><span class="line">    <span class="built_in">print_pos</span>(<span class="string">&quot;upper_bound&quot;</span>, v, it_upper); <span class="comment">// 指向 end()</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 查找一个比所有元素都小的元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nSearching for 5:\n&quot;</span>;</span><br><span class="line">    it_upper = std::ranges::<span class="built_in">upper_bound</span>(v, <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">print_pos</span>(<span class="string">&quot;upper_bound&quot;</span>, v, it_upper); <span class="comment">// 指向第一个元素 10 (索引 0)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="C-投影-Projection-的强大之处"><a href="#C-投影-Projection-的强大之处" class="headerlink" title="C++ 投影 (Projection) 的强大之处"></a><strong>C++ 投影 (Projection) 的强大之处</strong></h4><p>假设你有一个结构体 <code>Person</code> 的 <code>vector</code>，并按年龄排序，你想查找特定年龄的人。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;Person&gt; people = &#123;&#123;<span class="string">&quot;Alice&quot;</span>, <span class="number">20</span>&#125;, &#123;<span class="string">&quot;Bob&quot;</span>, <span class="number">25</span>&#125;, &#123;<span class="string">&quot;Charlie&quot;</span>, <span class="number">25</span>&#125;, &#123;<span class="string">&quot;David&quot;</span>, <span class="number">30</span>&#125;&#125;;</span><br><span class="line">    <span class="comment">// 按年龄排序</span></span><br><span class="line">    <span class="comment">// std::ranges::sort(people, &#123;&#125;, &amp;Person::age); // 假设已经排序</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> age_to_find = <span class="number">25</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用投影来直接在 Person vector 中查找年龄</span></span><br><span class="line">    <span class="keyword">auto</span> it = std::ranges::<span class="built_in">lower_bound</span>(people, age_to_find, &#123;&#125;, &amp;Person::age);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (it != people.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;First person with age &gt;= 25 is &quot;</span> &lt;&lt; it-&gt;name &lt;&lt; <span class="string">&quot; at age &quot;</span> &lt;&lt; it-&gt;age &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，<code>&amp;Person::age</code> 是一个投影，它告诉 <code>lower_bound</code>：“在比较时，不要看整个 <code>Person</code> 对象，只看它的 <code>age</code> 成员。” 这使得代码非常干净和直观。</p><hr><h3 id="第二部分：Python-bisect-bisect-left-和-bisect-bisect-right"><a href="#第二部分：Python-bisect-bisect-left-和-bisect-bisect-right" class="headerlink" title="第二部分：Python bisect.bisect_left 和 bisect.bisect_right"></a><strong>第二部分：Python <code>bisect.bisect_left</code> 和 <code>bisect.bisect_right</code></strong></h3><p>这些函数位于 Python 标准库的 <code>bisect</code> 模块中。</p><p><strong>前提条件</strong>：操作的列表（list）必须已经排好序。</p><p><strong>返回值</strong>：返回一个<strong>整数索引（index）</strong>，表示合适的插入点。这与 C++ 返回迭代器是主要区别之一。</p><h4 id="1-bisect-bisect-left"><a href="#1-bisect-bisect-left" class="headerlink" title="1. bisect.bisect_left"></a><strong>1. <code>bisect.bisect_left</code></strong></h4><p><strong>签名:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bisect.bisect_left(a, x, lo=<span class="number">0</span>, hi=<span class="built_in">len</span>(a))</span><br></pre></td></tr></table></figure><ul><li><code>a</code>: 已排序的序列（通常是列表）。</li><li><code>x</code>: 要查找的值。</li><li><code>lo</code>, <code>hi</code> (可选): 指定在序列的哪个子切片中进行搜索。</li></ul><p><strong>详细解释：</strong><br>功能上完全等同于 C++ 的 <code>lower_bound</code>。它返回一个插入点 <code>i</code>，这个插入点会将 <code>x</code> 插入到 <code>a</code> 中所有等于 <code>x</code> 的元素<strong>之前</strong>。</p><p><strong>代码示例：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> bisect</span><br><span class="line"></span><br><span class="line">a = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">30</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 查找一个存在且重复的元素</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Searching for 30:&quot;</span>)</span><br><span class="line">idx_left = bisect.bisect_left(a, <span class="number">30</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;bisect_left: index is <span class="subst">&#123;idx_left&#125;</span>&quot;</span>) <span class="comment"># 输出 index is 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 查找一个不存在的元素</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nSearching for 25:&quot;</span>)</span><br><span class="line">idx_left = bisect.bisect_left(a, <span class="number">25</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;bisect_left: index is <span class="subst">&#123;idx_left&#125;</span>&quot;</span>) <span class="comment"># 输出 index is 2 (25应该插入到30之前)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 查找一个比所有元素都大的元素</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nSearching for 60:&quot;</span>)</span><br><span class="line">idx_left = bisect.bisect_left(a, <span class="number">60</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;bisect_left: index is <span class="subst">&#123;idx_left&#125;</span>&quot;</span>) <span class="comment"># 输出 index is 7 (列表长度)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 查找一个比所有元素都小的元素</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nSearching for 5:&quot;</span>)</span><br><span class="line">idx_left = bisect.bisect_left(a, <span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;bisect_left: index is <span class="subst">&#123;idx_left&#125;</span>&quot;</span>) <span class="comment"># 输出 index is 0</span></span><br></pre></td></tr></table></figure><h4 id="2-bisect-bisect-right"><a href="#2-bisect-bisect-right" class="headerlink" title="2. bisect.bisect_right"></a><strong>2. <code>bisect.bisect_right</code></strong></h4><p><strong>签名 (与 <code>bisect_left</code> 类似):</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bisect.bisect_right(a, x, lo=<span class="number">0</span>, hi=<span class="built_in">len</span>(a))</span><br></pre></td></tr></table></figure><p><code>bisect.bisect</code> 是 <code>bisect.bisect_right</code> 的一个别名，两者完全相同。</p><p><strong>详细解释：</strong><br>功能上完全等同于 C++ 的 <code>upper_bound</code>。它返回一个插入点 <code>i</code>，这个插入点会将 <code>x</code> 插入到 <code>a</code> 中所有等于 <code>x</code> 的元素<strong>之后</strong>。</p><p><strong>代码示例 (续上):</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> bisect</span><br><span class="line"></span><br><span class="line">a = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">30</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 查找一个存在且重复的元素</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Searching for 30:&quot;</span>)</span><br><span class="line">idx_right = bisect.bisect_right(a, <span class="number">30</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;bisect_right: index is <span class="subst">&#123;idx_right&#125;</span>&quot;</span>) <span class="comment"># 输出 index is 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 查找一个不存在的元素</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nSearching for 25:&quot;</span>)</span><br><span class="line">idx_right = bisect.bisect_right(a, <span class="number">25</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;bisect_right: index is <span class="subst">&#123;idx_right&#125;</span>&quot;</span>) <span class="comment"># 输出 index is 2 (和 bisect_left 结果相同)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 查找一个比所有元素都大的元素</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nSearching for 60:&quot;</span>)</span><br><span class="line">idx_right = bisect.bisect_right(a, <span class="number">60</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;bisect_right: index is <span class="subst">&#123;idx_right&#125;</span>&quot;</span>) <span class="comment"># 输出 index is 7</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 查找一个比所有元素都小的元素</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nSearching for 5:&quot;</span>)</span><br><span class="line">idx_right = bisect.bisect_right(a, <span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;bisect_right: index is <span class="subst">&#123;idx_right&#125;</span>&quot;</span>) <span class="comment"># 输出 index is 0</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：Python 的 <code>bisect</code> 模块本身没有 C++ <code>ranges</code> 那样直接的 <code>key</code> 或 <code>projection</code> 参数。如果你需要对复杂对象列表进行操作，通常有两种方法：</p><ol><li>创建一个只包含用于排序的键的临时列表，然后用 <code>bisect</code> 操作这个键列表。</li><li>将你的对象封装在一个类中，并实现 <code>__lt__</code> 等比较方法，这样 <code>bisect</code> 就可以直接比较对象了。</li><li>从 Python 3.10 开始，<code>bisect</code> 函数新增了 <code>key</code> 参数，用法和 <code>sorted()</code> 的 <code>key</code> 类似，这使得它和 C++ 的投影功能对齐了。</li></ol><hr><h3 id="核心差异与总结"><a href="#核心差异与总结" class="headerlink" title="核心差异与总结"></a><strong>核心差异与总结</strong></h3><table><thead><tr><th align="left">特性</th><th align="left">C++ <code>std::ranges</code></th><th align="left">Python <code>bisect</code></th></tr></thead><tbody><tr><td align="left"><strong>核心功能</strong></td><td align="left">查找排序序列中的插入点</td><td align="left">查找排序序列中的插入点</td></tr><tr><td align="left"><strong><code>lower_bound</code>&#x2F;<code>_left</code></strong></td><td align="left">返回第一个<strong>不小于</strong>目标值的位置</td><td align="left">返回第一个<strong>不小于</strong>目标值的位置</td></tr><tr><td align="left"><strong><code>upper_bound</code>&#x2F;<code>_right</code></strong></td><td align="left">返回第一个<strong>严格大于</strong>目标值的位置</td><td align="left">返回第一个<strong>严格大于</strong>目标值的位置</td></tr><tr><td align="left"><strong>返回值类型</strong></td><td align="left"><strong>迭代器 (Iterator)</strong></td><td align="left"><strong>整数索引 (Integer Index)</strong></td></tr><tr><td align="left"><strong>库&#x2F;模块</strong></td><td align="left">C++20 <code>&lt;ranges&gt;</code> 标准库</td><td align="left">Python <code>bisect</code> 标准库模块</td></tr><tr><td align="left"><strong>处理复杂对象</strong></td><td align="left">非常强大，通过**投影(projection)<strong>和</strong>自定义比较(comparator)**实现</td><td align="left">Python 3.10+ 支持 <code>key</code> 参数。之前版本需要额外处理。</td></tr><tr><td align="left"><strong>语法</strong></td><td align="left"><code>std::ranges::func(range, value, comp, proj)</code></td><td align="left"><code>bisect.func(list, value, lo, hi, key)</code></td></tr></tbody></table><hr><h3 id="常见应用场景"><a href="#常见应用场景" class="headerlink" title="常见应用场景"></a><strong>常见应用场景</strong></h3><p>这些函数非常有用，远不止查找那么简单。</p><h4 id="1-高效地保持列表-向量有序"><a href="#1-高效地保持列表-向量有序" class="headerlink" title="1. 高效地保持列表&#x2F;向量有序"></a><strong>1. 高效地保持列表&#x2F;向量有序</strong></h4><p>这是它们的本职工作。</p><ul><li><strong>Python:</strong><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.insert(bisect.bisect_left(a, x), x)</span><br></pre></td></tr></table></figure></li><li><strong>C++:</strong><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.<span class="built_in">insert</span>(std::ranges::<span class="built_in">lower_bound</span>(v, x), x);</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-计算有序序列中特定值的数量"><a href="#2-计算有序序列中特定值的数量" class="headerlink" title="2. 计算有序序列中特定值的数量"></a><strong>2. 计算有序序列中特定值的数量</strong></h4><p>这是一个非常经典的用法。等于 <code>value</code> 的所有元素构成一个连续的区间，其起始点由 <code>lower_bound</code> 给出，结束点（不包含）由 <code>upper_bound</code> 给出。</p><ul><li><strong>Python:</strong><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">count = bisect.bisect_right(a, <span class="number">30</span>) - bisect.bisect_left(a, <span class="number">30</span>)</span><br><span class="line"><span class="comment"># count = 5 - 2 = 3</span></span><br></pre></td></tr></table></figure></li><li><strong>C++:</strong><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> count = std::<span class="built_in">distance</span>(std::ranges::<span class="built_in">lower_bound</span>(v, <span class="number">30</span>),</span><br><span class="line">                           std::ranges::<span class="built_in">upper_bound</span>(v, <span class="number">30</span>));</span><br><span class="line"><span class="comment">// count = 3</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="3-检查元素是否存在"><a href="#3-检查元素是否存在" class="headerlink" title="3. 检查元素是否存在"></a><strong>3. 检查元素是否存在</strong></h4><p>虽然有更直接的方法（如 <code>std::ranges::binary_search</code> 或 Python 的 <code>in</code>），但也可以用 <code>lower_bound</code> 来实现，这在某些复杂逻辑中可能更方便。</p><ul><li><strong>Python:</strong><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i = bisect.bisect_left(a, x)</span><br><span class="line"><span class="keyword">if</span> i != <span class="built_in">len</span>(a) <span class="keyword">and</span> a[i] == x:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;x&#125;</span> is in the list&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><strong>C++:</strong><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> it = std::ranges::<span class="built_in">lower_bound</span>(v, x);</span><br><span class="line"><span class="keyword">if</span> (it != v.<span class="built_in">end</span>() &amp;&amp; *it == x) &#123;</span><br><span class="line">    std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot; is in the vector&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>这里必须检查 <code>it != v.end()</code>，因为如果 <code>x</code> 比所有元素都大，<code>lower_bound</code> 会返回 <code>end()</code>，解引用 <code>end()</code> 是未定义行为。</li></ul><p>[1] <a href="https://www.bilibili.com/video/BV1y34y147s5/?spm_id_from=333.1365.top_right_bar_window_custom_collection.content.click&vd_source=58f3263b57ef9a6a30806fa51b07a5c1">二分查找为什么总是写错？</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CPP学习笔记—标准模板库（STL）中的容器</title>
      <link href="/2025/07/26/CPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93%EF%BC%88STL%EF%BC%89%E4%B8%AD%E7%9A%84%E5%AE%B9%E5%99%A8/"/>
      <url>/2025/07/26/CPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93%EF%BC%88STL%EF%BC%89%E4%B8%AD%E7%9A%84%E5%AE%B9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="一、什么是容器？为什么它如此重要？"><a href="#一、什么是容器？为什么它如此重要？" class="headerlink" title="一、什么是容器？为什么它如此重要？"></a><strong>一、什么是容器？为什么它如此重要？</strong></h3><p>简单来说，<strong>C++ 容器是用来存储和管理一组对象的类模板</strong>。它们就像是工具箱里不同种类的收纳盒：有的适合快速取放（像数组），有的适合保持物品有序（像分类文件柜），还有的适合快速查找（像带索引的卡片盒）。</p><p>使用 STL 容器的好处是巨大的：</p><ol><li><strong>代码更简洁</strong>：你无需从零开始实现链表、哈希表等复杂数据结构。</li><li><strong>性能更优越</strong>：STL 容器经过了高度优化，性能通常比手写的要好。</li><li><strong>代码更安全</strong>：它们处理了内存管理的细节，减少了内存泄漏和越界访问的风险。</li><li><strong>互操作性强</strong>：所有容器都遵循一套统一的接口（如 <code>begin()</code>, <code>end()</code>, <code>size()</code>），可以与 STL 的<strong>迭代器</strong>和<strong>算法</strong>无缝协作，威力倍增。</li></ol><hr><h3 id="二、容器的分类与概览"><a href="#二、容器的分类与概览" class="headerlink" title="二、容器的分类与概览"></a><strong>二、容器的分类与概览</strong></h3><p>C++ 的容器主要分为四大类，分别是序列容器、关联容器、无序关联容器和容器适配器。</p><table><thead><tr><th align="left">类别</th><th align="left">容器</th><th align="left">特点</th></tr></thead><tbody><tr><td align="left"><strong>序列容器</strong></td><td align="left"><code>vector</code>, <code>deque</code>, <code>list</code>, <code>array</code></td><td align="left">元素按线性顺序排列，可通过位置访问。</td></tr><tr><td align="left"><strong>关联容器</strong></td><td align="left"><code>map</code>, <code>set</code>, <code>multimap</code>, <code>multiset</code></td><td align="left">元素根据键值自动排序，查找速度快 (O(log N))。</td></tr><tr><td align="left"><strong>无序关联容器</strong></td><td align="left"><code>unordered_map</code>, <code>unordered_set</code>, …</td><td align="left">元素通过哈希存储，无序，查找速度极快 (平均 O(1))。</td></tr><tr><td align="left"><strong>容器适配器</strong></td><td align="left"><code>stack</code>, <code>queue</code>, <code>priority_queue</code></td><td align="left">提供特定接口（LIFO&#x2F;FIFO），是对其他容器的封装。</td></tr></tbody></table><hr><h3 id="三、序列容器-Sequence-Containers"><a href="#三、序列容器-Sequence-Containers" class="headerlink" title="三、序列容器 (Sequence Containers)"></a><strong>三、序列容器 (Sequence Containers)</strong></h3><p>序列容器中的元素按严格的线性序列排序，你可以通过元素在序列中的位置来访问它们。</p><h4 id="1-std-vector-—-动态数组"><a href="#1-std-vector-—-动态数组" class="headerlink" title="1. std::vector — 动态数组"></a><strong>1. <code>std::vector</code> — 动态数组</strong></h4><p><code>vector</code> 是最基本也是最常用的容器，是你的“默认选项”。</p><ul><li><strong>头文件</strong>: <code>#include &lt;vector&gt;</code></li><li><strong>本质</strong>: 一块在堆上分配的<strong>连续内存空间</strong>。当空间不足时，会自动重新分配一块更大的内存，并将原有元素移动过去。</li><li><strong>复杂度</strong>:<ul><li>随机访问 (通过 <code>[]</code> 或 <code>at()</code>): <strong>O(1)</strong></li><li>尾部添加&#x2F;删除 (<code>push_back</code>, <code>pop_back</code>): <strong>均摊 O(1)</strong></li><li>中间或头部添加&#x2F;删除 (<code>insert</code>, <code>erase</code>): <strong>O(N)</strong></li></ul></li><li><strong>适用场景</strong>:<ul><li>需要快速随机访问元素。</li><li>主要在容器末尾进行添加或删除操作。</li><li>在大多数情况下，当你需要一个动态数组时，<code>vector</code> 都是最佳选择。</li></ul></li></ul><p><strong>示例代码</strong>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_vector</span><span class="params">(<span class="type">const</span> std::string&amp; title, <span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; title &lt;&lt; <span class="string">&quot;:\t[ &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : v) std::cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;], size=&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot;, capacity=&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">    std::vector vec2 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">vec3</span><span class="params">(<span class="number">5</span>)</span></span>;   <span class="comment">//  初始化5个元素的vector，默认值为0</span></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">vec4</span><span class="params">(<span class="number">5</span>, <span class="number">2</span>)</span></span>;    <span class="comment">//  初始化5个元素的vector，默认值为2</span></span><br><span class="line">    <span class="built_in">print_vector</span>(<span class="string">&quot;Initial&quot;</span>, vec);</span><br><span class="line">    <span class="built_in">print_vector</span>(<span class="string">&quot;Initial vec2&quot;</span>, vec2);</span><br><span class="line">    <span class="built_in">print_vector</span>(<span class="string">&quot;Initial vec3&quot;</span>, vec3);</span><br><span class="line">    <span class="built_in">print_vector</span>(<span class="string">&quot;Initial vec4&quot;</span>, vec4);</span><br><span class="line"></span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">    <span class="built_in">print_vector</span>(<span class="string">&quot;After push_back&quot;</span>, vec);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 随机访问</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Element at index 1: &quot;</span> &lt;&lt; vec.<span class="built_in">at</span>(<span class="number">1</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在中间插入</span></span><br><span class="line">    vec.<span class="built_in">insert</span>(vec.<span class="built_in">begin</span>() + <span class="number">1</span>, <span class="number">15</span>);</span><br><span class="line">    <span class="built_in">print_vector</span>(<span class="string">&quot;After insert&quot;</span>, vec);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除元素</span></span><br><span class="line">    vec.<span class="built_in">erase</span>(vec.<span class="built_in">begin</span>() + <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">print_vector</span>(<span class="string">&quot;After erase&quot;</span>, vec);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除一个区间的元素</span></span><br><span class="line">    vec.<span class="built_in">erase</span>(vec.<span class="built_in">begin</span>() + <span class="number">2</span>, vec.<span class="built_in">end</span>()); <span class="comment">// 删除索引2到末尾的元素</span></span><br><span class="line">    <span class="built_in">print_vector</span>(<span class="string">&quot;After erase from index 2 to end&quot;</span>, vec);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 弹出最后一个元素</span></span><br><span class="line">    vec.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="built_in">print_vector</span>(<span class="string">&quot;After pop_back&quot;</span>, vec);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">Initial:        [ ], size=0, capacity=0</span></span><br><span class="line"><span class="comment">After push_back:        [ 10 20 30 ], size=3, capacity=4</span></span><br><span class="line"><span class="comment">Element at index 1: 20</span></span><br><span class="line"><span class="comment">After insert:   [ 10 15 20 30 ], size=4, capacity=4</span></span><br><span class="line"><span class="comment">After erase:    [ 10 15 30 ], size=3, capacity=4</span></span><br><span class="line"><span class="comment">After erase from index 2 to end:        [ 10 15 ], size=2, capacity=4</span></span><br><span class="line"><span class="comment">After pop_back: [ 10 ], size=1, capacity=4</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="2-std-deque-—-双端队列"><a href="#2-std-deque-—-双端队列" class="headerlink" title="2. std::deque — 双端队列"></a><strong>2. <code>std::deque</code> — 双端队列</strong></h4><p><code>deque</code> (double-ended queue) 是一个在两端操作都非常高效的序列。</p><ul><li><strong>头文件</strong>: <code>#include &lt;deque&gt;</code></li><li><strong>本质</strong>: 由多个独立的小内存块（chunks）和一箇中控的映射结构组成，<strong>非连续内存</strong>。</li><li><strong>复杂度</strong>:<ul><li>随机访问: <strong>O(1)</strong> (但比 <code>vector</code> 慢，需要两次指针解引用)</li><li>头部和尾部添加&#x2F;删除 (<code>push_front</code>, <code>pop_front</code>, <code>push_back</code>, <code>pop_back</code>): <strong>O(1)</strong></li><li>中间添加&#x2F;删除: <strong>O(N)</strong></li></ul></li><li><strong>适用场景</strong>:<ul><li>需要在容器的<strong>两端</strong>进行频繁的插入和删除操作。</li><li>例如，实现一个任务队列，既可以从队首取任务，也可以在队尾或队首添加新任务。</li></ul></li></ul><p><strong>示例代码</strong>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_deque</span><span class="params">(<span class="type">const</span> std::string&amp; title, <span class="type">const</span> std::deque&lt;<span class="type">int</span>&gt;&amp; d)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; title &lt;&lt; <span class="string">&quot;:\t[ &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : d) std::cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;], size=&quot;</span> &lt;&lt; d.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::deque&lt;<span class="type">int</span>&gt; deq = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;;</span><br><span class="line">    <span class="built_in">print_deque</span>(<span class="string">&quot;Initial&quot;</span>, deq);</span><br><span class="line"></span><br><span class="line">    deq.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">    <span class="built_in">print_deque</span>(<span class="string">&quot;After push_back(40)&quot;</span>, deq);</span><br><span class="line"></span><br><span class="line">    deq.<span class="built_in">push_front</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">print_deque</span>(<span class="string">&quot;After push_front(5)&quot;</span>, deq);</span><br><span class="line"></span><br><span class="line">    deq.<span class="built_in">pop_front</span>();</span><br><span class="line">    <span class="built_in">print_deque</span>(<span class="string">&quot;After pop_front()&quot;</span>, deq);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">Initial:        [ 10 20 30 ], size=3</span></span><br><span class="line"><span class="comment">After push_back(40):    [ 10 20 30 40 ], size=4</span></span><br><span class="line"><span class="comment">After push_front(5):    [ 5 10 20 30 40 ], size=5</span></span><br><span class="line"><span class="comment">After pop_front():      [ 10 20 30 40 ], size=4</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="3-std-list-—-双向链表"><a href="#3-std-list-—-双向链表" class="headerlink" title="3. std::list — 双向链表"></a><strong>3. <code>std::list</code> — 双向链表</strong></h4><p><code>list</code> 专为在任意位置进行快速插入和删除而设计。</p><ul><li><strong>头文件</strong>: <code>#include &lt;list&gt;</code></li><li><strong>本质</strong>: 一个<strong>双向链表</strong>，每个节点包含元素值以及指向前一个和后一个节点的指针。</li><li><strong>复杂度</strong>:<ul><li>随机访问: <strong>O(N)</strong> (不支持 <code>[]</code> 或 <code>at()</code>)</li><li>任意位置添加&#x2F;删除: <strong>O(1)</strong> (前提是已有指向该位置的迭代器)</li></ul></li><li><strong>适用场景</strong>:<ul><li>当程序需要对序列进行大量、频繁的<strong>非头部非尾部</strong>的插入和删除操作时。</li><li>对元素的随机访问需求不高。</li></ul></li></ul><p><strong>示例代码</strong>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_list</span><span class="params">(<span class="type">const</span> std::string&amp; title, <span class="type">const</span> std::list&lt;<span class="type">int</span>&gt;&amp; l)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; title &lt;&lt; <span class="string">&quot;:\t[ &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : l) std::cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;], size=&quot;</span> &lt;&lt; l.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::list&lt;<span class="type">int</span>&gt; myList = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">40</span>&#125;;</span><br><span class="line">    <span class="built_in">print_list</span>(<span class="string">&quot;Initial&quot;</span>, myList);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> it = myList.<span class="built_in">begin</span>();</span><br><span class="line">    ++it; <span class="comment">// it 指向 20</span></span><br><span class="line">    myList.<span class="built_in">insert</span>(it, <span class="number">15</span>); <span class="comment">// 在 20 前插入 15</span></span><br><span class="line">    <span class="built_in">print_list</span>(<span class="string">&quot;After insert&quot;</span>, myList);</span><br><span class="line"></span><br><span class="line">    it = myList.<span class="built_in">begin</span>();</span><br><span class="line">    ++it; ++it; <span class="comment">// it 指向 20</span></span><br><span class="line">    myList.<span class="built_in">erase</span>(it);</span><br><span class="line">    <span class="built_in">print_list</span>(<span class="string">&quot;After erase&quot;</span>, myList);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">Initial:        [ 10 20 40 ], size=3</span></span><br><span class="line"><span class="comment">After insert:   [ 10 15 20 40 ], size=4</span></span><br><span class="line"><span class="comment">After erase:    [ 10 15 40 ], size=3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="4-std-array-—-固定大小数组"><a href="#4-std-array-—-固定大小数组" class="headerlink" title="4. std::array — 固定大小数组"></a><strong>4. <code>std::array</code> — 固定大小数组</strong></h4><p><code>std::array</code> 是对 C 风格静态数组的轻量级、类型安全的封装。</p><ul><li><strong>头文件</strong>: <code>#include &lt;array&gt;</code></li><li><strong>本质</strong>: 一块在<strong>栈上或静态存储区</strong>分配的<strong>固定大小的连续内存空间</strong>。它的大小在<strong>编译时</strong>就必须确定，之后不能改变。它本质上就是对 C 语言数组 <code>T arr[N]</code> 的一个包装。</li><li><strong>复杂度</strong>:<ul><li>随机访问 (通过 <code>[]</code> 或 <code>at()</code>): <strong>O(1)</strong></li><li>不支持任何改变其大小的操作（如 <code>push_back</code>, <code>insert</code>, <code>erase</code> 等）。</li></ul></li><li><strong>适用场景</strong>:<ul><li>当你需要一个<strong>大小在编译时就已知</strong>的固定长度数组时。</li><li>相比 C 风格数组，<code>std::array</code> 提供了容器的通用接口（如 <code>size()</code>, <code>begin()</code>, <code>end()</code>, <code>empty()</code>），可以无缝地与 STL 算法（如 <code>std::sort</code>）配合使用。</li><li>它不会退化为指针，作为函数参数传递时会传递整个数组（或其引用），保留了大小信息，更加安全。</li></ul></li></ul><p><strong>示例代码</strong>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span> <span class="comment">// for std::sort</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数可以安全地接收 std::array，并知道其大小</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_array</span><span class="params">(<span class="type">const</span> std::array&lt;<span class="type">int</span>, <span class="number">5</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Array contents: [ &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> element : arr) &#123;</span><br><span class="line">        std::cout &lt;&lt; element &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;], size=&quot;</span> &lt;&lt; arr.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 声明一个包含 5 个整数的 array</span></span><br><span class="line">    std::array&lt;<span class="type">int</span>, 5&gt; myArray = &#123;<span class="number">30</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">20</span>, <span class="number">40</span>&#125;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Initial state:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">print_array</span>(myArray);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 随机访问</span></span><br><span class="line">    myArray[<span class="number">0</span>] = <span class="number">35</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Element at index 2: &quot;</span> &lt;&lt; myArray.<span class="built_in">at</span>(<span class="number">2</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 STL 算法</span></span><br><span class="line">    std::<span class="built_in">sort</span>(myArray.<span class="built_in">begin</span>(), myArray.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nAfter sorting:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">print_array</span>(myArray);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 填充所有元素为 0</span></span><br><span class="line">    myArray.<span class="built_in">fill</span>(<span class="number">0</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nAfter filling with 0:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">print_array</span>(myArray);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编译错误示例：</span></span><br><span class="line">    <span class="comment">// myArray.push_back(100); // 错误！std::array 没有 push_back 方法</span></span><br><span class="line">    <span class="comment">// std::array&lt;int, some_runtime_variable&gt; runtimeArray; // 错误！大小必须是编译时常量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">Initial state:</span></span><br><span class="line"><span class="comment">Array contents: [ 30 10 50 20 40 ], size=5</span></span><br><span class="line"><span class="comment">Element at index 2: 50</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">After sorting:</span></span><br><span class="line"><span class="comment">Array contents: [ 10 20 35 40 50 ], size=5</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">After filling with 0:</span></span><br><span class="line"><span class="comment">Array contents: [ 0 0 0 0 0 ], size=5</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><hr><h3 id="四、关联容器-Associative-Containers"><a href="#四、关联容器-Associative-Containers" class="headerlink" title="四、关联容器 (Associative Containers)"></a><strong>四、关联容器 (Associative Containers)</strong></h3><p>关联容器中的元素根据它们的键自动排序，提供了高效的查找能力。</p><h4 id="1-std-map-—-有序键值对"><a href="#1-std-map-—-有序键值对" class="headerlink" title="1. std::map — 有序键值对"></a><strong>1. <code>std::map</code> — 有序键值对</strong></h4><ul><li><strong>头文件</strong>: <code>#include &lt;map&gt;</code></li><li><strong>本质</strong>: 通常是<strong>红黑树</strong> (一种自平衡二叉搜索树)。存储 <code>std::pair&lt;const Key, T&gt;</code> 类型的键值对，键是唯一的，并根据键自动排序。</li><li><strong>复杂度</strong>:<ul><li>插入、删除、查找 (<code>insert</code>, <code>erase</code>, <code>find</code>, <code>count</code>): <strong>O(log N)</strong></li></ul></li><li><strong>适用场景</strong>:<ul><li>需要存储唯一的键值对，并希望它们根据键自动排序。</li><li>需要高效地根据键查找、更新或删除对应的值。</li><li>例如，存储字典、配置文件、学生ID和姓名的映射等。</li></ul></li></ul><p><strong>示例代码</strong>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::map&lt;std::string, <span class="type">int</span>&gt; student_ages;</span><br><span class="line"></span><br><span class="line">    student_ages[<span class="string">&quot;Alice&quot;</span>] = <span class="number">21</span>;</span><br><span class="line">    student_ages.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(<span class="string">&quot;Bob&quot;</span>, <span class="number">22</span>));</span><br><span class="line">    student_ages.<span class="built_in">emplace</span>(<span class="string">&quot;Charlie&quot;</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Bob&#x27;s age is: &quot;</span> &lt;&lt; student_ages.<span class="built_in">at</span>(<span class="string">&quot;Bob&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历 map，元素会按键的字母顺序输出</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;All students:\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pair : student_ages) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; pair.first &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; pair.second &lt;&lt; <span class="string">&quot; years old.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    student_ages.<span class="built_in">erase</span>(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Number of students after erasing Alice: &quot;</span> &lt;&lt; student_ages.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">Bob&#x27;s age is: 22</span></span><br><span class="line"><span class="comment">All students:</span></span><br><span class="line"><span class="comment"> - Alice is 21 years old.</span></span><br><span class="line"><span class="comment"> - Bob is 22 years old.</span></span><br><span class="line"><span class="comment"> - Charlie is 20 years old.</span></span><br><span class="line"><span class="comment">Number of students after erasing Alice: 2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="2-std-set-—-有序唯一集合"><a href="#2-std-set-—-有序唯一集合" class="headerlink" title="2. std::set — 有序唯一集合"></a><strong>2. <code>std::set</code> — 有序唯一集合</strong></h4><ul><li><strong>头文件</strong>: <code>#include &lt;set&gt;</code></li><li><strong>本质</strong>: 同样是<strong>红黑树</strong>。只存储键，没有值。可以看作是一种只有键的 <code>map</code>。元素是唯一的，并自动排序。</li><li><strong>复杂度</strong>:<ul><li>插入、删除、查找: <strong>O(log N)</strong></li></ul></li><li><strong>适用场景</strong>:<ul><li>需要存储一组唯一的元素，并保持它们有序。</li><li>需要快速判断一个元素是否存在于集合中。</li><li>例如，存储不重复的用户ID、统计文章中出现的不同单词等。</li></ul></li></ul><p><strong>示例代码</strong>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::set&lt;std::string&gt; unique_words;</span><br><span class="line"></span><br><span class="line">    unique_words.<span class="built_in">insert</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    unique_words.<span class="built_in">insert</span>(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">    unique_words.<span class="built_in">insert</span>(<span class="string">&quot;hello&quot;</span>); <span class="comment">// 重复插入会被忽略</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Unique words count: &quot;</span> &lt;&lt; unique_words.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unique_words.<span class="built_in">count</span>(<span class="string">&quot;world&quot;</span>)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;&#x27;world&#x27; is in the set.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历 set，元素会按字母顺序输出</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Words in set:\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; word : unique_words) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; word &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">Unique words count: 2</span></span><br><span class="line"><span class="comment">&#x27;world&#x27; is in the set.</span></span><br><span class="line"><span class="comment">Words in set:</span></span><br><span class="line"><span class="comment"> - hello</span></span><br><span class="line"><span class="comment"> - world</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="3-std-multimap-—-有序多重映射"><a href="#3-std-multimap-—-有序多重映射" class="headerlink" title="3. std::multimap — 有序多重映射"></a><strong>3. <code>std::multimap</code> — 有序多重映射</strong></h4><p>在 <code>std::map</code> 和 <code>std::set</code> 的基础上，STL 提供了它们的多键版本，允许存储重复的键。<code>multimap</code> 是 <code>map</code> 的变体，它允许存储具有相同键的多个键值对。</p><ul><li><strong>头文件</strong>: <code>#include &lt;map&gt;</code></li><li><strong>本质</strong>: 与 <code>std::map</code> 一样，通常是<strong>红黑树</strong>。它存储的也是 <code>std::pair&lt;const Key, T&gt;</code>，但<strong>允许键 (Key) 重复</strong>。所有元素仍然会根据键自动排序。</li><li><strong>复杂度</strong>:<ul><li>插入 (<code>insert</code>): <strong>O(log N)</strong></li><li>删除 (<code>erase</code>): <strong>O(log N + k)</strong>，其中 k 是被删除的元素数量。</li><li>查找 (<code>find</code>, <code>count</code>, <code>equal_range</code>): <strong>O(log N)</strong></li></ul></li><li><strong>适用场景</strong>:<ul><li>需要表示**“一对多”**的关系。</li><li>例如，一个字典中一个单词可以有多个释义；一个学生可以注册多门课程；一个作者可以有多本著作。在这些场景下，键（单词、学生、作者）是相同的，但值（释义、课程、著作）不同。</li></ul></li></ul><p><strong>示例代码</strong>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::multimap&lt;std::string, std::string&gt; student_courses;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加选课记录，Alice 选了三门课</span></span><br><span class="line">    student_courses.<span class="built_in">insert</span>(&#123;<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Math101&quot;</span>&#125;);</span><br><span class="line">    student_courses.<span class="built_in">insert</span>(&#123;<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;CS101&quot;</span>&#125;);</span><br><span class="line">    student_courses.<span class="built_in">insert</span>(&#123;<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Physics201&quot;</span>&#125;);</span><br><span class="line">    student_courses.<span class="built_in">insert</span>(&#123;<span class="string">&quot;Charlie&quot;</span>, <span class="string">&quot;History101&quot;</span>&#125;);</span><br><span class="line">    student_courses.<span class="built_in">insert</span>(&#123;<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Chem101&quot;</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询某个键的数量</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Alice is enrolled in &quot;</span> &lt;&lt; student_courses.<span class="built_in">count</span>(<span class="string">&quot;Alice&quot;</span>) &lt;&lt; <span class="string">&quot; courses.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找并打印 Alice 的所有课程</span></span><br><span class="line">    <span class="comment">// 使用 equal_range 是最高效且最标准的方式</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nCourses for Alice:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">auto</span> range = student_courses.<span class="built_in">equal_range</span>(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = range.first; it != range.second; ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历整个 multimap，键相同的元素会相邻出现</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nAll enrollments:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pair : student_courses) &#123;</span><br><span class="line">        std::cout &lt;&lt; pair.first &lt;&lt; <span class="string">&quot; -&gt; &quot;</span> &lt;&lt; pair.second &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">Alice is enrolled in 3 courses.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Courses for Alice:</span></span><br><span class="line"><span class="comment"> - Math101</span></span><br><span class="line"><span class="comment"> - Physics201</span></span><br><span class="line"><span class="comment"> - Chem101</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">All enrollments:</span></span><br><span class="line"><span class="comment">Alice -&gt; Math101</span></span><br><span class="line"><span class="comment">Alice -&gt; Physics201</span></span><br><span class="line"><span class="comment">Alice -&gt; Chem101</span></span><br><span class="line"><span class="comment">Bob -&gt; CS101</span></span><br><span class="line"><span class="comment">Charlie -&gt; History101</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="4-std-multiset-—-有序多重集合"><a href="#4-std-multiset-—-有序多重集合" class="headerlink" title="4. std::multiset — 有序多重集合"></a><strong>4. <code>std::multiset</code> — 有序多重集合</strong></h4><p><code>multiset</code> 是 <code>set</code> 的变体，它允许存储多个相同的元素。</p><ul><li><strong>头文件</strong>: <code>#include &lt;set&gt;</code></li><li><strong>本质</strong>: 与 <code>std::set</code> 一样，是<strong>红黑树</strong>。它允许存储<strong>重复的元素</strong>，并且所有元素都会自动排序。</li><li><strong>复杂度</strong>:<ul><li>插入 (<code>insert</code>): <strong>O(log N)</strong></li><li>删除 (<code>erase</code>): <strong>O(log N + k)</strong>，其中 k 是被删除的元素数量。</li><li>查找 (<code>find</code>, <code>count</code>): <strong>O(log N)</strong></li></ul></li><li><strong>适用场景</strong>:<ul><li>需要存储一个可以有重复值的有序集合。</li><li>例如，存储一场比赛的所有得分（可能会有同分）；对一组数字进行排序并保留所有重复项；或者需要快速统计集合中某个特定值的出现次数。</li></ul></li></ul><p><strong>示例代码</strong>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_multiset</span><span class="params">(<span class="type">const</span> std::string&amp; title, <span class="type">const</span> std::multiset&lt;<span class="type">int</span>&gt;&amp; ms)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; title &lt;&lt; <span class="string">&quot;:\t[ &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> score : ms) &#123;</span><br><span class="line">        std::cout &lt;&lt; score &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;]&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::multiset&lt;<span class="type">int</span>&gt; scores;</span><br><span class="line"></span><br><span class="line">    scores.<span class="built_in">insert</span>(<span class="number">88</span>);</span><br><span class="line">    scores.<span class="built_in">insert</span>(<span class="number">95</span>);</span><br><span class="line">    scores.<span class="built_in">insert</span>(<span class="number">73</span>);</span><br><span class="line">    scores.<span class="built_in">insert</span>(<span class="number">88</span>); <span class="comment">// 允许插入重复的 88</span></span><br><span class="line">    scores.<span class="built_in">insert</span>(<span class="number">95</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print_multiset</span>(<span class="string">&quot;All scores (sorted)&quot;</span>, scores);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询某个分数的数量</span></span><br><span class="line">    <span class="type">int</span> score_to_find = <span class="number">88</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The score &quot;</span> &lt;&lt; score_to_find &lt;&lt; <span class="string">&quot; appears &quot;</span></span><br><span class="line">              &lt;&lt; scores.<span class="built_in">count</span>(score_to_find) &lt;&lt; <span class="string">&quot; times.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除所有等于 95 的分数</span></span><br><span class="line">    scores.<span class="built_in">erase</span>(<span class="number">95</span>);</span><br><span class="line">    <span class="built_in">print_multiset</span>(<span class="string">&quot;After erasing all 95s&quot;</span>, scores);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">All scores (sorted):    [ 73 88 88 95 95 ]</span></span><br><span class="line"><span class="comment">The score 88 appears 2 times.</span></span><br><span class="line"><span class="comment">After erasing all 95s:  [ 73 88 88 ]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><hr><h3 id="五、无序关联容器-Unordered-Associative-Containers"><a href="#五、无序关联容器-Unordered-Associative-Containers" class="headerlink" title="五、无序关联容器 (Unordered Associative Containers)"></a><strong>五、无序关联容器 (Unordered Associative Containers)</strong></h3><p>C++11 引入，基于哈希表实现，提供平均常数时间的查找性能，但元素无序。</p><h4 id="1-std-unordered-map-—-哈希映射"><a href="#1-std-unordered-map-—-哈希映射" class="headerlink" title="1. std::unordered_map — 哈希映射"></a><strong>1. <code>std::unordered_map</code> — 哈希映射</strong></h4><ul><li><strong>头文件</strong>: <code>#include &lt;unordered_map&gt;</code></li><li><strong>本质</strong>: <strong>哈希表</strong>。存储唯一的键值对，但元素之间没有特定的顺序，其存储位置由键的哈希值决定。</li><li><strong>复杂度</strong>:<ul><li>插入、删除、查找: <strong>平均 O(1)</strong>, 最坏 O(N) (哈希冲突严重时)</li></ul></li><li><strong>适用场景</strong>:<ul><li>当你需要 <code>map</code> 的功能（键值对存储和快速查找），但<strong>不关心元素的顺序</strong>时。</li><li>在性能至关重要的场景下，它通常是比 <code>map</code> 更快的选择。</li></ul></li></ul><p><strong>示例代码</strong>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::unordered_map&lt;std::string, std::string&gt; capital_cities;</span><br><span class="line"></span><br><span class="line">    capital_cities[<span class="string">&quot;China&quot;</span>] = <span class="string">&quot;Beijing&quot;</span>;</span><br><span class="line">    capital_cities[<span class="string">&quot;France&quot;</span>] = <span class="string">&quot;Paris&quot;</span>;</span><br><span class="line">    capital_cities.<span class="built_in">emplace</span>(<span class="string">&quot;Japan&quot;</span>, <span class="string">&quot;Tokyo&quot;</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The capital of France is: &quot;</span> &lt;&lt; capital_cities[<span class="string">&quot;France&quot;</span>] &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历顺序是不确定的</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;All entries:\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pair : capital_cities) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; pair.first &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; pair.second &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">The capital of France is: Paris</span></span><br><span class="line"><span class="comment">All entries:</span></span><br><span class="line"><span class="comment"> - Japan: Tokyo</span></span><br><span class="line"><span class="comment"> - France: Paris</span></span><br><span class="line"><span class="comment"> - China: Beijing</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="2-std-unordered-set-—-哈希集合"><a href="#2-std-unordered-set-—-哈希集合" class="headerlink" title="2. std::unordered_set — 哈希集合"></a><strong>2. <code>std::unordered_set</code> — 哈希集合</strong></h4><ul><li><strong>头文件</strong>: <code>#include &lt;unordered_set&gt;</code></li><li><strong>本质</strong>: <strong>哈希表</strong>。存储唯一的元素，无序。</li><li><strong>复杂度</strong>:<ul><li>插入、删除、查找: <strong>平均 O(1)</strong>, 最坏 O(N)</li></ul></li><li><strong>适用场景</strong>:<ul><li>需要快速地判断一个元素是否存在于一个集合中，且完全不关心顺序。</li><li>例如，用作访问记录，快速检查某个IP地址今天是否已经访问过。</li></ul></li></ul><p><strong>示例代码</strong>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::unordered_set&lt;<span class="type">int</span>&gt; visited_ids;</span><br><span class="line"></span><br><span class="line">    visited_ids.<span class="built_in">insert</span>(<span class="number">101</span>);</span><br><span class="line">    visited_ids.<span class="built_in">insert</span>(<span class="number">205</span>);</span><br><span class="line">    visited_ids.<span class="built_in">insert</span>(<span class="number">101</span>); <span class="comment">// 再次插入，被忽略</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (visited_ids.<span class="built_in">find</span>(<span class="number">205</span>) != visited_ids.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ID 205 has been visited.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Total unique visited IDs: &quot;</span> &lt;&lt; visited_ids.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">ID 205 has been visited.</span></span><br><span class="line"><span class="comment">Total unique visited IDs: 2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><hr><h3 id="六、容器适配器-Container-Adapters"><a href="#六、容器适配器-Container-Adapters" class="headerlink" title="六、容器适配器 (Container Adapters)"></a><strong>六、容器适配器 (Container Adapters)</strong></h3><p>它们不是独立的容器，而是对现有序列容器（默认为 <code>std::deque</code>）的接口进行封装，以提供特定的行为模式。</p><h4 id="1-std-stack-—-栈"><a href="#1-std-stack-—-栈" class="headerlink" title="1. std::stack — 栈"></a><strong>1. <code>std::stack</code> — 栈</strong></h4><ul><li><strong>头文件</strong>: <code>#include &lt;stack&gt;</code></li><li><strong>本质</strong>: 封装了其他容器（默认 <code>std::deque</code>）的<strong>后进先出 (LIFO)</strong> 接口。</li><li><strong>复杂度</strong>:<ul><li><code>push</code>, <code>pop</code>, <code>top</code>: <strong>O(1)</strong> (依赖于底层容器的 <code>push_back</code>, <code>pop_back</code>, <code>back</code> 操作)</li></ul></li><li><strong>适用场景</strong>:<ul><li>需要后进先出行为的任何地方。</li><li>例如，函数调用栈、括号匹配、表达式求值等。</li></ul></li></ul><p><strong>示例代码</strong>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">    s.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    s.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">    s.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Top element: &quot;</span> &lt;&lt; s.<span class="built_in">top</span>() &lt;&lt; std::endl; <span class="comment">// 3</span></span><br><span class="line">    s.<span class="built_in">pop</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Top element after pop: &quot;</span> &lt;&lt; s.<span class="built_in">top</span>() &lt;&lt; std::endl; <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Stack is &quot;</span> &lt;&lt; (s.<span class="built_in">empty</span>() ? <span class="string">&quot;empty&quot;</span> : <span class="string">&quot;not empty&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">Top element: 3</span></span><br><span class="line"><span class="comment">Top element after pop: 2</span></span><br><span class="line"><span class="comment">Stack is not empty</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="2-std-queue-—-队列"><a href="#2-std-queue-—-队列" class="headerlink" title="2. std::queue — 队列"></a><strong>2. <code>std::queue</code> — 队列</strong></h4><ul><li><strong>头文件</strong>: <code>#include &lt;queue&gt;</code></li><li><strong>本质</strong>: 封装了其他容器（默认 <code>std::deque</code>）的<strong>先进先出 (FIFO)</strong> 接口。</li><li><strong>复杂度</strong>:<ul><li><code>push</code>, <code>pop</code>, <code>front</code>, <code>back</code>: <strong>O(1)</strong> (依赖于底层容器的 <code>push_back</code>, <code>pop_front</code>, <code>front</code>, <code>back</code> 操作)</li></ul></li><li><strong>适用场景</strong>:<ul><li>需要先进先出行为的任何地方。</li><li>例如，任务队列、广度优先搜索 (BFS)、打印机缓冲池等。</li></ul></li></ul><p><strong>示例代码</strong>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::queue&lt;std::string&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="string">&quot;First&quot;</span>);</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="string">&quot;Second&quot;</span>);</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="string">&quot;Third&quot;</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Front of queue: &quot;</span> &lt;&lt; q.<span class="built_in">front</span>() &lt;&lt; std::endl; <span class="comment">// First</span></span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Front after pop: &quot;</span> &lt;&lt; q.<span class="built_in">front</span>() &lt;&lt; std::endl; <span class="comment">// Second</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">Front of queue: First</span></span><br><span class="line"><span class="comment">Front after pop: Second</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="3-std-priority-queue-—-优先队列"><a href="#3-std-priority-queue-—-优先队列" class="headerlink" title="3. std::priority_queue — 优先队列"></a><strong>3. <code>std::priority_queue</code> — 优先队列</strong></h4><ul><li><strong>头文件</strong>: <code>#include &lt;queue&gt;</code></li><li><strong>本质</strong>: 封装了其他容器（默认 <code>std::vector</code>）并使用<strong>堆 (heap)</strong> 算法来维护的结构。每次取出的都是当前队列中优先级最高的元素。</li><li><strong>复杂度</strong>:<ul><li><code>push</code>: <strong>O(log N)</strong></li><li><code>pop</code>: <strong>O(log N)</strong></li><li><code>top</code>: <strong>O(1)</strong></li></ul></li><li><strong>适用场景</strong>:<ul><li>需要不断处理当前集合中最大（或最小）的元素。</li><li>例如，事件调度、Dijkstra算法、A*搜索算法等。</li></ul></li></ul><p><strong>示例代码 (默认最大堆)</strong>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span> <span class="comment">// for std::greater</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 最大堆 (默认)</span></span><br><span class="line">    std::priority_queue&lt;<span class="type">int</span>&gt; max_heap;</span><br><span class="line">    max_heap.<span class="built_in">push</span>(<span class="number">30</span>);</span><br><span class="line">    max_heap.<span class="built_in">push</span>(<span class="number">100</span>);</span><br><span class="line">    max_heap.<span class="built_in">push</span>(<span class="number">20</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Max element: &quot;</span> &lt;&lt; max_heap.<span class="built_in">top</span>() &lt;&lt; std::endl; <span class="comment">// 100</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最小堆 (需要提供比较函数)</span></span><br><span class="line">    std::priority_queue&lt;<span class="type">int</span>, std::vector&lt;<span class="type">int</span>&gt;, std::greater&lt;<span class="type">int</span>&gt;&gt; min_heap;</span><br><span class="line">    min_heap.<span class="built_in">push</span>(<span class="number">30</span>);</span><br><span class="line">    min_heap.<span class="built_in">push</span>(<span class="number">100</span>);</span><br><span class="line">    min_heap.<span class="built_in">push</span>(<span class="number">20</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Min element: &quot;</span> &lt;&lt; min_heap.<span class="built_in">top</span>() &lt;&lt; std::endl; <span class="comment">// 20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">Max element: 100</span></span><br><span class="line"><span class="comment">Min element: 20</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CPP学习笔记—指针</title>
      <link href="/2025/07/26/CPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E6%8C%87%E9%92%88/"/>
      <url>/2025/07/26/CPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<h3 id="一、指针到底是什么？——-内存地址的“房卡”"><a href="#一、指针到底是什么？——-内存地址的“房卡”" class="headerlink" title="一、指针到底是什么？—— 内存地址的“房卡”"></a><strong>一、指针到底是什么？—— 内存地址的“房卡”</strong></h3><p>想象一下计算机的内存是一家长长的酒店，里面有无数的房间，每个房间都有一个独一无二的<strong>门牌号（内存地址）</strong>。</p><ul><li><p><strong>普通变量</strong>：就像一个<strong>房间</strong>，里面存放着具体的<strong>东西（值）</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> age = <span class="number">25</span>; <span class="comment">// 在一个叫 `age` 的房间里，放了数字 25。</span></span><br></pre></td></tr></table></figure></li><li><p><strong>指针</strong>：它本身也是一个变量，但它里面存放的不是普通的东西，而是一张<strong>房卡</strong>。这张房卡上写着另一个房间的<strong>门牌号</strong>。</p></li></ul><p>所以，<strong>指针是一个存储了另一个变量内存地址的变量</strong>。通过这张“房卡”，我们就能找到并操作那个特定的“房间”。</p><hr><h3 id="二、两大核心操作符：-取地址-和-解引用"><a href="#二、两大核心操作符：-取地址-和-解引用" class="headerlink" title="二、两大核心操作符：&amp; (取地址) 和 * (解引用)"></a><strong>二、两大核心操作符：<code>&amp;</code> (取地址) 和 <code>*</code> (解引用)</strong></h3><p>要玩转指针，必须掌握这两个“魔法”操作符。</p><h4 id="1-取地址符-——-“制作房卡”"><a href="#1-取地址符-——-“制作房卡”" class="headerlink" title="1. &amp; (取地址符) —— “制作房卡”"></a><strong>1. <code>&amp;</code> (取地址符) —— “制作房卡”</strong></h4><p><code>&amp;</code> 符号的作用是获取一个变量的内存地址。可以把它读作“…的地址”。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> age = <span class="number">25</span>;       <span class="comment">// 一个存放 25 的房间 `age`</span></span><br><span class="line"><span class="type">int</span>* p_age = &amp;age;  <span class="comment">// 创建一张叫 `p_age` 的房卡，</span></span><br><span class="line">                    <span class="comment">// 上面记录 `age` 房间的门牌号 (&amp;age)。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// `int*` 表示 `p_age` 是一个“专门指向整数类型房间”的指针(房卡)。</span></span><br></pre></td></tr></table></figure><h4 id="2-解引用-间接访问符-——-“刷卡进门”"><a href="#2-解引用-间接访问符-——-“刷卡进门”" class="headerlink" title="2. * (解引用&#x2F;间接访问符) —— “刷卡进门”"></a><strong>2. <code>*</code> (解引用&#x2F;间接访问符) —— “刷卡进门”</strong></h4><p><code>*</code> 符号的作用是访问指针所指向的地址中存储的值。可以把它读作“访问…所指向地址里的值”。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; *p_age; <span class="comment">// 输出 25</span></span><br><span class="line"><span class="comment">// 这行代码的意思是：“使用 p_age 这张房卡，打开它指向的房间，把里面的东西拿出来看看。”</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们甚至可以通过指针修改原变量的值</span></span><br><span class="line">*p_age = <span class="number">30</span>; <span class="comment">// 刷卡进门，把房间里的 25 换成了 30。</span></span><br><span class="line">std::cout &lt;&lt; age;    <span class="comment">// 现在直接看 age 房间，会发现它也变成了 30。</span></span><br></pre></td></tr></table></figure><p><strong>小结：</strong> <code>&amp;</code> 是从值到地址，<code>*</code> 是从地址到值。它们是一对互逆的操作。</p><hr><h3 id="三、为什么我们需要指针？——-C-的“超能力”"><a href="#三、为什么我们需要指针？——-C-的“超能力”" class="headerlink" title="三、为什么我们需要指针？—— C++的“超能力”"></a><strong>三、为什么我们需要指针？—— C++的“超能力”</strong></h3><p>直接用 <code>age</code> 不就行了，为什么要多此一举用指针？问得好！指针之所以重要，主要体现在以下几个方面：</p><h4 id="1-高效的函数传参"><a href="#1-高效的函数传参" class="headerlink" title="1. 高效的函数传参"></a><strong>1. 高效的函数传参</strong></h4><p>想象一个函数需要处理一个非常大的数据结构（比如一个包含一百万个元素的数组）。</p><ul><li><strong>不使用指针（传值）</strong>：函数会把整个百万元素的数组<strong>完整地复制一份</strong>。这既浪费时间又浪费内存。</li><li><strong>使用指针（传址）</strong>：只需要把数组的“房卡”（一个仅占 8 字节的地址）复制给函数。函数通过这张小小的房卡，就能直接访问和修改原始的、巨大的数组。效率天差地别！</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设 BigData 是一个很大的结构体</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processData</span><span class="params">(BigData* data)</span> </span>&#123; <span class="comment">// 只传递一个地址，非常快！</span></span><br><span class="line">    <span class="comment">// 通过指针直接操作原始数据</span></span><br><span class="line">    data-&gt;some_value = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-动态内存管理"><a href="#2-动态内存管理" class="headerlink" title="2. 动态内存管理"></a><strong>2. 动态内存管理</strong></h4><p>有时候，我们在写代码时并不知道程序运行时需要多少内存。比如，用户可能要处理 10 个文件，也可能要处理 1000 个。指针允许我们在程序运行时，按需向操作系统申请内存（在“堆”上）。</p><ul><li><code>new</code>：向系统申请一块新内存（建一个新房间），并返回一个指向它的指针（一张新房卡）。</li><li><code>delete</code>：告诉系统这块内存我用完了，你可以回收了（退房）。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* dynamic_array;</span><br><span class="line"><span class="type">int</span> size = <span class="number">100</span>; <span class="comment">// 假设这个 size 是用户输入的</span></span><br><span class="line"></span><br><span class="line">dynamic_array = <span class="keyword">new</span> <span class="type">int</span>[size]; <span class="comment">// 申请能容纳100个整数的连续内存空间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ... 使用这个数组 ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span>[] dynamic_array; <span class="comment">// 使用完毕，必须释放内存！</span></span><br></pre></td></tr></table></figure><h4 id="3-实现多态"><a href="#3-实现多态" class="headerlink" title="3. 实现多态"></a><strong>3. 实现多态</strong></h4><p>在面向对象编程中，我们可以用基类的指针指向派生类的对象，从而实现多态，让代码更加灵活和可扩展。这是 C++ 高级特性之一，其基础就是指针。</p><hr><h3 id="四、指针的“危险地带”：必须知道的注意事项"><a href="#四、指针的“危险地带”：必须知道的注意事项" class="headerlink" title="四、指针的“危险地带”：必须知道的注意事项"></a><strong>四、指针的“危险地带”：必须知道的注意事项</strong></h3><p>指针的灵活性也带来了风险：</p><h4 id="1-野指针-Wild-Pointer"><a href="#1-野指针-Wild-Pointer" class="headerlink" title="1. 野指针 (Wild Pointer)"></a><strong>1. 野指针 (Wild Pointer)</strong></h4><p>一个未经初始化的指针，它的指向是完全随机的，就像一张印着未知门牌号的房卡。使用它就像在酒店里乱刷卡，可能会闯入不该进的房间，导致程序崩溃。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p;   <span class="comment">// 野指针！它指向哪里完全未知。</span></span><br><span class="line">*p = <span class="number">10</span>;  <span class="comment">// 灾难！试图向一个未知地址写入数据。</span></span><br></pre></td></tr></table></figure><p><strong>防御方法</strong>：在定义指针时，立即初始化！</p><h4 id="2-空指针-Null-Pointer"><a href="#2-空指针-Null-Pointer" class="headerlink" title="2. 空指针 (Null Pointer)"></a><strong>2. 空指针 (Null Pointer)</strong></h4><p>为了安全，当我们暂时没有明确的目标让指针指向时，应该给它一个特殊的值 <code>nullptr</code> (C++11 推荐)。这就像一张被明确标记为“无效”的房卡。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p = <span class="literal">nullptr</span>; <span class="comment">// 好习惯！明确表示p不指向任何东西。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在使用前，务必检查</span></span><br><span class="line"><span class="keyword">if</span> (p != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    *p = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-悬挂指针-Dangling-Pointer"><a href="#3-悬挂指针-Dangling-Pointer" class="headerlink" title="3. 悬挂指针 (Dangling Pointer)"></a><strong>3. 悬挂指针 (Dangling Pointer)</strong></h4><p>当指针指向的内存已经被释放（<code>delete</code>），但指针本身没有被置为 <code>nullptr</code> 时，它就成了悬挂指针。这就像退了房，但房卡还留在手里，而那个房间可能已经分给了下一位客人。此时再用这张房卡，后果不堪设想。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">5</span>);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">delete</span> p; <span class="comment">// 内存被释放，房间被回收</span></span><br><span class="line"><span class="comment">// 此时 p 变成了悬挂指针</span></span><br><span class="line"></span><br><span class="line">*p = <span class="number">20</span>; <span class="comment">// 极其危险的操作！</span></span><br></pre></td></tr></table></figure><p><strong>防御方法</strong>：释放内存后，立即将指针置为 <code>nullptr</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line">p = <span class="literal">nullptr</span>; <span class="comment">// 安全了！</span></span><br></pre></td></tr></table></figure><h4 id="4-内存泄漏-Memory-Leak"><a href="#4-内存泄漏-Memory-Leak" class="headerlink" title="4. 内存泄漏 (Memory Leak)"></a><strong>4. 内存泄漏 (Memory Leak)</strong></h4><p>如果用 <code>new</code> 申请了内存，但在程序结束前忘记用 <code>delete</code> 释放它，这块内存就“丢失”了。它既不能被程序使用，也无法被系统回收。这就像不断开新房间但从不退房，最终会导致酒店（系统）没有可用房间（内存耗尽）。</p><p><strong>防御方法</strong>：确保每一个 <code>new</code> 都有一个对应的 <code>delete</code>（或 <code>delete[]</code>）。</p><hr><h3 id="五、现代C-的救赎：智能指针"><a href="#五、现代C-的救赎：智能指针" class="headerlink" title="五、现代C++的救赎：智能指针"></a><strong>五、现代C++的救赎：智能指针</strong></h3><p>手动管理内存（<code>new</code>&#x2F;<code>delete</code>）既繁琐又容易出错。为了解决这个问题，现代 C++（C++11及以后）引入了<strong>智能指针</strong>，这才是我们现在应该优先使用的工具！</p><p>智能指针本质上是一个类，它包装了原始指针，并利用类的构造函数和析构函数来自动管理内存的生命周期。</p><ul><li><code>std::unique_ptr</code>：独占所有权的智能指针。当它被销毁时，它所管理的内存会自动释放。保证了任何时候只有一个指针指向资源。</li><li><code>std::shared_ptr</code>：共享所有权的智能指针。它使用引用计数，只有当最后一个指向资源的 <code>shared_ptr</code> 被销毁时，内存才会被释放。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_smart_pointers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 不需要手动 delete！</span></span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>&gt; p1 = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当 p1 离开作用域时 (比如函数结束)，它指向的内存会自动被释放。</span></span><br><span class="line">    <span class="comment">// 这就是所谓的 RAII (Resource Acquisition Is Initialization) 技术。</span></span><br><span class="line">&#125; <span class="comment">// p1 在这里被销毁，内存自动释放</span></span><br></pre></td></tr></table></figure><p><strong>黄金法则：</strong> 在现代 C++ 编程中，<strong>优先使用智能指针来管理动态分配的内存</strong>，只有在与旧的 C API 交互或特定性能优化场景下，才考虑使用原始指针。</p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>指针是 C++ 的核心，也是它的魅力所在。它赋予了我们直接与内存对话的能力。</p><ul><li><strong>核心是地址</strong>：指针存储的是地址。</li><li><strong><code>&amp;</code> 和 <code>*</code> 是钥匙</strong>：<code>&amp;</code> 用来获取地址，<code>*</code> 用来通过地址访问内容。</li><li><strong>能力伴随风险</strong>：务必警惕野指针、悬挂指针和内存泄漏。</li><li><strong>拥抱现代 C++</strong>：尽可能使用智能指针，让编译器处理繁琐的内存管理。</li></ul>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python输入输出处理</title>
      <link href="/2025/07/14/Python%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%A4%84%E7%90%86/"/>
      <url>/2025/07/14/Python%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h3 id="核心知识点"><a href="#核心知识点" class="headerlink" title="核心知识点"></a>核心知识点</h3><ol><li><p><strong><code>input()</code> vs <code>sys.stdin.readline()</code></strong></p><ul><li><code>input()</code>: 内置函数，使用方便，但速度较慢。它会读取一行，去除末尾的换行符 <code>\n</code>，并返回一个字符串。</li><li><code>sys.stdin.readline()</code>: 速度更快，因为它使用了缓冲区。它会读取一行，但<strong>保留</strong>末尾的换行符 <code>\n</code>。因此，通常需要配合 <code>.strip()</code> 或 <code>.rstrip()</code> 使用。</li></ul></li><li><p><strong><code>print()</code> vs <code>sys.stdout.write()</code></strong></p><ul><li><code>print()</code>: 内置函数，功能强大，可以自动在末尾添加换行符，但相对较慢。</li><li><code>sys.stdout.write()</code>: 速度更快，但只接受字符串作为参数，且<strong>不会</strong>自动添加换行符，需要手动添加 <code>&#39;\n&#39;</code>。</li></ul></li></ol><p>对于追求极致性能的竞赛，推荐使用 <code>sys</code> 模块。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="comment"># 之后就可以使用 sys.stdin.readline() 和 sys.stdout.write()</span></span><br></pre></td></tr></table></figure><hr><h3 id="一、-输入-Input"><a href="#一、-输入-Input" class="headerlink" title="一、 输入 (Input)"></a>一、 输入 (Input)</h3><h4 id="场景1：读取单行数据"><a href="#场景1：读取单行数据" class="headerlink" title="场景1：读取单行数据"></a>场景1：读取单行数据</h4><h5 id="1-1-读取一个字符串"><a href="#1-1-读取一个字符串" class="headerlink" title="1.1 读取一个字符串"></a>1.1 读取一个字符串</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方法一：使用 input() (方便，但稍慢)</span></span><br><span class="line">s = <span class="built_in">input</span>() </span><br><span class="line"><span class="comment"># 示例输入: hello world</span></span><br><span class="line"><span class="comment"># s 的值: &#x27;hello world&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法二：使用 sys.stdin.readline() (推荐，更快)</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">s = sys.stdin.readline().strip() <span class="comment"># .strip() 去除首尾空白，包括换行符</span></span><br><span class="line"><span class="comment"># 示例输入: hello world</span></span><br><span class="line"><span class="comment"># s 的值: &#x27;hello world&#x27;</span></span><br></pre></td></tr></table></figure><h5 id="1-2-读取一个整数或浮点数"><a href="#1-2-读取一个整数或浮点数" class="headerlink" title="1.2 读取一个整数或浮点数"></a>1.2 读取一个整数或浮点数</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方法一：使用 input()</span></span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">f = <span class="built_in">float</span>(<span class="built_in">input</span>())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法二：使用 sys.stdin.readline() (推荐)</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">n = <span class="built_in">int</span>(sys.stdin.readline())</span><br><span class="line">f = <span class="built_in">float</span>(sys.stdin.readline())</span><br></pre></td></tr></table></figure><h4 id="场景2：读取单行内的多个值"><a href="#场景2：读取单行内的多个值" class="headerlink" title="场景2：读取单行内的多个值"></a>场景2：读取单行内的多个值</h4><p>这是最常见的场景之一，一行中有多个由空格隔开的数字或字符串。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 示例输入: 10 20</span></span><br><span class="line"><span class="comment"># 示例输入: apple banana orange</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法一：使用 input().split()</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取两个整数</span></span><br><span class="line">a_str, b_str = <span class="built_in">input</span>().split()</span><br><span class="line">a, b = <span class="built_in">int</span>(a_str), <span class="built_in">int</span>(b_str)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更简洁的写法：使用 map()</span></span><br><span class="line">a, b = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()) </span><br><span class="line"><span class="comment"># a 的值: 10, b 的值: 20</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取一个整数和一个字符串</span></span><br><span class="line">n, s = <span class="built_in">input</span>().split()</span><br><span class="line">n = <span class="built_in">int</span>(n)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法二：使用 sys.stdin.readline().split() (推荐)</span></span><br><span class="line">a, b = <span class="built_in">map</span>(<span class="built_in">int</span>, sys.stdin.readline().split())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取一个列表</span></span><br><span class="line"><span class="comment"># 示例输入: 1 2 3 4 5</span></span><br><span class="line">nums_str = <span class="built_in">input</span>().split() <span class="comment"># [&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;]</span></span><br><span class="line">nums = [<span class="built_in">int</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> nums_str] <span class="comment"># [1, 2, 3, 4, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 更简洁的写法</span></span><br><span class="line">nums = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))</span><br><span class="line"><span class="comment"># 或者使用 sys.stdin.readline()</span></span><br><span class="line">nums = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, sys.stdin.readline().split()))</span><br></pre></td></tr></table></figure><h4 id="场景3：读取固定行数的多行数据"><a href="#场景3：读取固定行数的多行数据" class="headerlink" title="场景3：读取固定行数的多行数据"></a>场景3：读取固定行数的多行数据</h4><p>通常第一行会给出一个整数 <code>N</code>，表示接下来有 <code>N</code> 行数据。</p><h5 id="3-1-每行只有一个数据"><a href="#3-1-每行只有一个数据" class="headerlink" title="3.1 每行只有一个数据"></a>3.1 每行只有一个数据</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 示例输入:</span></span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"><span class="comment"># apple</span></span><br><span class="line"><span class="comment"># banana</span></span><br><span class="line"><span class="comment"># orange</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取行数</span></span><br><span class="line">n = <span class="built_in">int</span>(sys.stdin.readline())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 循环读取N行</span></span><br><span class="line">data = []</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    line = sys.stdin.readline().strip()</span><br><span class="line">    data.append(line)</span><br><span class="line"><span class="comment"># data 的值: [&#x27;apple&#x27;, &#x27;banana&#x27;, &#x27;orange&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以用列表推导式，更简洁</span></span><br><span class="line"><span class="comment"># n = int(sys.stdin.readline())</span></span><br><span class="line"><span class="comment"># data = [sys.stdin.readline().strip() for _ in range(n)]</span></span><br></pre></td></tr></table></figure><h5 id="3-2-每行有多个数据"><a href="#3-2-每行有多个数据" class="headerlink" title="3.2 每行有多个数据"></a>3.2 每行有多个数据</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 示例输入:</span></span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"><span class="comment"># 1 2</span></span><br><span class="line"><span class="comment"># 3 4</span></span><br><span class="line"><span class="comment"># 5 6</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">n = <span class="built_in">int</span>(sys.stdin.readline())</span><br><span class="line">matrix = []</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    row = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, sys.stdin.readline().split()))</span><br><span class="line">    matrix.append(row)</span><br><span class="line"><span class="comment"># matrix 的值: [[1, 2], [3, 4], [5, 6]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 列表推导式写法</span></span><br><span class="line"><span class="comment"># n = int(sys.stdin.readline())</span></span><br><span class="line"><span class="comment"># matrix = [list(map(int, sys.stdin.readline().split())) for _ in range(n)]</span></span><br></pre></td></tr></table></figure><h4 id="场景4：读取不定行数的数据，直到文件末尾-EOF"><a href="#场景4：读取不定行数的数据，直到文件末尾-EOF" class="headerlink" title="场景4：读取不定行数的数据，直到文件末尾 (EOF)"></a>场景4：读取不定行数的数据，直到文件末尾 (EOF)</h4><p>这种场景下，输入没有明确的结束标志，需要一直读取直到输入流结束。</p><h5 id="4-1-方法一：使用-try-except-适用于-input-和-sys-stdin-readline"><a href="#4-1-方法一：使用-try-except-适用于-input-和-sys-stdin-readline" class="headerlink" title="4.1 方法一：使用 try-except (适用于 input() 和 sys.stdin.readline())"></a>4.1 方法一：使用 <code>try-except</code> (适用于 <code>input()</code> 和 <code>sys.stdin.readline()</code>)</h5><p>当 <code>input()</code> 或 <code>sys.stdin.readline()</code> 读到文件末尾时，会引发 <code>EOFError</code> 或返回一个空字符串。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">lines = []</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        line = sys.stdin.readline().strip()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> line: <span class="comment"># 如果是空行或文件末尾，则跳出</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="comment"># 处理 line</span></span><br><span class="line">        <span class="comment"># 例如，将一行数字存入列表</span></span><br><span class="line">        nums = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, line.split()))</span><br><span class="line">        lines.append(nums)</span><br><span class="line">    <span class="keyword">except</span> EOFError:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="comment"># 之后处理 lines</span></span><br></pre></td></tr></table></figure><h5 id="4-2-方法二：直接遍历-sys-stdin-更-Pythonic，推荐"><a href="#4-2-方法二：直接遍历-sys-stdin-更-Pythonic，推荐" class="headerlink" title="4.2 方法二：直接遍历 sys.stdin (更 Pythonic，推荐)"></a>4.2 方法二：直接遍历 <code>sys.stdin</code> (更 Pythonic，推荐)</h5><p><code>sys.stdin</code> 本身就是一个可迭代对象，当输入结束时，循环会自动停止。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> sys.stdin:</span><br><span class="line">    <span class="comment"># line 包含了末尾的 &#x27;\n&#x27;，通常需要处理</span></span><br><span class="line">    line = line.strip() </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> line: <span class="comment"># 有时需要处理空行</span></span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="comment"># 处理 line</span></span><br><span class="line">    a, b = <span class="built_in">map</span>(<span class="built_in">int</span>, line.split())</span><br><span class="line">    <span class="comment"># ... 进行计算和输出 ...</span></span><br></pre></td></tr></table></figure><h4 id="场景5：复杂的多组测试数据"><a href="#场景5：复杂的多组测试数据" class="headerlink" title="场景5：复杂的多组测试数据"></a>场景5：复杂的多组测试数据</h4><p>题目通常会先给一个测试组数 <code>T</code>，然后循环 <code>T</code> 次处理每一组数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 示例输入:</span></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"><span class="comment"># 1 2 3</span></span><br><span class="line"><span class="comment"># 4</span></span><br><span class="line"><span class="comment"># 10 20 30 40</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取测试组数 T</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    t = <span class="built_in">int</span>(sys.stdin.readline())</span><br><span class="line"><span class="keyword">except</span> (ValueError, IndexError): <span class="comment"># 预防空输入</span></span><br><span class="line">    t = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(t):</span><br><span class="line">    <span class="comment"># --- 开始处理一组测试数据 ---</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 读取该组数据的行数 N</span></span><br><span class="line">    n = <span class="built_in">int</span>(sys.stdin.readline())</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 读取该组数据的具体内容</span></span><br><span class="line">    nums = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, sys.stdin.readline().split()))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 在这里进行计算</span></span><br><span class="line">    result = <span class="built_in">sum</span>(nums)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 输出该组数据的结果</span></span><br><span class="line">    <span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure><hr><h3 id="二、-输出-Output"><a href="#二、-输出-Output" class="headerlink" title="二、 输出 (Output)"></a>二、 输出 (Output)</h3><h4 id="场景1：输出单个值"><a href="#场景1：输出单个值" class="headerlink" title="场景1：输出单个值"></a>场景1：输出单个值</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方法一：使用 print() (最常用)</span></span><br><span class="line">result = <span class="number">100</span></span><br><span class="line"><span class="built_in">print</span>(result) <span class="comment"># 自动换行</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法二：使用 sys.stdout.write() (更快)</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">result = <span class="number">100</span></span><br><span class="line"><span class="comment"># 必须转换为字符串，且手动添加换行符</span></span><br><span class="line">sys.stdout.write(<span class="built_in">str</span>(result) + <span class="string">&#x27;\n&#x27;</span>) </span><br></pre></td></tr></table></figure><h4 id="场景2：在一行输出多个值，用空格隔开"><a href="#场景2：在一行输出多个值，用空格隔开" class="headerlink" title="场景2：在一行输出多个值，用空格隔开"></a>场景2：在一行输出多个值，用空格隔开</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 示例：输出一个列表 [1, 2, 3, 4] 为 1 2 3 4</span></span><br><span class="line">data = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法一：使用 print() 的 * 解包</span></span><br><span class="line"><span class="built_in">print</span>(*data) <span class="comment"># *data 会将列表解包成 print(1, 2, 3, 4)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法二：使用 str.join() (推荐，非常高效)</span></span><br><span class="line"><span class="comment"># 注意：join() 的元素必须是字符串，所以要用 map(str, ...)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27; &#x27;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>, data)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法三：使用循环和 print() 的 end 参数</span></span><br><span class="line"><span class="keyword">for</span> i, item <span class="keyword">in</span> <span class="built_in">enumerate</span>(data):</span><br><span class="line">    <span class="comment"># print(item, end=&#x27; &#x27; if i &lt; len(data) - 1 else &#x27;&#x27;)</span></span><br><span class="line">    <span class="built_in">print</span>(item, end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>() <span class="comment"># 最后输出一个换行符来结束这一行</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法四：使用 sys.stdout.write() 和 join()</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.stdout.write(<span class="string">&#x27; &#x27;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>, data)) + <span class="string">&#x27;\n&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="场景3：格式化输出"><a href="#场景3：格式化输出" class="headerlink" title="场景3：格式化输出"></a>场景3：格式化输出</h4><h5 id="3-1-使用-f-string-Python-3-6-，推荐"><a href="#3-1-使用-f-string-Python-3-6-，推荐" class="headerlink" title="3.1 使用 f-string (Python 3.6+，推荐)"></a>3.1 使用 f-string (Python 3.6+，推荐)</h5><p>f-string 是目前最现代、最易读的格式化方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&quot;Alice&quot;</span></span><br><span class="line">score = <span class="number">95.5</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Name: <span class="subst">&#123;name&#125;</span>, Score: <span class="subst">&#123;score&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 控制浮点数精度 (例如，保留两位小数)</span></span><br><span class="line">pi = <span class="number">3.1415926</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;pi:<span class="number">.2</span>f&#125;</span>&quot;</span>) <span class="comment"># 输出: 3.14</span></span><br></pre></td></tr></table></figure><h5 id="3-2-使用-str-format-方法"><a href="#3-2-使用-str-format-方法" class="headerlink" title="3.2 使用 str.format() 方法"></a>3.2 使用 <code>str.format()</code> 方法</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&quot;Bob&quot;</span></span><br><span class="line">score = <span class="number">88.0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Name: &#123;&#125;, Score: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(name, score))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 控制浮点数精度</span></span><br><span class="line">pi = <span class="number">3.1415926</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&#123;:.2f&#125;&quot;</span>.<span class="built_in">format</span>(pi)) <span class="comment"># 输出: 3.14</span></span><br></pre></td></tr></table></figure><hr><h3 id="三、完整-ACM-模式模板"><a href="#三、完整-ACM-模式模板" class="headerlink" title="三、完整 ACM 模式模板"></a>三、完整 ACM 模式模板</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">solve</span>():</span><br><span class="line">    <span class="comment"># 读取单行输入</span></span><br><span class="line">    <span class="comment"># n, k = map(int, sys.stdin.readline().strip().split())</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 读取数组</span></span><br><span class="line">    <span class="comment"># arr = list(map(int, sys.stdin.readline().strip().split()))</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 在这里编写核心解题逻辑</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 构造结果</span></span><br><span class="line">    result = <span class="string">&quot;your_answer&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 输出结果</span></span><br><span class="line">    sys.stdout.write(<span class="built_in">str</span>(result) + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># 处理单组测试数据</span></span><br><span class="line">    <span class="comment"># solve()</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 处理多组测试数据</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 尝试读取测试组数 T</span></span><br><span class="line">        t = <span class="built_in">int</span>(sys.stdin.readline())</span><br><span class="line">    <span class="keyword">except</span> (ValueError, IndexError):</span><br><span class="line">        <span class="comment"># 如果读取失败（例如输入为空），则默认为1组或0组</span></span><br><span class="line">        t = <span class="number">1</span> <span class="comment"># 或者 t = 0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(t):</span><br><span class="line">        solve()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table><thead><tr><th align="left">操作</th><th align="left">方便但慢 (小数据量)</th><th align="left">高效推荐 (大数据量)</th></tr></thead><tbody><tr><td align="left"><strong>读一行</strong></td><td align="left"><code>s = input()</code></td><td align="left"><code>s = sys.stdin.readline().strip()</code></td></tr><tr><td align="left"><strong>读整数</strong></td><td align="left"><code>n = int(input())</code></td><td align="left"><code>n = int(sys.stdin.readline())</code></td></tr><tr><td align="left"><strong>读一行多个数</strong></td><td align="left"><code>arr = list(map(int, input().split()))</code></td><td align="left"><code>arr = list(map(int, sys.stdin.readline().split()))</code></td></tr><tr><td align="left"><strong>读到EOF</strong></td><td align="left"><code>try-except</code> 块</td><td align="left"><code>for line in sys.stdin:</code></td></tr><tr><td align="left"><strong>输出</strong></td><td align="left"><code>print(var)</code></td><td align="left"><code>sys.stdout.write(str(var) + &#39;\n&#39;)</code></td></tr><tr><td align="left"><strong>输出列表</strong></td><td align="left"><code>print(*my_list)</code></td><td align="left"><code>sys.stdout.write(&#39; &#39;.join(map(str, my_list)) + &#39;\n&#39;)</code></td></tr></tbody></table><p><strong>始终优先使用 <code>sys.stdin.readline()</code></strong>，并记得用 <code>.strip()</code> 或 <code>.rstrip()</code> 去掉换行符。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习—K近邻算法（KNN）</title>
      <link href="/2025/07/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94K%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95%EF%BC%88KNN%EF%BC%89/"/>
      <url>/2025/07/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94K%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95%EF%BC%88KNN%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="第一部分：KNN算法详解-K-近邻算法"><a href="#第一部分：KNN算法详解-K-近邻算法" class="headerlink" title="第一部分：KNN算法详解 (K-近邻算法)"></a><strong>第一部分：KNN算法详解 (K-近邻算法)</strong></h3><h4 id="1-核心思想"><a href="#1-核心思想" class="headerlink" title="1. 核心思想"></a><strong>1. 核心思想</strong></h4><p>KNN（K-Nearest Neighbors）是一种<strong>监督学习</strong>算法，既可以用于<strong>分类</strong>任务，也可以用于<strong>回归</strong>任务。它的核心思想是：一个样本的类别&#x2F;数值，由其在特征空间中<strong>最邻近的 K 个样本</strong>的类别&#x2F;数值来决定。</p><h4 id="2-算法步骤-以分类任务为例"><a href="#2-算法步骤-以分类任务为例" class="headerlink" title="2. 算法步骤 (以分类任务为例)"></a><strong>2. 算法步骤 (以分类任务为例)</strong></h4><p>假设我们有一个带标签的训练数据集，现在来了一个新的、没有标签的数据点，我们要预测它的类别。</p><p><strong>Step 1: 确定超参数 K</strong><br>K是一个正整数，代表我们要参考“邻居”的数量。这个值需要我们预先设定。比如，我们选择 K&#x3D;3。</p><p><strong>Step 2: 计算距离</strong><br>计算这个新的数据点与训练集中<strong>每一个</strong>数据点的距离。距离的度量方式有很多种，最常用的是：</p><ul><li><p><strong>欧氏距离 (Euclidean Distance):</strong><br>$$ d(x, y) &#x3D; \sqrt{\sum_{i&#x3D;1}^{n}(x_i - y_i)^2} $$</p></li><li><p><strong>曼哈顿距离 (Manhattan Distance):</strong><br>$$ d(x, y) &#x3D; \sum_{i&#x3D;1}^{n}|x_i - y_i| $$</p></li><li><p><strong>闵可夫斯基距离 (Minkowski Distance):</strong><br>$$ d(x, y) &#x3D; (\sum_{i&#x3D;1}^{n}|x_i - y_i|^p)^{1&#x2F;p} $$</p></li></ul><p><strong>Step 3: 找到最近的 K 个邻居</strong><br>根据上一步计算出的距离，对所有训练样本进行排序，找出距离最近的 K 个样本。</p><p><strong>Step 4: 做出决策</strong></p><ul><li><strong>用于分类：</strong> 在这 K 个邻居中，采用“少数服从多数”的原则，哪个类别的样本最多，新的数据点就被预测为哪个类别。</li><li><strong>用于回归：</strong> 预测一个具体的数值。通常是取这 K 个邻居的数值的<strong>平均值</strong>或<strong>加权平均值</strong>（例如，距离越近的邻居权重越高）。</li></ul><hr><h3 id="第二部分：以MNIST数据集为例，说明距离的计算过程"><a href="#第二部分：以MNIST数据集为例，说明距离的计算过程" class="headerlink" title="第二部分：以MNIST数据集为例，说明距离的计算过程"></a><strong>第二部分：以MNIST数据集为例，说明距离的计算过程</strong></h3><h4 id="第一步：理解数据本身——图像如何表示为向量"><a href="#第一步：理解数据本身——图像如何表示为向量" class="headerlink" title="第一步：理解数据本身——图像如何表示为向量"></a><strong>第一步：理解数据本身——图像如何表示为向量</strong></h4><p>MNIST 数据集中的每一张图片都是一个 28x28 像素的灰度图。</p><p><img src="/img_1/02.png" alt="MNIST数据集中的&quot;7&quot;"></p><ul><li><strong>图像：</strong> 在我们眼中，它是一张图片，比如一个手写的 “7”。</li><li><strong>计算机的表示：</strong> 对计算机来说，它是一个 28x28 的矩阵。矩阵中的每一个元素代表一个像素点，其值在 0 到 255 之间，表示该点的灰度（0代表纯黑，255代表纯白）。</li></ul><p>为了在 KNN 算法中计算距离，我们首先需要把这个二维的图像矩阵“拉平”（Flatten），变成一个一维的向量。</p><ul><li><strong>原始矩阵:</strong> 一个 28x28 的矩阵</li><li><strong>拉平操作:</strong> 将矩阵的第一行、第二行、…、第二十八行，依次拼接起来，形成一个长长的一维向量。</li><li><strong>特征向量:</strong> 这个向量的维度就是 <code>28 * 28 = 784</code>。所以，<strong>每一张手写数字图片，都被表示为了一个 784 维空间中的一个点</strong>。</li></ul><p>这个 784 维的向量就是这张图片的<strong>特征向量 (Feature Vector)</strong>。</p><h4 id="第二步：计算距离——在784维空间中丈量"><a href="#第二步：计算距离——在784维空间中丈量" class="headerlink" title="第二步：计算距离——在784维空间中丈量"></a><strong>第二步：计算距离——在784维空间中丈量</strong></h4><p>现在，我们有了两个手写数字图片，比如图片A和图片B。它们分别被转换成了两个 784 维的向量：</p><ul><li>向量 <code>A = (a₁, a₂, a₃, ..., a₇₈₄)</code></li><li>向量 <code>B = (b₁, b₂, b₃, ..., b₇₈₄)</code></li></ul><p>其中 <code>aᵢ</code> 和 <code>bᵢ</code> 分别是两张图片第 <code>i</code> 个像素点的灰度值。</p><p>接下来，我们就可以像在二维、三维空间中一样，计算这两个高维向量之间的距离了。最常用的仍然是<strong>欧氏距离</strong>。</p><p><strong>欧氏距离计算公式：</strong><br>$$ d(A, B) &#x3D; \sqrt{(a_1 - b_1)^2 + (a_2 - b_2)^2 + \dots + (a_{784} - b_{784})^2} $$<br>$$ d(A, B) &#x3D; \sqrt{\sum_{i&#x3D;1}^{784}(a_i - b_i)^2} $$</p><p><strong>直观理解这个距离的含义：</strong><br>这个距离衡量的是两张图片在<strong>逐个像素点上的差异程度</strong>。</p><ul><li>如果两张图片非常相似（比如两个不同人写的、但都很标准的 “1”），那么它们对应位置的像素值会很接近，<code>(aᵢ - bᵢ)²</code> 的值会很小，最终计算出的总距离也会很小。</li><li>如果两张图片差异巨大（比如一个是 “1”，一个是 “8”），那么它们在很多位置上的像素值都会有很大差别，<code>(aᵢ - bᵢ)²</code> 的值会很大，最终计算出的总距离也就会很大。</li></ul><p><strong>举一个简化的例子：</strong></p><p>假设我们处理的是 3x3 的迷你图片，而不是 28x28。</p><p><strong>图片A (一个”X”):</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[255,   0, 255],</span><br><span class="line"> [  0, 255,   0],</span><br><span class="line"> [255,   0, 255]]</span><br></pre></td></tr></table></figure><p>拉平后的向量 <code>A = (255, 0, 255, 0, 255, 0, 255, 0, 255)</code></p><p><strong>图片B (一个”O”):</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[  0, 255,   0],</span><br><span class="line"> [255,   0, 255],</span><br><span class="line"> [  0, 255,   0]]</span><br></pre></td></tr></table></figure><p>拉平后的向量 <code>B = (0, 255, 0, 255, 0, 255, 0, 255, 0)</code></p><p><strong>计算A和B的欧氏距离：</strong><br>$$ d(A, B) &#x3D; \sqrt{ (255-0)^2 + (0-255)^2 + (255-0)^2 + \dots } $$<br>你会发现每一项都是 <code>(±255)²</code>，这个距离会非常大。</p><p>现在，再来一张<strong>图片C (一个略有不同的”X”)</strong>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[250,   5, 250],</span><br><span class="line"> [ 10, 245,  10],</span><br><span class="line"> [250,   5, 250]]</span><br></pre></td></tr></table></figure><p>拉平后的向量 <code>C = (250, 5, 250, 10, 245, 10, 250, 5, 250)</code></p><p><strong>计算A和C的欧氏距离：</strong><br>$$ d(A, C) &#x3D; \sqrt{ (255-250)^2 + (0-5)^2 + (255-250)^2 + \dots } $$<br>$$ d(A, C) &#x3D; \sqrt{ 5^2 + (-5)^2 + 5^2 + \dots } $$<br>你会发现每一项的差值都很小，所以 <code>d(A, C)</code> 会远远小于 <code>d(A, B)</code>。</p><p>因此，在KNN算法中，如果拿图片C去预测，它很可能会找到图片A作为它的近邻，从而被正确地分类为”X”。</p><p><strong>面试中的引申问题：</strong></p><ol><li><p><strong>数据归一化在这里重要吗？</strong></p><ul><li><strong>回答：</strong> 是的，很重要。虽然MNIST所有特征（像素值）的量纲都是一样的（0-255），但进行归一化（比如将所有像素值除以255，缩放到[0, 1]区间）是一个非常好的习惯。这样做可以<strong>改善模型的数值稳定性</strong>，并且在后续使用梯度下降等优化算法时（虽然KNN不用，但深度学习用）能<strong>加快收敛速度</strong>。所以，这是一个标准的预处理步骤。</li></ul></li><li><p><strong>784维是不是太高了？这有什么问题吗？</strong></p><ul><li><strong>回答：</strong> 是的，784维属于高维数据。这会引出我们之前讨论过的**“维度灾难”**问题。在高维空间中，数据点会变得稀疏，距离的区分度可能会下降。尽管如此，KNN在MNIST上依然能取得不错的（超过95%）的准确率，证明了这种基于像素的距离度量在一定程度上是有效的。</li><li><strong>进一步加分：</strong> 我们可以通过<strong>主成分分析（PCA）<strong>等降维技术，将784维的特征向量降到更低的维度（比如50维或100维），同时保留大部分信息。在降维后的空间里再使用KNN，通常可以</strong>大幅提升计算速度</strong>，并且有时还能<strong>因为去除了噪声而提升模型性能</strong>。</li></ul></li></ol><hr><h3 id="第三部分：以MNIST数据集为例，说明KNN的执行步骤"><a href="#第三部分：以MNIST数据集为例，说明KNN的执行步骤" class="headerlink" title="第三部分：以MNIST数据集为例，说明KNN的执行步骤"></a><strong>第三部分：以MNIST数据集为例，说明KNN的执行步骤</strong></h3><p><strong>数据集背景:</strong></p><ul><li><strong>训练集 (Training Set):</strong> 60,000 张 28x28 像素的图片，每张图片都有一个明确的标签（0, 1, 2, …, 9）。这是我们的“参考答案库”。</li><li><strong>测试集 (Test Set):</strong> 10,000 张 28x28 像素的图片，同样带有标签。我们用它来评估模型的效果，但在预测时，我们会假装不知道它的标签。</li></ul><h4 id="KNN在MNIST上的执行步骤"><a href="#KNN在MNIST上的执行步骤" class="headerlink" title="KNN在MNIST上的执行步骤"></a><strong>KNN在MNIST上的执行步骤</strong></h4><h5 id="预备阶段：数据准备-Data-Preparation"><a href="#预备阶段：数据准备-Data-Preparation" class="headerlink" title="预备阶段：数据准备 (Data Preparation)"></a><strong>预备阶段：数据准备 (Data Preparation)</strong></h5><p>在运行算法之前，我们必须先处理数据。</p><ol><li><p><strong>数据加载：</strong> 从文件中加载60,000张训练图片、对应的60,000个标签，以及10,000张测试图片和对应的10,000个标签。</p></li><li><p><strong>数据“拉平”(Flattening)：</strong></p><ul><li>每一张图片是一个 <code>28x28</code> 的二维矩阵。</li><li>为了计算距离，我们将其转换为一个 <code>1x784</code> 的一维向量（特征向量）。</li><li>操作后，我们的训练集就变成了一个 <code>60000 x 784</code> 的巨大矩阵，每一行代表一张图片。</li></ul></li><li><p><strong>数据归一化 (Normalization)：</strong></p><ul><li>原始像素值的范围是 [0, 255]。不同图片中笔画的深浅可能会影响距离计算。</li><li>我们将所有像素值都除以 255，将它们缩放到 [0, 1] 区间。这是一个标准的预处理步骤，能提升模型的稳定性和性能。</li><li>现在，训练集矩阵里的每个元素都在0和1之间。</li></ul></li></ol><h5 id="算法执行阶段-以预测一张新的测试图片为例"><a href="#算法执行阶段-以预测一张新的测试图片为例" class="headerlink" title="算法执行阶段 (以预测一张新的测试图片为例)"></a><strong>算法执行阶段 (以预测一张新的测试图片为例)</strong></h5><p>假设我们从10,000张测试图片中，拿出<strong>第一张</strong>图片，想预测它是什么数字。我们称之为<code>test_image_1</code>。</p><p><strong>第1步：确定超参数 K</strong><br>这是我们必须预先决定的。K值的选择会影响最终结果。我们先选择一个常见的、较小的值，比如 <strong>K&#x3D;5</strong>。</p><p><strong>第2步：计算距离</strong><br>这是最核心、也是最耗时的一步。</p><ul><li>拿出 <code>test_image_1</code> 的784维向量。</li><li>将这个向量与训练集中<strong>每一张</strong>图片（共60,000张）的784维向量，逐一计算<strong>欧氏距离</strong>。</li><li>这个过程会产生 <strong>60,000个</strong> 距离值。每一个距离值都代表了 <code>test_image_1</code> 与某一张训练图片的“相似程度”（距离越小越相似）。</li></ul><p><strong>第3步：找到最近的 K 个邻居</strong></p><ul><li>我们有了一个包含60,000个距离值的列表。</li><li>对这个列表进行<strong>升序排序</strong>，找到值最小的前 K 个。在我们这个例子里，就是找到最小的 <strong>5个</strong> 距离值。</li><li>同时，记录下这5个距离值所对应的<strong>训练图片的原始标签</strong>。</li></ul><p><strong>第4步：投票决定类别</strong></p><ul><li>假设我们找到的5个最近邻居，它们的标签分别是：<code>{7, 9, 7, 1, 7}</code>。</li><li>我们进行“投票统计”：<ul><li>数字 “7” 出现了 3 次。</li><li>数字 “9” 出现了 1 次。</li><li>数字 “1” 出现了 1 次。</li></ul></li><li>根据“少数服从多数”原则，<strong>数字 “7” 的票数最多</strong>。</li></ul><p><strong>第5步：做出预测</strong></p><ul><li>我们的KNN模型最终预测 <code>test_image_1</code> 的类别为 <strong>7</strong>。</li></ul><h5 id="模型评估阶段-Evaluation"><a href="#模型评估阶段-Evaluation" class="headerlink" title="模型评估阶段 (Evaluation)"></a><strong>模型评估阶段 (Evaluation)</strong></h5><p>预测完一张图片还不够，我们需要知道模型的整体性能。</p><p><strong>第6步：评估准确率</strong></p><ul><li>我们拿出 <code>test_image_1</code> 的<strong>真实标签</strong>。假设它的真实标签确实是 “7”，那么这次预测就是<strong>正确</strong>的。如果真实标签是 “2”，那这次预测就是<strong>错误</strong>的。</li><li><strong>重复第2步到第5步</strong>，对测试集中<strong>所有10,000张图片</strong>都进行一次预测。</li><li>统计所有预测正确的次数。</li><li>计算最终的准确率：<br>$$ \text{Accuracy} &#x3D; \frac{\text{Number of Correct Predictions}}{\text{Total Number of Test Images}} &#x3D; \frac{\text{预测正确的图片数}}{10000} $$</li></ul><p>例如，如果我们正确预测了9,680张图片，那么模型的准确率就是 <code>9680 / 10000 = 96.8%</code>。</p><hr><h3 id="第四部分：核心考察点"><a href="#第四部分：核心考察点" class="headerlink" title="第四部分：核心考察点"></a><strong>第四部分：核心考察点</strong></h3><h4 id="考点1：KNN的优缺点是什么？"><a href="#考点1：KNN的优缺点是什么？" class="headerlink" title="考点1：KNN的优缺点是什么？"></a><strong>考点1：KNN的优缺点是什么？</strong></h4><p><strong>优点 (Pros):</strong></p><ol><li><strong>简单直观：</strong> 算法思想简单，易于理解和实现。是很好的入门和基线模型（Baseline）。</li><li><strong>非参数模型 (Non-parametric):</strong> 对数据分布没有假设（比如不像线性回归那样假设数据是线性的）。这使得KNN在处理一些非线性、复杂边界问题时有奇效。</li><li><strong>无需训练 (Lazy Learning):</strong> KNN是“懒惰学习”的代表。它没有显式的训练过程，只是把训练数据存储起来。训练时间开销为零。</li></ol><p><strong>缺点 (Cons):</strong></p><ol><li><strong>计算成本高昂：</strong> 预测阶段的计算量巨大。对于一个新样本，需要和所有N个训练样本计算距离，时间复杂度为O(N*d)，其中d是特征维度。当数据集很大时，预测会非常慢。</li><li><strong>内存占用大：</strong> 需要存储全部训练数据，对内存消耗大。</li><li><strong>对K值敏感：</strong> K值的选择直接影响模型性能，需要通过交叉验证等方法小心选择。</li><li><strong>受样本不均衡问题影响大：</strong> 如果某些类别的样本数量远多于其他类别，那么在投票时，数量多的类别会占据天然优势。</li><li><strong>维度灾难 (Curse of Dimensionality)：</strong> 随着特征维度的增加，KNN的性能会急剧下降。</li></ol><h4 id="考点2：K值的选择与影响-Bias-Variance-Tradeoff"><a href="#考点2：K值的选择与影响-Bias-Variance-Tradeoff" class="headerlink" title="考点2：K值的选择与影响 (Bias-Variance Tradeoff)"></a><strong>考点2：K值的选择与影响 (Bias-Variance Tradeoff)</strong></h4><ul><li><p><strong>较小的 K 值：</strong></p><ul><li>模型会变得更复杂，决策边界会更不规则。</li><li>容易受到噪声数据的影响，导致<strong>过拟合 (Overfitting)</strong>。</li><li>表现为<strong>低偏差 (Low Bias)</strong> 和 <strong>高方差 (High Variance)</strong>。</li></ul></li><li><p><strong>较大的 K 值：</strong></p><ul><li>模型会变得更简单，决策边界会更平滑。</li><li>会忽略数据中局部的、细微的结构，导致<strong>欠拟合 (Underfitting)</strong>。</li><li>表现为<strong>高偏差 (High Bias)</strong> 和 <strong>低方差 (Low Variance)</strong>。</li></ul></li><li><p><strong>如何选择K值？</strong></p><ul><li><strong>交叉验证 (Cross-Validation):</strong> 最常用的方法。将训练集分成多份，轮流作为验证集来测试不同K值的效果，选择在验证集上平均表现最好的K值。</li><li>通常K值会选择一个<strong>奇数</strong>，以避免在二分类问题中出现票数相等的情况。</li></ul></li></ul><h4 id="考点3：为什么KNN需要对数据进行归一化-Normalization-Standardization-？"><a href="#考点3：为什么KNN需要对数据进行归一化-Normalization-Standardization-？" class="headerlink" title="考点3：为什么KNN需要对数据进行归一化(Normalization&#x2F;Standardization)？"></a><strong>考点3：为什么KNN需要对数据进行归一化(Normalization&#x2F;Standardization)？</strong></h4><ul><li><strong>核心原因：</strong> KNN是基于<strong>距离</strong>的算法。如果不同特征的量纲（尺度）差异巨大，那么距离的计算将完全由尺度大的特征主导。</li><li><strong>举例说明：</strong> 假设有两个特征：身高（单位：cm，范围150-200）和体重（单位：kg，范围40-100）。在计算欧氏距离时，身高的差值平方项会比体重的差值平方项大得多，这会使得模型在计算距离时，几乎只考虑了身高，而忽略了体重这个特征。这显然是不合理的。</li><li><strong>解决方案：</strong><ul><li><strong>归一化 (Normalization):</strong> 将数据缩放到 [0, 1] 区间。公式：<code>X_norm = (X - X_min) / (X_max - X_min)</code></li><li><strong>标准化 (Standardization):</strong> 将数据缩放到均值为0，标准差为1的分布。公式：<code>X_std = (X - mean(X)) / std(X)</code></li><li>面试时能说出这个原因并给出例子，就是满分回答。</li></ul></li></ul><h4 id="考点4：如何理解KNN中的“维度灾难”？"><a href="#考点4：如何理解KNN中的“维度灾难”？" class="headerlink" title="考点4：如何理解KNN中的“维度灾难”？"></a><strong>考点4：如何理解KNN中的“维度灾难”？</strong></h4><ul><li><strong>直观理解：</strong> 在高维空间中，数据点会变得非常<strong>稀疏</strong>。想象一下，在一个一维线段上撒10个点很容易密集，但在一个三维立方体里撒10个点，它们会非常分散。</li><li><strong>距离失效：</strong> 在高维空间中，任意两点之间的欧氏距离的差值会变得很小，趋向于一致。换句话说，对于一个给定的查询点，它到“最近”邻居的距离和到“最远”邻居的距离相差无几。这使得“近邻”这个概念失去了意义。</li><li><strong>如何缓解？</strong><ul><li><strong>特征选择&#x2F;降维：</strong> 使用PCA等方法对数据进行降维，去除冗余和不重要的特征。</li></ul></li></ul><h4 id="考点5：如何提高KNN的效率？"><a href="#考点5：如何提高KNN的效率？" class="headerlink" title="考点5：如何提高KNN的效率？"></a><strong>考点5：如何提高KNN的效率？</strong></h4><ul><li><strong>问题根源：</strong> KNN的瓶颈在于预测时需要进行大量的距离计算（暴力搜索）。</li><li><strong>解决方案：</strong> 使用<strong>空间索引数据结构</strong>来加速近邻搜索，避免全局扫描。<ul><li><strong>KD-Tree (K-Dimensional Tree):</strong> 这是一种对K维空间中的点进行划分的数据结构。它通过在不同维度上轮流切分数据空间，构建一个二叉树。在搜索时，可以快速剪枝掉那些不可能包含最近邻居的子空间，从而大大减少距离计算的次数。它在<strong>低维</strong>（例如d &lt; 20）时效率很高。</li><li><strong>Ball-Tree:</strong> 当维度非常高时，KD-Tree的效率会下降。Ball-Tree通过将数据点划分在一系列嵌套的超球体（Hypersphere）中来构建树。它对高维数据更具鲁棒性。</li></ul></li></ul><h4 id="考点6：KNN-和-K-Means-有什么区别？"><a href="#考点6：KNN-和-K-Means-有什么区别？" class="headerlink" title="考点6：KNN 和 K-Means 有什么区别？"></a><strong>考点6：KNN 和 K-Means 有什么区别？</strong></h4><table><thead><tr><th align="left">特性</th><th align="left">KNN (K-近邻)</th><th align="left">K-Means (K-均值)</th></tr></thead><tbody><tr><td align="left"><strong>算法类别</strong></td><td align="left"><strong>监督学习</strong> (Supervised Learning)</td><td align="left"><strong>无监督学习</strong> (Unsupervised Learning)</td></tr><tr><td align="left"><strong>解决问题</strong></td><td align="left"><strong>分类</strong> 或 <strong>回归</strong></td><td align="left"><strong>聚类</strong> (Clustering)</td></tr><tr><td align="left"><strong>数据要求</strong></td><td align="left">需要带<strong>标签</strong>的训练数据</td><td align="left">只需要数据点，<strong>无需标签</strong></td></tr><tr><td align="left"><strong>核心思想</strong></td><td align="left">基于邻居投票&#x2F;平均来预测新样本</td><td align="left">找到K个簇中心，使数据点到其所属簇中心的距离之和最小</td></tr><tr><td align="left"><strong>“K”的含义</strong></td><td align="left">邻居的数量（超参数）</td><td align="left">簇的数量（超参数）</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python中的sort方法、sorted函数与lambda表达式</title>
      <link href="/2025/07/02/Python%E4%B8%AD%E7%9A%84sort%E6%96%B9%E6%B3%95%E3%80%81sorted%E5%87%BD%E6%95%B0%E4%B8%8Elambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2025/07/02/Python%E4%B8%AD%E7%9A%84sort%E6%96%B9%E6%B3%95%E3%80%81sorted%E5%87%BD%E6%95%B0%E4%B8%8Elambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="1-sort-方法"><a href="#1-sort-方法" class="headerlink" title="1. sort()方法"></a>1. sort()方法</h1><h2 id="1-1-sort-方法"><a href="#1-1-sort-方法" class="headerlink" title="1.1 sort()方法"></a>1.1 sort()方法</h2><p>list.sort()最核心、也最需要记住的特点是：<strong>它会直接修改原始列表</strong>，使其变为有序状态。也就是原地排序。因此，<strong>sort()方法的返回值是None</strong>。部分初学者可能会将其结果赋值给新变量，这种用法是错误的。正确的用法是无需将其结果赋值给新变量，直接使用被修改后的原列表即可，如下所示：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nums = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">2</span>]</span><br><span class="line">nums.sort()</span><br><span class="line"><span class="built_in">print</span>(nums)</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure><h2 id="1-2-基本语法和参数"><a href="#1-2-基本语法和参数" class="headerlink" title="1.2 基本语法和参数"></a>1.2 基本语法和参数</h2><p>sort()方法的完整语法是：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>.sort(*, key=<span class="literal">None</span>, reverse=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p>它接受两个可自选的关键字参数：key和reverse。</p><h3 id="A-reverse参数"><a href="#A-reverse参数" class="headerlink" title="A. reverse参数"></a>A. reverse参数</h3><p>这个参数非常直观</p><ul><li>reverse &#x3D; False（默认值）：升序排序</li><li>reverse &#x3D; True：降序排序</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">numbers = [<span class="number">4</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">6</span>]</span><br><span class="line">numbers.sort() <span class="comment"># 默认升序</span></span><br><span class="line"><span class="built_in">print</span>(numbers) <span class="comment"># 输出: [1, 2, 4, 6, 8]</span></span><br><span class="line"></span><br><span class="line">numbers.sort(reverse=<span class="literal">True</span>) <span class="comment"># 降序</span></span><br><span class="line"><span class="built_in">print</span>(numbers) <span class="comment"># 输出: [8, 6, 4, 2, 1]</span></span><br></pre></td></tr></table></figure><h3 id="B-key参数"><a href="#B-key参数" class="headerlink" title="B. key参数"></a>B. key参数</h3><p>key参数是sort()方法最强大的功能。它允许你<strong>自定义排序的逻辑</strong>。<br>key接受一个函数（通常是lambda匿名函数）。在排序比较之前，列表中的每个元素都会先经过这个key函数处理，<strong>然后Python会根据这个函数的返回值来进行排序</strong>。</p><h4 id="示例1：按字符串长度排序："><a href="#示例1：按字符串长度排序：" class="headerlink" title="示例1：按字符串长度排序："></a>示例1：按字符串长度排序：</h4><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">words = [<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;kiwi&quot;</span>, <span class="string">&quot;cherry&quot;</span>]</span><br><span class="line"><span class="comment"># key=len 意味着对每个单词应用 len() 函数，然后按长度排序</span></span><br><span class="line">words.sort(key=<span class="built_in">len</span>)</span><br><span class="line"><span class="built_in">print</span>(words) <span class="comment"># 输出: [&#x27;kiwi&#x27;, &#x27;apple&#x27;, &#x27;banana&#x27;, &#x27;cherry&#x27;]</span></span><br></pre></td></tr></table></figure><h4 id="示例2：忽略大小写排序："><a href="#示例2：忽略大小写排序：" class="headerlink" title="示例2：忽略大小写排序："></a>示例2：忽略大小写排序：</h4><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">names = [<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;alice&quot;</span>, <span class="string">&quot;Charlie&quot;</span>, <span class="string">&quot;david&quot;</span>]</span><br><span class="line">names.sort()</span><br><span class="line"><span class="built_in">print</span>(names) <span class="comment"># 输出: [&#x27;Bob&#x27;, &#x27;Charlie&#x27;, &#x27;alice&#x27;, &#x27;david&#x27;] (默认排序)</span></span><br><span class="line"></span><br><span class="line">names.sort(key=<span class="built_in">str</span>.lower)</span><br><span class="line"><span class="built_in">print</span>(names) <span class="comment"># 输出: [&#x27;alice&#x27;, &#x27;Bob&#x27;, &#x27;Charlie&#x27;, &#x27;david&#x27;] (忽略大小写)</span></span><br></pre></td></tr></table></figure><h4 id="示例3：按对象的属性排序（非常常用）："><a href="#示例3：按对象的属性排序（非常常用）：" class="headerlink" title="示例3：按对象的属性排序（非常常用）："></a>示例3：按对象的属性排序（非常常用）：</h4><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">people = [</span><br><span class="line">    &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Alice&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">30</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">25</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Charlie&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">35</span>&#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 lambda 函数提取 &#x27;age&#x27; 的值作为排序的 key</span></span><br><span class="line">people.sort(key=<span class="keyword">lambda</span> person: person[<span class="string">&#x27;age&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(people)</span><br><span class="line"><span class="comment"># 输出:</span></span><br><span class="line"><span class="comment"># [&#123;&#x27;name&#x27;: &#x27;Bob&#x27;, &#x27;age&#x27;: 25&#125;, &#123;&#x27;name&#x27;: &#x27;Alice&#x27;, &#x27;age&#x27;: 30&#125;, &#123;&#x27;name&#x27;: &#x27;Charlie&#x27;, &#x27;age&#x27;: 35&#125;]</span></span><br></pre></td></tr></table></figure><p>当然也可以同时使用key和reverse：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 按年龄降序排序</span></span><br><span class="line">people.sort(key=<span class="keyword">lambda</span> person: person[<span class="string">&#x27;age&#x27;</span>], reverse=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(people)</span><br><span class="line"><span class="comment"># 输出:</span></span><br><span class="line"><span class="comment"># [&#123;&#x27;name&#x27;: &#x27;Charlie&#x27;, &#x27;age&#x27;: 35&#125;, &#123;&#x27;name&#x27;: &#x27;Alice&#x27;, &#x27;age&#x27;: 30&#125;, &#123;&#x27;name&#x27;: &#x27;Bob&#x27;, &#x27;age&#x27;: 25&#125;]</span></span><br></pre></td></tr></table></figure><h1 id="2-sorted-函数"><a href="#2-sorted-函数" class="headerlink" title="2. sorted()函数"></a>2. sorted()函数</h1><p>Python还提供了一个内置函数sorted()，它也用于排序。理解它们的区别至关重要。</p><table><thead><tr><th align="center"></th><th align="center">list.sort()</th><th align="center">sorted()</th></tr></thead><tbody><tr><td align="center">类型</td><td align="center">列表的方法（method）</td><td align="center">内置函数（function）</td></tr><tr><td align="center">使用对象</td><td align="center">只能用于列表（list）</td><td align="center">可以用于任何可迭代对象（list, tuple, str, dict, etc.）</td></tr><tr><td align="center">修改</td><td align="center">原地修改</td><td align="center">不能修改原始对象，通常赋值给一个新的变量</td></tr><tr><td align="center">返回值</td><td align="center">None</td><td align="center">返回一个新的、已排序的列表</td></tr></tbody></table><h2 id="2-1-代码对比"><a href="#2-1-代码对比" class="headerlink" title="2.1 代码对比"></a>2.1 代码对比</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 list.sort()</span></span><br><span class="line">original_list = [<span class="number">5</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">original_list.sort() <span class="comment"># 直接修改 original_list</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Original list after sort(): <span class="subst">&#123;original_list&#125;</span>&quot;</span>) <span class="comment"># 输出: [2, 3, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 sorted()</span></span><br><span class="line">original_tuple = (<span class="number">5</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">new_list = <span class="built_in">sorted</span>(original_tuple) <span class="comment"># 不会修改 original_tuple，而是返回新列表</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Original tuple: <span class="subst">&#123;original_tuple&#125;</span>&quot;</span>) <span class="comment"># 输出: (5, 2, 3)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;New list from sorted(): <span class="subst">&#123;new_list&#125;</span>&quot;</span>) <span class="comment"># 输出: [2, 3, 5]</span></span><br></pre></td></tr></table></figure><h1 id="3-lambda函数"><a href="#3-lambda函数" class="headerlink" title="3. lambda函数"></a>3. lambda函数</h1><p>一个lambda函数是一个小型的、匿名的、单行表达式函数。</p><h2 id="3-1-基本语法"><a href="#3-1-基本语法" class="headerlink" title="3.1 基本语法"></a>3.1 基本语法</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lambda</span> arguments: expression</span><br></pre></td></tr></table></figure><ul><li>lambda：关键字，表示你正在定义一个lambda函数。</li><li>arguments：和普通函数的参数一样，可以有零个或多个，用逗号分割，也就是<strong>形参</strong>。</li><li>expression：一个单独的表达式。计算这个表达式的结果，并作为函数的<strong>返回值</strong>。</li></ul><h2 id="3-2-lambda函数与普通函数的对比"><a href="#3-2-lambda函数与普通函数的对比" class="headerlink" title="3.2 lambda函数与普通函数的对比"></a>3.2 lambda函数与普通函数的对比</h2><p>A. 使用def（普通函数）</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">x, y</span>):</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line">result = add(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(result) <span class="comment"># 输出: 5</span></span><br></pre></td></tr></table></figure><p>B. 使用lambda（匿名函数）</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add_lambda = <span class="keyword">lambda</span> x, y: x + y</span><br><span class="line"></span><br><span class="line">result = add_lambda(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(result) <span class="comment"># 输出: 5</span></span><br></pre></td></tr></table></figure><h2 id="3-3-lambda表达式的用法"><a href="#3-3-lambda表达式的用法" class="headerlink" title="3.3 lambda表达式的用法"></a>3.3 lambda表达式的用法</h2><p>lambda的主要用途是作为高阶函数的参数，</p><h3 id="示例1：sorted函数和sort方法自定义排序规则"><a href="#示例1：sorted函数和sort方法自定义排序规则" class="headerlink" title="示例1：sorted函数和sort方法自定义排序规则"></a>示例1：sorted函数和sort方法自定义排序规则</h3><p>这是lambda最经典、最常见的用途。sorted函数和sort方法有一个key参数，你可以提供一个函数，sorted函数和sort方法会根据这个函数的返回值对元素进行排序。假设有一个元组列表，每个元组代表 (商品, 价格)。我们想<strong>按价格排序</strong>。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">items = [(<span class="string">&#x27;apple&#x27;</span>, <span class="number">2.5</span>), (<span class="string">&#x27;banana&#x27;</span>, <span class="number">1.8</span>), (<span class="string">&#x27;cherry&#x27;</span>, <span class="number">3.0</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 def 的繁琐方式</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_price</span>(<span class="params">item</span>):</span><br><span class="line">  <span class="keyword">return</span> item[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">sorted_items = <span class="built_in">sorted</span>(items, key=get_price)</span><br><span class="line"><span class="built_in">print</span>(sorted_items)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 lambda 的简洁方式</span></span><br><span class="line">sorted_items_lambda = <span class="built_in">sorted</span>(items, key=<span class="keyword">lambda</span> item: item[<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(sorted_items_lambda)</span><br><span class="line"><span class="comment"># 输出都是：</span></span><br><span class="line"><span class="comment"># [(&#x27;banana&#x27;, 1.8), (&#x27;apple&#x27;, 2.5), (&#x27;cherry&#x27;, 3.0)]</span></span><br></pre></td></tr></table></figure><p><code>key=lambda item: item[1]</code>创建了一个临时的、无需命名的函数，它接受一个item（元组），也就是items中的一个元素，并返回该元组的第二个元素（价格）。<br>其原理如下：</p><ul><li>sorted()函数开始工作，它拿到了<code>items</code>列表。</li><li>它需要对列表中的元素进行比较排序。它看到了<code>key=lambda item: item[1]</code>这个规则。</li><li>它取出第一个元素 <code>(&#39;apple&#39;, 2.5)</code>。</li><li>它将这个元素传递给<code>lambda</code>函数，即<code>item</code>参数现在是 <code>(&#39;apple&#39;, 2.5)</code>。</li><li>lambda函数执行它的表达式<code>item[1]</code>，返回的结果是2.5。sorted()函数在内部记下：<code>(&#39;apple&#39;, 2.5)</code>的排序值为2.5。</li><li>接着，它取出第二个元素<code>(&#39;banana&#39;, 1.8)</code>。</li><li>它将这个元素传递给lambda函数，<code>item</code>变成了<code>(&#39;banana&#39;, 1.8)</code>。</li><li>lambda函数执行<code>item[1]</code>，返回1.8。sorted()记下：<code>(&#39;banana&#39;, 1.8)</code>的排序值为1.8”。</li><li>它取出第三个元素<code>(&#39;cherry&#39;, 3.0)</code>，同样地，通过lambda函数得到它的排序值为3.0。</li><li>最后，<code>sorted()</code>根据这些排序值<code>[2.5, 1.8, 3.0]</code>来对原始的<code>items</code>列表进行排序。1.8最小，2.5其次，3.0最大。</li><li>所以，最终返回的排序结果是：<code>[(&#39;banana&#39;, 1.8), (&#39;apple&#39;, 2.5), (&#39;cherry&#39;, 3.0)]</code>。</li></ul><p>上面的例子是对价格进行升序排列，如果要进行<strong>降序排列</strong>可以这样写：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">items = [(<span class="string">&#x27;apple&#x27;</span>, <span class="number">2.5</span>), (<span class="string">&#x27;banana&#x27;</span>, <span class="number">1.8</span>), (<span class="string">&#x27;cherry&#x27;</span>, <span class="number">3.0</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 lambda 的简洁方式</span></span><br><span class="line"><span class="comment"># 该技巧仅适用于数值类型，其他类型，例如字符可能需要进行多次排序</span></span><br><span class="line">sorted_items_lambda = <span class="built_in">sorted</span>(items, key=<span class="keyword">lambda</span> item: -item[<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(sorted_items_lambda)</span><br><span class="line"><span class="comment"># 输出是：</span></span><br><span class="line"><span class="comment"># [(&#x27;cherry&#x27;, 3.0), (&#x27;apple&#x27;, 2.5), (&#x27;banana&#x27;, 1.8)]</span></span><br></pre></td></tr></table></figure><p>如果要进行<strong>多级排序</strong>，可以这样写：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列表中元组中元素的含义分别为名称、价格、重量</span></span><br><span class="line">data = [</span><br><span class="line">    (<span class="string">&#x27;Cherry&#x27;</span>, <span class="number">20</span>, <span class="number">100</span>),</span><br><span class="line">    (<span class="string">&#x27;Apple&#x27;</span>, <span class="number">20</span>, <span class="number">150</span>),</span><br><span class="line">    (<span class="string">&#x27;Banana&#x27;</span>, <span class="number">30</span>, <span class="number">120</span>),</span><br><span class="line">    (<span class="string">&#x27;Date&#x27;</span>, <span class="number">10</span>, <span class="number">500</span>),</span><br><span class="line">    (<span class="string">&#x27;Blueberry&#x27;</span>, <span class="number">20</span>, <span class="number">100</span>)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 lambda 返回一个元组作为排序的 key</span></span><br><span class="line"><span class="comment"># (item[1], item[2], item[0]) -&gt; (价格, 重量, 名称)</span></span><br><span class="line"><span class="comment"># 先按照价格排序，价格相同的情况下按照重量排序，价格和重量都相同的情况下按照名称进行排序</span></span><br><span class="line">sorted_data = <span class="built_in">sorted</span>(data, key=<span class="keyword">lambda</span> item: (item[<span class="number">1</span>], item[<span class="number">2</span>], item[<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(sorted_data)</span><br><span class="line"><span class="comment"># 输出结果为：</span></span><br><span class="line">[(<span class="string">&#x27;Date&#x27;</span>, <span class="number">10</span>, <span class="number">500</span>), (<span class="string">&#x27;Blueberry&#x27;</span>, <span class="number">20</span>, <span class="number">100</span>), (<span class="string">&#x27;Cherry&#x27;</span>, <span class="number">20</span>, <span class="number">100</span>), (<span class="string">&#x27;Apple&#x27;</span>, <span class="number">20</span>, <span class="number">150</span>), (<span class="string">&#x27;Banana&#x27;</span>, <span class="number">30</span>, <span class="number">120</span>)]</span><br></pre></td></tr></table></figure><h3 id="示例2：map-——对序列中的每个元素应用函数"><a href="#示例2：map-——对序列中的每个元素应用函数" class="headerlink" title="示例2：map()——对序列中的每个元素应用函数"></a>示例2：map()——对序列中的每个元素应用函数</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 lambda</span></span><br><span class="line">squared_numbers = <span class="built_in">map</span>(<span class="keyword">lambda</span> x: x * x, numbers)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(squared_numbers)) <span class="comment"># 输出: [1, 4, 9, 16, 25]</span></span><br></pre></td></tr></table></figure><h3 id="示例3：filter-——筛选序列中的元素"><a href="#示例3：filter-——筛选序列中的元素" class="headerlink" title="示例3：filter()——筛选序列中的元素"></a>示例3：filter()——筛选序列中的元素</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从序列中筛选出所有的偶数</span></span><br><span class="line">numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 lambda</span></span><br><span class="line">even_numbers = <span class="built_in">filter</span>(<span class="keyword">lambda</span> x: x % <span class="number">2</span> == <span class="number">0</span>, numbers)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(even_numbers)) <span class="comment"># 输出: [2, 4, 6, 8]</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回溯</title>
      <link href="/2025/05/29/%E5%9B%9E%E6%BA%AF/"/>
      <url>/2025/05/29/%E5%9B%9E%E6%BA%AF/</url>
      
        <content type="html"><![CDATA[<p>回溯算法（backtracking algorithm）是一种通过穷举来解决问题的办法，其<strong>本质是一种暴力搜索算法</strong>。它的<strong>核心思想是从一个初始状态出发，暴力搜索所有可能遇到的解决方案，当遇到正确的解则将其记录，直到找到解或尝试了所有可能的选择都无法找到解为止。</strong></p><h1 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h1><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">state: State, choices: <span class="built_in">list</span>[choice], res: <span class="built_in">list</span>[state]</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;回溯算法框架&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 判断是否为解</span></span><br><span class="line">    <span class="keyword">if</span> is_solution(state):</span><br><span class="line">        <span class="comment"># 记录解</span></span><br><span class="line">        record_solution(state, res)</span><br><span class="line">        <span class="comment"># 不再继续搜索</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># 遍历所有选择</span></span><br><span class="line">    <span class="keyword">for</span> choice <span class="keyword">in</span> choices:</span><br><span class="line">        <span class="comment"># 剪枝：判断选择是否合法</span></span><br><span class="line">        <span class="keyword">if</span> is_valid(state, choice):</span><br><span class="line">            <span class="comment"># 尝试：做出选择，更新状态</span></span><br><span class="line">            make_choice(state, choice)</span><br><span class="line">            backtrack(state, choices, res)</span><br><span class="line">            <span class="comment"># 回退：撤销选择，恢复到之前的状态</span></span><br><span class="line">            undo_choice(state, choice)</span><br></pre></td></tr></table></figure><p>也可以简易描述为下面的框架：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">backtracking</span>(<span class="params">参数</span>):</span><br><span class="line">    <span class="keyword">if</span> 终止条件:</span><br><span class="line">        存放结果</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> 当前节点下的所有选择:</span><br><span class="line">        处理节点，即做出该选择后更新后的状态，也就是更新路径</span><br><span class="line">        backtracking(参数)</span><br><span class="line">        回溯，撤销选择，恢复到之前的状态</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python学习笔记7—集合</title>
      <link href="/2025/03/21/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B07%E2%80%94%E9%9B%86%E5%90%88/"/>
      <url>/2025/03/21/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B07%E2%80%94%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h1 id="1-集合的创建"><a href="#1-集合的创建" class="headerlink" title="1. 集合的创建"></a>1. 集合的创建</h1><p>在前面几期已经介绍过了python中列表[]、元组()和字典{}的创建和使用，这一期要介绍的是另一个相似的结构，也就是哈希集合set()，和python中的哈希表也就是字典相似，集合set()也是用大括号{}来表示的，它可以用下面的方式进行初始化：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">nums = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(nums)</span><br><span class="line"></span><br><span class="line">nums = <span class="built_in">set</span>()</span><br><span class="line">nums.add(<span class="number">1</span>)</span><br><span class="line">nums.add(<span class="number">2</span>)</span><br><span class="line">nums.add(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(nums)</span><br><span class="line"></span><br><span class="line">nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">num_set = <span class="built_in">set</span>(nums)</span><br><span class="line"><span class="built_in">print</span>(num_set)</span><br></pre></td></tr></table></figure><p>上述三种方式打印的结果都是相同的，如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure><p>值得注意的是，虽然集合和字典都用{}来表示，但是集合的初始化不能使用<code>num_set = {}</code>这种方式，因为这种方式只会创建出一个字典。</p><h1 id="2-集合的特性"><a href="#2-集合的特性" class="headerlink" title="2. 集合的特性"></a>2. 集合的特性</h1><h2 id="2-1-集合是无序、无法进行索引的、元素不重复的"><a href="#2-1-集合是无序、无法进行索引的、元素不重复的" class="headerlink" title="2.1 集合是无序、无法进行索引的、元素不重复的"></a>2.1 集合是无序、无法进行索引的、元素不重复的</h2><p>除此之外，<strong>集合中的元素是无序的，因此集合中的元素也无法像列表一样能够通过索引进行访问，集合中也不存在相同的元素，因此当你使用add方法向集合中添加两个相同的元素时，集合中只会保留一个</strong>，例如：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">num_set = <span class="built_in">set</span>()</span><br><span class="line">num_set.add(<span class="number">1</span>)</span><br><span class="line">num_set.add(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(num_set)</span><br></pre></td></tr></table></figure><p>此时的输出结果如下</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure><p>当我们对一个字符串使用set()函数时，python会将其每个独一无二的字符单独存进集合中，例如</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str_set = <span class="built_in">set</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(str_set)</span><br></pre></td></tr></table></figure><p>其输出结果如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;h&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><p>可以看到，’hello’中的两’l’最终只保留了一个，并且字符存放顺序也是乱序的，符合上述我们说的集合的特点。</p><h2 id="2-2-集合可快速进行成员检查（in操作）"><a href="#2-2-集合可快速进行成员检查（in操作）" class="headerlink" title="2.2 集合可快速进行成员检查（in操作）"></a>2.2 集合可快速进行成员检查（in操作）</h2><p>对于列表来说，进行成员检查的时间复杂度为$O(n)$，因为要逐个遍历字典中的每个元素知道找到目标元素，如<code>3 in [1, 2, 3]</code>这样的操作。<br>对于集合来说，由于集合是基于哈希表实现的，因此其进行成员检查的时间复杂度为$O(1)$，如<code>3 in {1, 2, 3}</code>这样的操作</p><h1 id="3-集合的运算"><a href="#3-集合的运算" class="headerlink" title="3. 集合的运算"></a>3. 集合的运算</h1><p>我们之前已经知道了列表的运算方式，对两个列表做加法运算的结果是将第二个列表直接拼接在第一个列表的后面，对一个列表使用符合’* n’并不是表示对其中的每个元素做乘法运算，乘上一个n，而是将该列表支付n - 1份拼接在原列表后面。列表运算中不存在减法运算。<br>而对于集合来说，两个集合之间的运算方式共有4中，分别是<code>- | &amp; ^</code>。</p><h2 id="3-1-集合的-运算"><a href="#3-1-集合的-运算" class="headerlink" title="3.1 集合的 - 运算"></a>3.1 集合的 - 运算</h2><p>两个集合的<code>-</code>运算表示若被减集合中存在减集合中的元素，则将该元素从被减集合中删除，其余元素不变。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">num_1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">num_2 = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">num = num_1 - num_2</span><br><span class="line"><span class="built_in">print</span>(num)</span><br></pre></td></tr></table></figure><p>输出结果为</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure><p>因为被减集合中存在与减集合中相同的元素3，因此将其删除，并输出最后的结果。</p><h2 id="3-2-集合的-｜-运算"><a href="#3-2-集合的-｜-运算" class="headerlink" title="3.2 集合的 ｜ 运算"></a>3.2 集合的 ｜ 运算</h2><p>两个集合的<code>|</code>运算表示将两个集合做并集。注意集合运算中不存在<code>+</code>运算。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">num_1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">num_2 = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">num = num_1 | num_2</span><br><span class="line"><span class="built_in">print</span>(num)</span><br></pre></td></tr></table></figure><p>输出结果为</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="3-3-集合的-运算"><a href="#3-3-集合的-运算" class="headerlink" title="3.3 集合的 &amp; 运算"></a>3.3 集合的 &amp; 运算</h2><p>两个集合的<code>&amp;</code>运算即对两个集合做交集。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">num_1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">num_2 = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">num = num_1 &amp; num_2</span><br><span class="line"><span class="built_in">print</span>(num)</span><br></pre></td></tr></table></figure><p>输出结果为</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="3-4-集合的-运算"><a href="#3-4-集合的-运算" class="headerlink" title="3.4 集合的 ^ 运算"></a>3.4 集合的 ^ 运算</h2><p>两个集合的<code>^</code>运算表示对两个集合做反交集。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">num_1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">num_2 = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">num = num_1 ^ num_2</span><br><span class="line"><span class="built_in">print</span>(num)</span><br></pre></td></tr></table></figure><p>输出结果为</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure><h1 id="4-集合的增、删"><a href="#4-集合的增、删" class="headerlink" title="4. 集合的增、删"></a>4. 集合的增、删</h1><h1 id="4-1-在集合中添加元素（add-方法、update-方法）"><a href="#4-1-在集合中添加元素（add-方法、update-方法）" class="headerlink" title="4.1 在集合中添加元素（add()方法、update()方法）"></a>4.1 在集合中添加元素（add()方法、update()方法）</h1><p>使用方法add()可以向集合中添加元素，当添加的元素在集合中已经存在时，则不执行任何操作。使用方法update时需要传入的参数是一个集合，update会将该集合中不同的元素更新进原来的集合。换句话说，方法add()用于更新单个元素，方法update()用于更新集合表示的多个元素，当要用方法update更新单个元素时，要将该元素写成集合的形式，否则会报错。具体操作如下所示：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">num_1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">num_2 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">num_3 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">num_4 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line">num_1.add(<span class="number">4</span>)</span><br><span class="line">num_2.add(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">num_3.update(&#123;<span class="number">5</span>&#125;)</span><br><span class="line">num_4.update(num_3)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(num_1)</span><br><span class="line"><span class="built_in">print</span>(num_2)</span><br><span class="line"><span class="built_in">print</span>(num_3)</span><br><span class="line"><span class="built_in">print</span>(num_4)</span><br></pre></td></tr></table></figure><p>此时输出的结果为</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure><p>可以看到，通过方法add()集合<code>num_1</code>中添加了一个不重复的元素<code>4</code>，而集合<code>num_2</code>中的元素则没有发生变化。通过方法update()向集合<code>num_4</code>添加单个元素<code>5</code>时需要写成<code>{5}</code>，另一方面，当用update()方法将集合<code>num_3</code>更新进<code>num_4</code>时，仅仅更新了新的元素<code>5</code>。</p><h1 id="4-2-在集合中删除元素（remove-方法、pop-方法、discard-方法）"><a href="#4-2-在集合中删除元素（remove-方法、pop-方法、discard-方法）" class="headerlink" title="4.2 在集合中删除元素（remove()方法、pop()方法、discard()方法）"></a>4.2 在集合中删除元素（remove()方法、pop()方法、discard()方法）</h1><p>使用方法remove()可以移除集合中的指定元素，使用方法pop()则随机移除集合中的一个元素。如下所示：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">num_1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">num_2 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line">num_1.remove(<span class="number">1</span>)</span><br><span class="line">pop_num = num_2.pop()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(num_1)</span><br><span class="line"><span class="built_in">print</span>(num_2)</span><br><span class="line"><span class="built_in">print</span>(pop_num)</span><br></pre></td></tr></table></figure><p>此时的输出结果为</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">&#123;<span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>使用pop()方法后会放回弹出的元素，而remove()则不会。值得注意的是，当使用remove()方法移除一个集合中不存在的元素会会报错，同样的，当对一个为空的集合使用remove()方法后也会报错。此时可以考虑使用discard()方法，discard()方法的使用与remove()相似，只是当使用discard()方法删除集合中不存在的元素或对一个空集合执行discard()方法时，将不会执行任何操作，并且也不会报错。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法5—栈</title>
      <link href="/2025/01/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%955%E2%80%94%E6%A0%88/"/>
      <url>/2025/01/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%955%E2%80%94%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<p>栈（stack）是一种遵循<strong>先入后出</strong>逻辑的线性数据结构。</p><p>如图所示，我们将堆叠元素的顶部称为“栈顶”，底部称为“栈底”。将把元素添加到栈顶的操作叫做“入栈”，删除栈顶元素的操作叫做“出栈”。<br><img src="/img_1/01.png" alt="栈示意图"></p><h1 id="1-栈的常用操作"><a href="#1-栈的常用操作" class="headerlink" title="1. 栈的常用操作"></a>1. 栈的常用操作</h1><p>栈的常用操作如下表所示：</p><table><thead><tr><th align="center">方法</th><th align="center">描述</th><th align="center">时间复杂度</th></tr></thead><tbody><tr><td align="center">push()</td><td align="center">元素入栈（添加至栈顶）</td><td align="center">$O(1)$</td></tr><tr><td align="center">pop()</td><td align="center">栈顶元素出栈</td><td align="center">$O(1)$</td></tr><tr><td align="center">peek()</td><td align="center">访问栈顶元素</td><td align="center">$O(1)$</td></tr></tbody></table><p>通常情况下，一些编程语言内置了栈类。当没有提供栈类时，可以将该语言的“数组”或“链表”当作栈来使用，并在程序逻辑上忽略与栈无关的操作。C++具有栈类stack可以直接使用，而Python的列表也有能轻易实现栈操作的方法，因此下面以C为例实现栈。</p><h1 id="2-栈的实现"><a href="#2-栈的实现" class="headerlink" title="2. 栈的实现"></a>2. 栈的实现</h1><p>栈可以视为一种受限制的数组或链表，因为它只能在栈顶添加或删除元素。换句话说，我们可以通过屏蔽数组或链表的部分无关操作，使其对外表现的逻辑符合栈的特性。</p><h2 id="2-1-基于链表的实现"><a href="#2-1-基于链表的实现" class="headerlink" title="2.1 基于链表的实现"></a>2.1 基于链表的实现</h2><p>使用链表实现栈时，可以将链表的头节点视为栈顶，尾节点视为栈底。对于入栈操作，只需将元素插入链表头部，这种节点插入方法被称为“头插法”。而对于出栈操作，只需将头节点从链表中删除即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 基于链表实现的栈 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    ListNode *top; <span class="comment">// 将头节点作为栈顶</span></span><br><span class="line">    <span class="type">int</span> size;      <span class="comment">// 栈的长度</span></span><br><span class="line">&#125; LinkedListStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 构造函数 */</span></span><br><span class="line">LinkedListStack *<span class="title function_">newLinkedListStack</span><span class="params">()</span> &#123;</span><br><span class="line">    LinkedListStack *s = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkedListStack));</span><br><span class="line">    s-&gt;top = <span class="literal">NULL</span>;</span><br><span class="line">    s-&gt;size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 析构函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delLinkedListStack</span><span class="params">(LinkedListStack *s)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (s-&gt;top) &#123;</span><br><span class="line">        ListNode *n = s-&gt;top-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(s-&gt;top);</span><br><span class="line">        s-&gt;top = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取栈的长度 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">size</span><span class="params">(LinkedListStack *s)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s-&gt;size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 判断栈是否为空 */</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isEmpty</span><span class="params">(LinkedListStack *s)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> size(s) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 入栈 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(LinkedListStack *s, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">    ListNode *node = (ListNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ListNode));</span><br><span class="line">    node-&gt;next = s-&gt;top; <span class="comment">// 更新新加节点指针域</span></span><br><span class="line">    node-&gt;val = num;     <span class="comment">// 更新新加节点数据域</span></span><br><span class="line">    s-&gt;top = node;       <span class="comment">// 更新栈顶</span></span><br><span class="line">    s-&gt;size++;           <span class="comment">// 更新栈大小</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 访问栈顶元素 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">peek</span><span class="params">(LinkedListStack *s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s-&gt;size == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;栈为空\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> INT_MAX;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s-&gt;top-&gt;val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 出栈 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pop</span><span class="params">(LinkedListStack *s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> val = peek(s);</span><br><span class="line">    ListNode *tmp = s-&gt;top;</span><br><span class="line">    s-&gt;top = s-&gt;top-&gt;next;</span><br><span class="line">    <span class="comment">// 释放内存</span></span><br><span class="line">    <span class="built_in">free</span>(tmp);</span><br><span class="line">    s-&gt;size--;</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-基于数组的实现"><a href="#2-2-基于数组的实现" class="headerlink" title="2.2 基于数组的实现"></a>2.2 基于数组的实现</h2><p>在使用数组实现栈时，我们可以将数组的尾部视为栈顶。入栈与出栈操作分别对应在数组尾部添加元素与删除变量，时间复杂度都为$O(1)$。</p><p>由于入栈的元素可能会源源不断地增加，因此我们可以使用动态数组，这样就无需自行处理数组扩容问题。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 基于数组实现的栈 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> *data;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">&#125; ArrayStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 构造函数 */</span></span><br><span class="line">ArrayStack *<span class="title function_">newArrayStack</span><span class="params">()</span> &#123;</span><br><span class="line">    ArrayStack *<span class="built_in">stack</span> = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ArrayStack));</span><br><span class="line">    <span class="comment">// 初始化一个大容量，避免扩容</span></span><br><span class="line">    <span class="built_in">stack</span>-&gt;data = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * MAX_SIZE);</span><br><span class="line">    <span class="built_in">stack</span>-&gt;size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 析构函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delArrayStack</span><span class="params">(ArrayStack *<span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">stack</span>-&gt;data);</span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">stack</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取栈的长度 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">size</span><span class="params">(ArrayStack *<span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 判断栈是否为空 */</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isEmpty</span><span class="params">(ArrayStack *<span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 入栈 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(ArrayStack *<span class="built_in">stack</span>, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">stack</span>-&gt;size == MAX_SIZE) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;栈已满\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">stack</span>-&gt;data[<span class="built_in">stack</span>-&gt;size] = num;</span><br><span class="line">    <span class="built_in">stack</span>-&gt;size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 访问栈顶元素 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">peek</span><span class="params">(ArrayStack *<span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">stack</span>-&gt;size == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;栈为空\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> INT_MAX;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;data[<span class="built_in">stack</span>-&gt;size - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 出栈 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pop</span><span class="params">(ArrayStack *<span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> val = peek(<span class="built_in">stack</span>);</span><br><span class="line">    <span class="built_in">stack</span>-&gt;size--;</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-两种实现的对比"><a href="#3-两种实现的对比" class="headerlink" title="3. 两种实现的对比"></a>3. 两种实现的对比</h1><h2 id="3-1-时间效率"><a href="#3-1-时间效率" class="headerlink" title="3.1 时间效率"></a>3.1 时间效率</h2><p>在基于数组的实现中，<strong>入栈和出栈操作都在预先分配好的连续内存中进行，具有很好的缓存本地性</strong>，因此效率较高。然而，如果入栈时超出数组容量，会触发扩容机制，导致该次入栈操作的时间复杂度变为$O(n)$。</p><p>在基于链表的实现中，<strong>链表的扩容非常灵活，不存在上述数组扩容时效率降低的问题</strong>。但是，<strong>入栈操作需要初始化节点对象并修改指针，因此效率相对较低</strong>。不过，如果入栈元素本身就是节点对象，那么可以省去初始化步骤，从而提高效率。</p><p>综上所述，当入栈与出栈操作的元素是基本数据类型时，例如<code>int</code>或<code>double</code>，有如下结论：</p><ul><li>基于数组实现的栈在触发扩容时效率会降低，但由于扩容是低频操作，因此平均效率更高。</li><li>基于链表实现的栈可以提供更加稳定的效率表现。</li></ul><h2 id="3-2-空间效率"><a href="#3-2-空间效率" class="headerlink" title="3.2 空间效率"></a>3.2 空间效率</h2><p>在初始化列表时，系统会为列表分配“初始容量”，该容量可能超出实际需求；并且，扩容机制通常是按照特定倍率（例如2倍）进行扩容的，扩容后的容量也可能超出实际需求。因此，基于数组实现的栈可能造成一定的空间浪费。</p><p>然而，由于链表节点需要额外存储指针，因此链表节点占用的空间相对较大。故两者的空间效率仍需看情况讨论。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>[1] <a href="https://github.com/krahets/hello-algo" title="与时俱进、简介易懂的数据结构与算法教程">GitHub 开源项目《hello 算法》</a><br>[2] 程杰.大话数据结构【溢彩加强版】[M].清华大学出版社,2020.</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法4—列表</title>
      <link href="/2025/01/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%954%E2%80%94%E5%88%97%E8%A1%A8/"/>
      <url>/2025/01/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%954%E2%80%94%E5%88%97%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>列表（list）是一个抽象的数据结构概念，表示元素的有序集合，支持元素访问、修改、添加、删除和遍历等操作，<strong>无需使用者考虑容量限制的问题</strong>。列表可以基于链表或数组实现。</p><ul><li>链表天然可以看作一个列表，其支持元素增删改查操作，并且可以灵活动态扩容。</li><li>数组也支持元素增删改查，但由于其长度不可变，因此只能看作一个具有长度限制的列表。</li></ul><p>由于数组不具备扩展长度的能力，因此可以使用动态数组来实现列表。它继承了数组的各项优点，并且可以在程序运行过程中进行动态扩容。</p><p>许多编程语言中的标准库提供的列表是基于动态数组实现的，例如Python中的<code>list</code>、Java中的<code>ArrayList</code>、C++中的<code>vector</code>和C#中的<code>List</code>等。通常，将<strong>列表</strong>和<strong>动态数组</strong>视为等同的概念。</p><h1 id="1-列表常用操作"><a href="#1-列表常用操作" class="headerlink" title="1. 列表常用操作"></a>1. 列表常用操作</h1><h2 id="1-1-初始化列表"><a href="#1-1-初始化列表" class="headerlink" title="1.1 初始化列表"></a>1.1 初始化列表</h2><p>列表的初始化可以采用“无初始值”和“有初始值”这两种初始化方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 初始化列表 */</span></span><br><span class="line"><span class="comment">// 无初始值</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; nums1;</span><br><span class="line"><span class="comment">// 有初始值</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; nums = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span> &#125;;</span><br></pre></td></tr></table></figure><h2 id="1-2-访问元素"><a href="#1-2-访问元素" class="headerlink" title="1.2 访问元素"></a>1.2 访问元素</h2><p>列表本质上是数组，因此可以在$O(1)$时间内访问和更新元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 访问元素 */</span></span><br><span class="line"><span class="type">int</span> num = nums[<span class="number">1</span>];  <span class="comment">// 访问索引 1 处的元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 更新元素 */</span></span><br><span class="line">nums[<span class="number">1</span>] = <span class="number">0</span>;  <span class="comment">// 将索引 1 处的元素更新为 0</span></span><br></pre></td></tr></table></figure><h2 id="1-3-插入与删除元素"><a href="#1-3-插入与删除元素" class="headerlink" title="1.3 插入与删除元素"></a>1.3 插入与删除元素</h2><p>在列表末尾添加元素的时间复杂度为$O(1)$，但插入和删除元素的效率仍与数组相同，时间复杂度为$O(n)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 清空列表 */</span></span><br><span class="line">nums.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在尾部添加元素 */</span></span><br><span class="line">nums.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">nums.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">nums.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">nums.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">nums.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在中间插入元素 */</span></span><br><span class="line">nums.<span class="built_in">insert</span>(nums.<span class="built_in">begin</span>() + <span class="number">3</span>, <span class="number">6</span>);  <span class="comment">// 在索引 3 处插入数字 6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 删除元素 */</span></span><br><span class="line">nums.<span class="built_in">erase</span>(nums.<span class="built_in">begin</span>() + <span class="number">3</span>);      <span class="comment">// 删除索引 3 处的元素</span></span><br></pre></td></tr></table></figure><h2 id="1-4-遍历列表"><a href="#1-4-遍历列表" class="headerlink" title="1.4 遍历列表"></a>1.4 遍历列表</h2><p>与数组一样，列表可以根据索引遍历，也可以直接遍历各元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 通过索引遍历列表 */</span></span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    count += nums[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 直接遍历列表元素 */</span></span><br><span class="line">count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">    count += num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-5-拼接列表"><a href="#1-5-拼接列表" class="headerlink" title="1.5 拼接列表"></a>1.5 拼接列表</h2><p>给定一个新列表<code>nums1</code>，我们可以将其拼接到原列表的尾部。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 拼接两个列表 */</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; nums1 = &#123; <span class="number">6</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">10</span>, <span class="number">9</span> &#125;;</span><br><span class="line"><span class="comment">// 将列表 nums1 拼接到 nums 之后</span></span><br><span class="line">nums.<span class="built_in">insert</span>(nums.<span class="built_in">end</span>(), nums<span class="number">1.</span><span class="built_in">begin</span>(), nums<span class="number">1.</span><span class="built_in">end</span>());</span><br></pre></td></tr></table></figure><h2 id="1-6-排序列表"><a href="#1-6-排序列表" class="headerlink" title="1.6 排序列表"></a>1.6 排序列表</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 排序列表 */</span></span><br><span class="line"><span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());  <span class="comment">// 排序后，列表元素从小到大排列</span></span><br></pre></td></tr></table></figure><h1 id="2-简单列表的实现"><a href="#2-简单列表的实现" class="headerlink" title="2. 简单列表的实现"></a>2. 简单列表的实现</h1><p>由于Python和C++都内置了列表，直接使用内置的列表<code>list</code>和<code>vector</code>即可，因此下面仅提供C实现列表的方法。</p><p>列表的设计需要考虑下面三个因素：</p><ul><li><strong>初始容量</strong>：选取一个合理的数组初始容量。下面的示例中选择10作为初始容量。</li><li><strong>数量记录</strong>：声明一个变量<code>size</code>，用于记录列表当前元素数量，并随着元素插入和删除实时更新。根据此变量，我们可以定位列表尾部，以及判断是否需要扩容。</li><li><strong>扩容机制</strong>：若插入元素时列表容量已满，则需要进行扩容。<strong>先根据扩容倍数创建一个更大的数组，再将当前数组的所有元素依次移动至新数组</strong>。在下面的示例中，规定每次将数组扩容至之前的2倍。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 列表类 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> *arr;        <span class="comment">// 数组（存储列表元素）</span></span><br><span class="line">    <span class="type">int</span> capacity;    <span class="comment">// 列表容量</span></span><br><span class="line">    <span class="type">int</span> size;        <span class="comment">// 列表大小</span></span><br><span class="line">    <span class="type">int</span> extendRatio; <span class="comment">// 列表每次扩容的倍数</span></span><br><span class="line">&#125; MyList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 构造函数 */</span></span><br><span class="line">MyList *<span class="title function_">newMyList</span><span class="params">()</span> &#123;</span><br><span class="line">    MyList *nums = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(MyList));</span><br><span class="line">    nums-&gt;capacity = <span class="number">10</span>;</span><br><span class="line">    nums-&gt;arr = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * nums-&gt;capacity);</span><br><span class="line">    nums-&gt;size = <span class="number">0</span>;</span><br><span class="line">    nums-&gt;extendRatio = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 析构函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delMyList</span><span class="params">(MyList *nums)</span> &#123;</span><br><span class="line">    <span class="built_in">free</span>(nums-&gt;arr);</span><br><span class="line">    <span class="built_in">free</span>(nums);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取列表长度 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">size</span><span class="params">(MyList *nums)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> nums-&gt;size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取列表容量 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">capacity</span><span class="params">(MyList *nums)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> nums-&gt;capacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 访问元素 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">get</span><span class="params">(MyList *nums, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    assert(index &gt;= <span class="number">0</span> &amp;&amp; index &lt; nums-&gt;size);</span><br><span class="line">    <span class="keyword">return</span> nums-&gt;arr[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 更新元素 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">set</span><span class="params">(MyList *nums, <span class="type">int</span> index, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">    assert(index &gt;= <span class="number">0</span> &amp;&amp; index &lt; nums-&gt;size);</span><br><span class="line">    nums-&gt;arr[index] = num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在尾部添加元素 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(MyList *nums, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (size(nums) == capacity(nums)) &#123;</span><br><span class="line">        extendCapacity(nums); <span class="comment">// 扩容</span></span><br><span class="line">    &#125;</span><br><span class="line">    nums-&gt;arr[size(nums)] = num;</span><br><span class="line">    nums-&gt;size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在中间插入元素 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(MyList *nums, <span class="type">int</span> index, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">    assert(index &gt;= <span class="number">0</span> &amp;&amp; index &lt; size(nums));</span><br><span class="line">    <span class="comment">// 元素数量超出容量时，触发扩容机制</span></span><br><span class="line">    <span class="keyword">if</span> (size(nums) == capacity(nums)) &#123;</span><br><span class="line">        extendCapacity(nums); <span class="comment">// 扩容</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = size(nums); i &gt; index; --i) &#123;</span><br><span class="line">        nums-&gt;arr[i] = nums-&gt;arr[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    nums-&gt;arr[index] = num;</span><br><span class="line">    nums-&gt;size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 删除元素 */</span></span><br><span class="line"><span class="comment">// 注意：stdio.h 占用了 remove 关键词</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">removeItem</span><span class="params">(MyList *nums, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    assert(index &gt;= <span class="number">0</span> &amp;&amp; index &lt; size(nums));</span><br><span class="line">    <span class="type">int</span> num = nums-&gt;arr[index];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = index; i &lt; size(nums) - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        nums-&gt;arr[i] = nums-&gt;arr[i + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    nums-&gt;size--;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 列表扩容 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">extendCapacity</span><span class="params">(MyList *nums)</span> &#123;</span><br><span class="line">    <span class="comment">// 先分配空间</span></span><br><span class="line">    <span class="type">int</span> newCapacity = capacity(nums) * nums-&gt;extendRatio;</span><br><span class="line">    <span class="type">int</span> *extend = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * newCapacity);</span><br><span class="line">    <span class="type">int</span> *temp = nums-&gt;arr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝旧数据到新数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size(nums); i++)</span><br><span class="line">        extend[i] = nums-&gt;arr[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放旧数据</span></span><br><span class="line">    <span class="built_in">free</span>(temp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新新数据</span></span><br><span class="line">    nums-&gt;arr = extend;</span><br><span class="line">    nums-&gt;capacity = newCapacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将列表转换为 Array 用于打印 */</span></span><br><span class="line"><span class="type">int</span> *<span class="title function_">toArray</span><span class="params">(MyList *nums)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> nums-&gt;arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>[1] <a href="https://github.com/krahets/hello-algo" title="与时俱进、简介易懂的数据结构与算法教程">GitHub 开源项目《hello 算法》</a><br>[2] 程杰.大话数据结构【溢彩加强版】[M].清华大学出版社,2020.</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法3—链表</title>
      <link href="/2025/01/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%953%E2%80%94%E9%93%BE%E8%A1%A8/"/>
      <url>/2025/01/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%953%E2%80%94%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>内存空间是所有程序的公共资源，在一个复杂的系统运行环境下，空闲的内存空间可能散落在内存各处。我们知道，<strong>存储数组的内存空间必须是连续的</strong>，而当数组非常大时，内存可能无法提供如此大的连续空间。此时<strong>链表的灵活性</strong>优势就体现出来了。</p><p>链表是一种线性数据结构，其中的每个元素都是一个节点对象，各个节点通过“引用”或“指针”相连接。引用记录了下一个节点的内存地址，通过它可以从当前节点访问到下一个节点。</p><p>链表的设计使得各个节点可以分散存储在内存各处，<strong>它们的内存地址无须连续</strong>。</p><p>链表节点<code>ListNode</code>除了包含值，还需额外保存一个引用（指针）。因此<strong>在相同数据量下，链表比数组占用更多的内存空间</strong>。</p><h1 id="1-链表结构体"><a href="#1-链表结构体" class="headerlink" title="1. 链表结构体"></a>1. 链表结构体</h1><p>不同编程语言中的链表结构体如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 链表节点结构体 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> val;               <span class="comment">// 节点值</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">next</span>;</span> <span class="comment">// 指向下一节点的引用</span></span><br><span class="line">&#125; ListNode;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 链表节点 */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;链表节点类&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val: <span class="built_in">int</span></span>):</span><br><span class="line">        <span class="variable language_">self</span>.val: <span class="built_in">int</span> = val  <span class="comment"># 节点值</span></span><br><span class="line">        <span class="variable language_">self</span>.<span class="built_in">next</span>: ListNode | <span class="literal">None</span> = <span class="literal">None</span>  <span class="comment"># 后继节点引用</span></span><br></pre></td></tr></table></figure><h1 id="2-链表常用操作"><a href="#2-链表常用操作" class="headerlink" title="2. 链表常用操作"></a>2. 链表常用操作</h1><h2 id="2-1-初始化链表"><a href="#2-1-初始化链表" class="headerlink" title="2.1 初始化链表"></a>2.1 初始化链表</h2><p>建立链表分为两步，第一步是初始化各个节点对象，第二步是构建节点之间的引用关系。初始化完成后，我们就可以从链表的头节点出发，通过引用指向<code>next</code>依次访问所有节点。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 初始化链表 */</span></span><br><span class="line"><span class="comment">// 初始化各个节点</span></span><br><span class="line">ListNode *n0 = newListNode(<span class="number">1</span>);</span><br><span class="line">ListNode *n1 = newListNode(<span class="number">3</span>);</span><br><span class="line">ListNode *n2 = newListNode(<span class="number">2</span>);</span><br><span class="line">ListNode *n3 = newListNode(<span class="number">5</span>);</span><br><span class="line">ListNode *n4 = newListNode(<span class="number">4</span>);</span><br><span class="line"><span class="comment">// 构建节点之间的引用</span></span><br><span class="line">n0-&gt;next = n1;</span><br><span class="line">n1-&gt;next = n2;</span><br><span class="line">n2-&gt;next = n3;</span><br><span class="line">n3-&gt;next = n4;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;初始化的链表为\r\n&quot;</span>);</span><br><span class="line">printLinkedList(n0);</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 初始化链表 */</span></span><br><span class="line"><span class="comment">// 初始化各个节点</span></span><br><span class="line">ListNode *n0 = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">1</span>);</span><br><span class="line">ListNode *n1 = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">3</span>);</span><br><span class="line">ListNode *n2 = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">2</span>);</span><br><span class="line">ListNode *n3 = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">5</span>);</span><br><span class="line">ListNode *n4 = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">4</span>);</span><br><span class="line"><span class="comment">// 构建节点之间的引用</span></span><br><span class="line">n0-&gt;next = n1;</span><br><span class="line">n1-&gt;next = n2;</span><br><span class="line">n2-&gt;next = n3;</span><br><span class="line">n3-&gt;next = n4;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;初始化的链表为&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">printLinkedList</span>(n0);</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化链表</span></span><br><span class="line"><span class="comment"># 初始化各个节点</span></span><br><span class="line">n0 = ListNode(<span class="number">1</span>)</span><br><span class="line">n1 = ListNode(<span class="number">3</span>)</span><br><span class="line">n2 = ListNode(<span class="number">2</span>)</span><br><span class="line">n3 = ListNode(<span class="number">5</span>)</span><br><span class="line">n4 = ListNode(<span class="number">4</span>)</span><br><span class="line"><span class="comment"># 构建节点之间的引用</span></span><br><span class="line">n0.<span class="built_in">next</span> = n1</span><br><span class="line">n1.<span class="built_in">next</span> = n2</span><br><span class="line">n2.<span class="built_in">next</span> = n3</span><br><span class="line">n3.<span class="built_in">next</span> = n4</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;初始化的链表为&quot;</span>)</span><br><span class="line">print_linked_list(n0)</span><br></pre></td></tr></table></figure><p>链表是由多个独立的节点对象组成。<strong>通常将头节点当作链表的代称</strong>，比如以上代码中的链表可记作链表<code>n0</code>。</p><h2 id="2-2-插入节点"><a href="#2-2-插入节点" class="headerlink" title="2.2 插入节点"></a>2.2 插入节点</h2><p>在链表中插入节点只需改变两个节点引用（指针）即可，时间复杂度为$O(1)$，相比之下，数组由于要移动后续所有元素，所以在数组中插入节点的时间复杂度为$O(n)$。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 在链表的节点 n0 之后插入节点 P */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(ListNode *n0, ListNode *P)</span> &#123;</span><br><span class="line">    ListNode *n1 = n0-&gt;next;</span><br><span class="line">    P-&gt;next = n1;</span><br><span class="line">    n0-&gt;next = P;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 在链表的节点 n0 之后插入节点 P */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(ListNode *n0, ListNode *P)</span> </span>&#123;</span><br><span class="line">    ListNode *n1 = n0-&gt;next;</span><br><span class="line">    P-&gt;next = n1;</span><br><span class="line">    n0-&gt;next = P;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">n0: ListNode, P: ListNode</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;在链表的节点 n0 之后插入节点 P&quot;&quot;&quot;</span></span><br><span class="line">    n1 = n0.<span class="built_in">next</span></span><br><span class="line">    P.<span class="built_in">next</span> = n1</span><br><span class="line">    n0.<span class="built_in">next</span> = P</span><br></pre></td></tr></table></figure><h2 id="2-3-删除节点"><a href="#2-3-删除节点" class="headerlink" title="2.3 删除节点"></a>2.3 删除节点</h2><p>在链表中删除节点只需改变一个节点的引用（指针）即可。时间复杂度为$O(1)$，数组删除节点时同样需要移动后续元素，因此时间复杂度为$O(n)$。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 删除链表的节点 n0 之后的首个节点 */</span></span><br><span class="line"><span class="comment">// 注意：stdio.h 占用了 remove 关键词</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">removeItem</span><span class="params">(ListNode *n0)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!n0-&gt;next)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// n0 -&gt; P -&gt; n1</span></span><br><span class="line">    ListNode *P = n0-&gt;next;</span><br><span class="line">    ListNode *n1 = P-&gt;next;</span><br><span class="line">    n0-&gt;next = n1;</span><br><span class="line">    <span class="comment">// 释放内存</span></span><br><span class="line">    <span class="built_in">free</span>(P);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 删除链表的节点 n0 之后的首个节点 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(ListNode *n0)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n0-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// n0 -&gt; P -&gt; n1</span></span><br><span class="line">    ListNode *P = n0-&gt;next;</span><br><span class="line">    ListNode *n1 = P-&gt;next;</span><br><span class="line">    n0-&gt;next = n1;</span><br><span class="line">    <span class="comment">// 释放内存</span></span><br><span class="line">    <span class="keyword">delete</span> P;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">remove</span>(<span class="params">n0: ListNode</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;删除链表的节点 n0 之后的首个节点&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> n0.<span class="built_in">next</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># n0 -&gt; P -&gt; n1</span></span><br><span class="line">    P = n0.<span class="built_in">next</span></span><br><span class="line">    n1 = P.<span class="built_in">next</span></span><br><span class="line">    n0.<span class="built_in">next</span> = n1</span><br></pre></td></tr></table></figure><h2 id="2-4-访问节点"><a href="#2-4-访问节点" class="headerlink" title="2.4 访问节点"></a>2.4 访问节点</h2><p>在链表中访问节点需要从头节点出发，逐个向后遍历，直至找到目标节点，时间复杂度为$O(n)$，相比之下，数组访问节点所需的时间复杂度为$O(1)$。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 访问链表中索引为 index 的节点 */</span></span><br><span class="line">ListNode *<span class="title function_">access</span><span class="params">(ListNode *head, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 访问链表中索引为 index 的节点 */</span></span><br><span class="line"><span class="function">ListNode *<span class="title">access</span><span class="params">(ListNode *head, <span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">access</span>(<span class="params">head: ListNode, index: <span class="built_in">int</span></span>) -&gt; ListNode | <span class="literal">None</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;访问链表中索引为 index 的节点&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(index):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        head = head.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure><h2 id="2-5-查找节点"><a href="#2-5-查找节点" class="headerlink" title="2.5 查找节点"></a>2.5 查找节点</h2><p>即遍历链表，找到所需值，时间复杂度和数组相同，都为$O(n)$。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 在链表中查找值为 target 的首个节点 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">find</span><span class="params">(ListNode *head, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (head) &#123;</span><br><span class="line">        <span class="keyword">if</span> (head-&gt;val == target)</span><br><span class="line">            <span class="keyword">return</span> index;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 在链表中查找值为 target 的首个节点 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(ListNode *head, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (head-&gt;val == target)</span><br><span class="line">            <span class="keyword">return</span> index;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">head: ListNode, target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;在链表中查找值为 target 的首个节点&quot;&quot;&quot;</span></span><br><span class="line">    index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> head:</span><br><span class="line">        <span class="keyword">if</span> head.val == target:</span><br><span class="line">            <span class="keyword">return</span> index</span><br><span class="line">        head = head.<span class="built_in">next</span></span><br><span class="line">        index += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><h1 id="3-数组与链表的对比"><a href="#3-数组与链表的对比" class="headerlink" title="3. 数组与链表的对比"></a>3. 数组与链表的对比</h1><table><thead><tr><th align="center"></th><th align="center">数组</th><th align="center">链表</th></tr></thead><tbody><tr><td align="center">存储方式</td><td align="center">连续内存空间</td><td align="center">分散内存空间</td></tr><tr><td align="center">容量扩展</td><td align="center">长度不可变</td><td align="center">可灵活扩展</td></tr><tr><td align="center">内存效率</td><td align="center">元素占用内存少，但可能浪费空间</td><td align="center">元素占用内存多</td></tr><tr><td align="center">访问元素</td><td align="center">$O(1)$</td><td align="center">$O(n)$</td></tr><tr><td align="center">添加元素</td><td align="center">$O(n)$</td><td align="center">$O(1)$</td></tr><tr><td align="center">删除元素</td><td align="center">$O(n)$</td><td align="center">$O(1)$</td></tr></tbody></table><h1 id="4-常见链表类型"><a href="#4-常见链表类型" class="headerlink" title="4. 常见链表类型"></a>4. 常见链表类型</h1><ul><li><strong>单向链表</strong>：即上述介绍的链表。单向链表的节点包含值和指向下一节点的引用（指针）两项数据。我们将首个节点称为头节点，将最后一个节点称为尾节点，<strong>尾节点指向空</strong>。</li><li><strong>环形链表</strong>：将单向链表的尾节点指向头节点（首尾相接），则得到一个环形链表。<strong>在环形链表中，任意节点都可以视作头节点</strong>。</li><li><strong>双向链表</strong>：与单向链表相比，双向链表记录了两个方向的引用（指针）。双向链表的节点定义同时包含指向后续节点和前驱节点的引用（指针）。相较于单向链表，<strong>双向链表更具灵活性，可以朝两个方向遍历链表，但相应地也需要占用更多的内存空间</strong>。</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>[1] <a href="https://github.com/krahets/hello-algo" title="与时俱进、简介易懂的数据结构与算法教程">GitHub 开源项目《hello 算法》</a><br>[2] 程杰.大话数据结构【溢彩加强版】[M].清华大学出版社,2020.</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法2—数组</title>
      <link href="/2025/01/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%952%E2%80%94%E6%95%B0%E7%BB%84/"/>
      <url>/2025/01/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%952%E2%80%94%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<p>数组是一种常见的线性数据结构，其将相同类型的元素存储在连续的内存空间中，我们将元素在数组中的位置称为该元素的索引。</p><h1 id="1-数组的常用操作"><a href="#1-数组的常用操作" class="headerlink" title="1. 数组的常用操作"></a>1. 数组的常用操作</h1><h1 id="1-1-初始化数组"><a href="#1-1-初始化数组" class="headerlink" title="1.1 初始化数组"></a>1.1 初始化数组</h1><p>初始化数组时，我们可以根据需求选用数组的两种初始化方式：无初始值、给定初始值。在未指定初始值的情况下，大多数编程语言会将数组元素初始化为0，但是经过实测，<strong>C++和C在数组为初始化时，大多数情况下不会将数组初始化为0，特别是使用new或malloc创建动态数组时数组元素都是随机值，因此在C++和C中建议创建完数组后就立刻将其初始化</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 初始化数组arr */</span></span><br><span class="line"><span class="comment">// 将数组存储在栈上</span></span><br><span class="line"><span class="type">int</span> size = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;数组 arr = &quot;</span>);</span><br><span class="line">printArray(arr, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化数组nums */</span></span><br><span class="line"><span class="comment">// 将数组存储在栈上</span></span><br><span class="line"><span class="type">int</span> nums[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;数组 nums = &quot;</span>);</span><br><span class="line">printArray(nums, <span class="number">5</span>);</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 初始化数组arr */</span></span><br><span class="line"><span class="comment">// 将数组存储在堆上</span></span><br><span class="line"><span class="type">int</span> size = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> *arr = <span class="keyword">new</span> <span class="type">int</span>[size];</span><br><span class="line"><span class="built_in">fill_n</span>(arr, size, <span class="number">0</span>); <span class="comment">// 将数组 arr 的前 size 个元素初始化为 0</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;数组 arr = &quot;</span>;</span><br><span class="line"><span class="built_in">printArray</span>(arr, size);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化数组nums */</span></span><br><span class="line"><span class="comment">// 将数组存储在堆上</span></span><br><span class="line"><span class="type">int</span> *nums = <span class="keyword">new</span> <span class="type">int</span>[size]&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>&#125;;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;数组 nums = &quot;</span>;</span><br><span class="line"><span class="built_in">printArray</span>(nums, size);</span><br></pre></td></tr></table></figure><h2 id="1-2-访问数组元素"><a href="#1-2-访问数组元素" class="headerlink" title="1.2 访问数组元素"></a>1.2 访问数组元素</h2><p>数组元素被存储在<strong>连续的内存空间中</strong>，这意味着计算数组元素的内存地址非常容易。给定数组内存地址（首元素内存地址）和某个元素的索引，就能够直接访问该元素。</p><p>在数组中访问元素非常高效，我们<strong>可以在$O(1)$时间内随机访问数组中的任意一个元素</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 随机访问元素 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">randomAccess</span><span class="params">(<span class="type">int</span> *nums, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    <span class="comment">// 在区间 [0, size) 中随机抽取一个数字</span></span><br><span class="line">    <span class="type">int</span> randomIndex = rand() % size;</span><br><span class="line">    <span class="comment">// 获取并返回随机元素</span></span><br><span class="line">    <span class="type">int</span> randomNum = nums[randomIndex];</span><br><span class="line">    <span class="keyword">return</span> randomNum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 随机访问元素 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">randomAccess</span><span class="params">(<span class="type">int</span> *nums, <span class="type">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在区间 [0, size) 中随机抽取一个数字</span></span><br><span class="line">    <span class="type">int</span> randomIndex = <span class="built_in">rand</span>() % size;</span><br><span class="line">    <span class="comment">// 获取并返回随机元素</span></span><br><span class="line">    <span class="type">int</span> randomNum = nums[randomIndex];</span><br><span class="line">    <span class="keyword">return</span> randomNum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-3-插入元素"><a href="#1-3-插入元素" class="headerlink" title="1.3 插入元素"></a>1.3 插入元素</h2><p>数组元素在内存中是连续的，它们之间没有空间再存放任何数据。如果想在数组中间插入一个元素，则需要将该元素之后的所有元素都向后移动一位，之后再把元素赋值给该索引。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 在数组的索引 index 处插入元素 num */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> *nums, <span class="type">int</span> size, <span class="type">int</span> num, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="comment">// 把索引 index 以及之后的所有元素向后移动一位</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = size - <span class="number">1</span>; i &gt; index; i--) &#123;</span><br><span class="line">        nums[i] = nums[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将 num 赋给 index 处的元素</span></span><br><span class="line">    nums[index] = num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 在数组的索引 index 处插入元素 num */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> *nums, <span class="type">int</span> size, <span class="type">int</span> num, <span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 把索引 index 以及之后的所有元素向后移动一位</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = size - <span class="number">1</span>; i &gt; index; i--) &#123;</span><br><span class="line">        nums[i] = nums[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将 num 赋给 index 处的元素</span></span><br><span class="line">    nums[index] = num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-4-删除元素"><a href="#1-4-删除元素" class="headerlink" title="1.4 删除元素"></a>1.4 删除元素</h2><p>同理，若想删除索引 $i$ 处的元素，则需要把索引 $i$ 之后的元素都向前移动一位。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 删除索引 index 处的元素 */</span></span><br><span class="line"><span class="comment">// 注意：stdio.h 占用了 remove 关键词</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">removeItem</span><span class="params">(<span class="type">int</span> *nums, <span class="type">int</span> size, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="comment">// 把索引 index 之后的所有元素向前移动一位</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = index; i &lt; size - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        nums[i] = nums[i + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 删除索引 index 处的元素 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> *nums, <span class="type">int</span> size, <span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 把索引 index 之后的所有元素向前移动一位</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = index; i &lt; size - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        nums[i] = nums[i + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总的来看，数组的插入和删除操作有以下缺点：</p><ul><li><strong>时间复杂度高</strong>：数组的插入和删除的平均时间复杂度均为$O(n)$，其中n为数组长度。</li><li><strong>丢失元素</strong>：由于数组的长度不可变，因此在插入元素后，超出数组长度范围的元素会丢失。</li><li><strong>内存浪费</strong>：我们可以初始化一个比较长的数组，只用前面一部分，这样在插入数据时，丢失的末尾元素都是无意义的，但这样做会造成部分内存空间浪费。</li></ul><h2 id="1-5-遍历数组"><a href="#1-5-遍历数组" class="headerlink" title="1.5 遍历数组"></a>1.5 遍历数组</h2><p>在大多数编程语言中，我们既可以通过索引遍历数组，也可以直接遍历获取数组中的每个元素：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 遍历数组 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">traverse</span><span class="params">(<span class="type">int</span> *nums, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 通过索引遍历数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        count += nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 遍历数组 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(<span class="type">int</span> *nums, <span class="type">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 通过索引遍历数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        count += nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-6-查找元素"><a href="#1-6-查找元素" class="headerlink" title="1.6 查找元素"></a>1.6 查找元素</h2><p>在数组中查找指定元素需要遍历数组，每轮判断元素值是否匹配，若匹配则输出对应索引。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 在数组中查找指定元素 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> *nums, <span class="type">int</span> size, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == target)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 在数组中查找指定元素 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> *nums, <span class="type">int</span> size, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == target)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-7-扩容数组"><a href="#1-7-扩容数组" class="headerlink" title="1.7 扩容数组"></a>1.7 扩容数组</h2><p>当需要扩容数组时，需要重新建立一个更大的数组，然后把原数组元素依次复制到新数组。这是操作的时间复杂度时$O(n)$,因此在数组很大时非常耗时。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 扩展数组长度 */</span></span><br><span class="line"><span class="type">int</span> *<span class="title function_">extend</span><span class="params">(<span class="type">int</span> *nums, <span class="type">int</span> size, <span class="type">int</span> enlarge)</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化一个扩展长度后的数组</span></span><br><span class="line">    <span class="type">int</span> *res = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * (size + enlarge));</span><br><span class="line">    <span class="comment">// 将原数组中的所有元素复制到新数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        res[i] = nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化扩展后的空间</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = size; i &lt; size + enlarge; i++) &#123;</span><br><span class="line">        res[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回扩展后的新数组</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 扩展数组长度 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> *<span class="title">extend</span><span class="params">(<span class="type">int</span> *nums, <span class="type">int</span> size, <span class="type">int</span> enlarge)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化一个扩展长度后的数组</span></span><br><span class="line">    <span class="type">int</span> *res = <span class="keyword">new</span> <span class="type">int</span>[size + enlarge];</span><br><span class="line">    <span class="comment">// 将原数组中的所有元素复制到新数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        res[i] = nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化扩展后的新元素为 0</span></span><br><span class="line">    <span class="built_in">fill_n</span>(res + size, enlarge, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 释放内存</span></span><br><span class="line">    <span class="keyword">delete</span>[] nums;</span><br><span class="line">    <span class="comment">// 返回扩展后的新数组</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-数组的优点和局限性"><a href="#2-数组的优点和局限性" class="headerlink" title="2. 数组的优点和局限性"></a>2. 数组的优点和局限性</h1><p>数组存储在连续的内存空间内，且元素类型相同。这种做法包含丰富的先验信息，系统可以利用这些信息来优化数据结构的操作效率。</p><ul><li><strong>空间效率高</strong>：数组为数据分配了连续的内存块，无须额外的结构开销。</li><li><strong>支持随机访问</strong>：数组允许在$O(1)$时间内访问任何元素。</li><li><strong>缓存局部性</strong>：当访问数组元素时，计算机不仅会加载它，还会缓存其周围的其他数据，从而借助高速缓存来提升后续操作的执行速度。</li><li><strong>插入与删除效率低</strong>：当数组中元素较多时，插入与删除操作需要移动大量的元素。</li><li><strong>长度不可变</strong>：数组在初始化后长度就固定了，扩容数组需要将所有数据复制到新数组，开销很大。</li><li><strong>空间浪费</strong>：如果数组分配的大小超过实际所需，那么多余的空间就被浪费了。</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>[1] <a href="https://github.com/krahets/hello-algo" title="与时俱进、简介易懂的数据结构与算法教程">GitHub 开源项目《hello 算法》</a><br>[2] 程杰.大话数据结构【溢彩加强版】[M].清华大学出版社,2020.</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法1—基本概念与复杂度</title>
      <link href="/2025/01/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%951%E2%80%94%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
      <url>/2025/01/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%951%E2%80%94%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%A4%8D%E6%9D%82%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="1-算法的定义"><a href="#1-算法的定义" class="headerlink" title="1. 算法的定义"></a>1. 算法的定义</h1><p>算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。</p><h1 id="2-算法的特性"><a href="#2-算法的特性" class="headerlink" title="2. 算法的特性"></a>2. 算法的特性</h1><p>算法具有五个基本特性：<strong>输入、输出、有穷性、确定性和可行性</strong>。</p><h2 id="2-1-输入输出"><a href="#2-1-输入输出" class="headerlink" title="2.1 输入输出"></a>2.1 输入输出</h2><p>算法通常具有零个或多个输入，但<strong>至少有一个或多个输出</strong>。输出的形式可以是打印输出，也可以是返回一个或多个值。</p><h2 id="2-2-有穷性"><a href="#2-2-有穷性" class="headerlink" title="2.2 有穷性"></a>2.2 有穷性</h2><p>有穷性指算法在执行有限的步骤之后，自动结束而不会出现无限循环，并且每一个步骤在可接受的时间内完成。</p><h2 id="2-3-确定性"><a href="#2-3-确定性" class="headerlink" title="2.3 确定性"></a>2.3 确定性</h2><p>确定性指算法的每一步骤都具有确定的含义，不会出现二义性。</p><h2 id="2-4-可行性"><a href="#2-4-可行性" class="headerlink" title="2.4 可行性"></a>2.4 可行性</h2><p>可行性指算法的每一步都必须是可行的，也就是说每一步都能够执行有限次数完成。可行性意味着算法可以转化为程序上机运行，并得到正确的结果。</p><h1 id="3-算法设计的要求"><a href="#3-算法设计的要求" class="headerlink" title="3. 算法设计的要求"></a>3. 算法设计的要求</h1><p>算法设计的要求包括<strong>正确性、可读性、健壮性、高效率和低内存需求</strong>。</p><h2 id="3-1-正确性"><a href="#3-1-正确性" class="headerlink" title="3.1 正确性"></a>3.1 正确性</h2><p>算法的正确性是指算法至少应该具有输入、输出和加工处理无歧义性，能正确反映问题的需求，能够得到问题的正确答案。</p><ol><li>算法程序没有语法错误</li><li>算法程序对于合法的输入数据能够产生满足要求的输出结果。</li><li>算法程序对于非法的输入数据能够产生满足要求的输出结果。</li><li>算法程序对于精心选择的，甚至刁难的测试数据都有满足要求的输出结果。</li></ol><h2 id="3-2-可读性"><a href="#3-2-可读性" class="headerlink" title="3.2 可读性"></a>3.2 可读性</h2><p>算法设计的另一目的是为了便于阅读、理解和交流。</p><h2 id="3-3-健壮性"><a href="#3-3-健壮性" class="headerlink" title="3.3 健壮性"></a>3.3 健壮性</h2><p>当输入数据不合法时，算法也能做出相关处理，而不是产生异常或莫名期末的结果。</p><h2 id="3-4-时间效率高和存储量低"><a href="#3-4-时间效率高和存储量低" class="headerlink" title="3.4 时间效率高和存储量低"></a>3.4 时间效率高和存储量低</h2><p>设计算法应该尽量满足时间效率高和存储量低的需求。</p><h1 id="4-算法的度量方法"><a href="#4-算法的度量方法" class="headerlink" title="4 算法的度量方法"></a>4 算法的度量方法</h1><h2 id="4-1-事后统计法"><a href="#4-1-事后统计法" class="headerlink" title="4.1 事后统计法"></a>4.1 事后统计法</h2><p>这种方法主要是通过设计好的测试程序和数据，利用计算机计时器对不同算法编制的程序的运行时间进行比较，从而确定算法效率的高低。缺点是不科学和不准确。</p><h2 id="4-2-事前分析估算方法"><a href="#4-2-事前分析估算方法" class="headerlink" title="4.2 事前分析估算方法"></a>4.2 事前分析估算方法</h2><p>在计算机程序编写前，依据统计的方法对算法进行估算。</p><h1 id="5-复杂度"><a href="#5-复杂度" class="headerlink" title="5. 复杂度"></a>5. 复杂度</h1><h2 id="5-1-函数的渐近增长"><a href="#5-1-函数的渐近增长" class="headerlink" title="5.1 函数的渐近增长"></a>5.1 函数的渐近增长</h2><p>给定两个函数$f(n)$和$g(n)$，如果存在一个证书n，使得对于所有的$n&gt;N$，$f(n)$总是比$g(n)$大，那么我们说$f(n)$的增长渐近快于$g(n)$。于是我们可以得出一个结论，判断一个算法好不好，我们只通过少量的数据是不能做出准确判断的，如果我们可以对比算法的关键执行次数函数的渐近增长性，基本就可以分析出：某个算法，随着n的变大，它会越来越优于另一算法，或者越来越差于另一算法。</p><h2 id="5-2-时间复杂度"><a href="#5-2-时间复杂度" class="headerlink" title="5.2 时间复杂度"></a>5.2 时间复杂度</h2><p>时间复杂度采用大$O$记号表示,表示函数$T(n)$的渐近上界，其中$T(n)$表示操作数量，即每行代码运行的总次数。其中，时间复杂度由$T(n)$中最高阶的项决定。常见的时间复杂度所耗时间的大小排列如下：<br>$$<br>O(1)&lt;O(\log n)&lt;O(n)&lt;O(n\log n)&lt;O(n^2)&lt;O(2^n)&lt;O(n!)<br>$$<br>它们分别叫做常数阶、对数阶、线性阶、线性对数阶、平方阶、指数阶、阶乘阶。</p><h2 id="5-3-空间复杂度"><a href="#5-3-空间复杂度" class="headerlink" title="5.3 空间复杂度"></a>5.3 空间复杂度</h2><p>空间复杂度用于衡量算法占用内存空间随着数据量变大时的增长趋势。这个概念与时间复杂度相似，只需将“运行时间”替换为“占用内存空间”。<strong>通常我们都使用“时间复杂度”来指运行时间的需求，使用“空间复杂度”指空间需求，当不用限定词地使用“复杂度”时，通常都是指时间复杂度。</strong></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>[1] <a href="https://github.com/krahets/hello-algo" title="与时俱进、简介易懂的数据结构与算法教程">GitHub 开源项目《hello 算法》</a><br>[2] 程杰.大话数据结构【溢彩加强版】[M].清华大学出版社,2020.</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python格式规范</title>
      <link href="/2024/12/26/Python%E6%A0%BC%E5%BC%8F%E8%A7%84%E8%8C%83/"/>
      <url>/2024/12/26/Python%E6%A0%BC%E5%BC%8F%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Python命名规范"><a href="#1-Python命名规范" class="headerlink" title="1. Python命名规范"></a>1. Python命名规范</h1><h2 id="1-1-文件名、包名、模块名、变量名、函数名、实例名"><a href="#1-1-文件名、包名、模块名、变量名、函数名、实例名" class="headerlink" title="1.1 文件名、包名、模块名、变量名、函数名、实例名"></a>1.1 文件名、包名、模块名、变量名、函数名、实例名</h2><p>全部<strong>采用小写的形式，并使用下划线连接</strong>，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">my_car.py</span><br><span class="line">my_car</span><br></pre></td></tr></table></figure><h2 id="1-2-类名"><a href="#1-2-类名" class="headerlink" title="1.2 类名"></a>1.2 类名</h2><p><strong>采用驼峰命名法，即将类中的每个单词的首字母都大写，且不使用下划线</strong>，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ElectricCar</span><br></pre></td></tr></table></figure><h2 id="1-3-常量名"><a href="#1-3-常量名" class="headerlink" title="1.3 常量名"></a>1.3 常量名</h2><p><strong>所有字母大写，单词之间采用下划线连接</strong>，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MAX_NUM = <span class="number">100</span></span><br></pre></td></tr></table></figure><h1 id="2-Google-Python命名规范"><a href="#2-Google-Python命名规范" class="headerlink" title="2. Google Python命名规范"></a>2. Google Python命名规范</h1><blockquote><p>模块名写法: module_name ;<br>包名写法: package_name ;<br>类名: ClassName ;<br>方法名: method_name ;<br>异常名: ExceptionName ;<br>函数名: function_name ;<br>全局常量名: GLOBAL_CONSTANT_NAME ;<br>全局变量名: global_var_name ;<br>实例名: instance_var_name ;<br>函数参数名: function_parameter_name ;<br>局部变量名: local_var_name .</p></blockquote><h1 id="3-Python中代码格式"><a href="#3-Python中代码格式" class="headerlink" title="3. Python中代码格式"></a>3. Python中代码格式</h1><p>对于每个<strong>类、函数、方法都应在后面紧跟一个文档字符串</strong>，这种文档字符串简要地描述这个类、函数、方法的相关功能，对于<strong>每个模块也都应该包含一个文档字符串</strong>，模块中的文档字符串应该对其中的类的作用进行描述。</p><p>可使用空行来组织代码，但不要滥用。<strong>在类中，可使用一个空行来分隔方法</strong>；而<strong>在模块中，通常使用两个空行来分隔类</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python学习笔记6—类</title>
      <link href="/2024/12/26/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B06%E2%80%94%E7%B1%BB/"/>
      <url>/2024/12/26/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B06%E2%80%94%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="1-创建和使用类"><a href="#1-创建和使用类" class="headerlink" title="1. 创建和使用类"></a>1. 创建和使用类</h1><h2 id="1-1-创建Dog类"><a href="#1-1-创建Dog类" class="headerlink" title="1.1 创建Dog类"></a>1.1 创建Dog类</h2><p>下面将创建一个表示小狗的Dog类，根据Dog类创建的每个示例都将存储名字和年龄，并且赋予每条小狗蹲下（<code>sit()</code>）和打滚（<code>roll_over()</code>）的能力：</p><blockquote><p>dog.py</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot; 创建一个表示小狗的类 &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot; 初始化属性name和age &quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.name = name</span><br><span class="line">        <span class="variable language_">self</span>.age = age</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sit</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot; 模拟小狗被命令时蹲下 &quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="variable language_">self</span>.name.title() + <span class="string">&quot; is now sitting.&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">roll_over</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot; 模拟小狗被命令时打滚 &quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="variable language_">self</span>.name.title() + <span class="string">&quot; rolled over!&quot;</span>)</span><br></pre></td></tr></table></figure><p>在上面的代码中，定义了一个名为Dog的类。<strong>根据约定，在Python中，首字母大写的名称指的是类</strong>。这个类定义中的括号是空的，说明该类并没有需要继承的父类。</p><h3 id="1-1-1-方法-init"><a href="#1-1-1-方法-init" class="headerlink" title="1.1.1 方法__init__()"></a>1.1.1 方法__init__()</h3><p>类中的函数称为方法，而<code>__init__()</code>是一个特殊的方法，每当你根据Dog类创建新示例时，Python都会自动运行它，类似于C++类中的构造函数，在这个方法的名称中，开头和末尾各有两个下划线，这是一种约定，旨在避免Python默认方法与普通方法发生名称冲突。</p><p>我们将方法<code>__init__()</code>定义成了包含三个实参：self、name和age。在这个方法的定义中，<strong>形参self是必不可少的，还必须位于其他形参的前面，每个与类相关联的方法调用都自动传递实参self，它是一个指向示例本身的引用，让实例能够访问类中的属性和方法</strong>。我们将通过实参向Dog()传递名字和年龄，<code>self</code>会自动传递，因此我们不需要传递它，只需要给最后两个形参（<code>name</code>和<code>age</code>）提供值。</p><p>在类中，以<code>self</code>为前缀的变量都可供类中的所有方法使用，我们还可以通过类的实例来访问这些变量。<code>self.name = name</code>获取存储在形参<code>name</code>中的值，并将其存储到变量<code>name</code>中，然后该变量被关联到当前创建的实例。<code>self.age = age</code>的作用相同。像这样<strong>在类中可通过实例访问的变量称为属性</strong>。</p><h2 id="1-2-根据类创建实例"><a href="#1-2-根据类创建实例" class="headerlink" title="1.2 根据类创建实例"></a>1.2 根据类创建实例</h2><p>可将类视为有关如何创建实例的说明，<code>Dog</code>类是一系列说明，让Python知道如何创建表示特定小狗的实例。下面来创建一个表示特定小狗的实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>():</span><br><span class="line">    --snip--</span><br><span class="line"></span><br><span class="line">my_dog = Dog(<span class="string">&#x27;willie&#x27;</span>, <span class="number">6</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;My dog&#x27;s name is &quot;</span> + my_dog.name.title() + <span class="string">&quot;.&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;My dog is &quot;</span> + <span class="built_in">str</span>(my_dog.age) + <span class="string">&quot; years old.&quot;</span>)</span><br></pre></td></tr></table></figure><p>在上面这段代码中，创建了一个名字为’willie’、年龄为6的小狗。遇到这行代码时，Python将实参<code>&#39;willie&#39;</code>和<code>6</code>传入Dog类中的方法<code>__init__()</code>。方法<code>__init__()</code>创建一个便是特定小狗的实例，并使用实参的值来设置属性<code>name</code>和<code>age</code>。方法<code>__init__()</code>并未显式地包含return语句，但Python自动返回一个表示这条小狗的实例，并将这个实例存储在变量<code>my_dog</code>中。在Python中，我们通常可以认为首字母大写的名称（如Dog）指的是类，而小写的名称（如my_dog）指的是根据类创建的实例。</p><h3 id="1-2-1-访问属性"><a href="#1-2-1-访问属性" class="headerlink" title="1.2.1 访问属性"></a>1.2.1 访问属性</h3><p>要访问实例的属性，可使用句点表示法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_dog.name</span><br></pre></td></tr></table></figure><p>在这里，Python先找到实例<code>my_dog</code>，再查找与这个实例相关联的属性<code>name</code>。在<code>Dog</code>类中引用这个属性时，使用的是<code>self.name</code>，因此，在上面的实例化代码中，打印出的结果如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">My dog<span class="string">&#x27;s name is Willie.</span></span><br><span class="line"><span class="string">My dog is 6 years old.</span></span><br></pre></td></tr></table></figure><h3 id="1-2-2-调用方法"><a href="#1-2-2-调用方法" class="headerlink" title="1.2.2 调用方法"></a>1.2.2 调用方法</h3><p>根据<code>Dog</code>类创建实例后，就可以使用句点表示法来调用<code>Dog</code>类中定义的任何方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>():</span><br><span class="line">    --snip--</span><br><span class="line"></span><br><span class="line">my_dog = Dog(<span class="string">&#x27;willie&#x27;</span>, <span class="number">6</span>)</span><br><span class="line">my_dog.sit()</span><br><span class="line">my_dog.roll_over()</span><br></pre></td></tr></table></figure><p>要调用方法，可指定实例的名称和要调用的方法，并用句点分隔它们。上面的代码中运行的输出结果如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Willie <span class="keyword">is</span> now sitting.</span><br><span class="line">Willie rolled over!</span><br></pre></td></tr></table></figure><h1 id="2-使用类和实例"><a href="#2-使用类和实例" class="headerlink" title="2. 使用类和实例"></a>2. 使用类和实例</h1><p>在类编写好后，你的大部分时间都将花在使用根据类创建的实例上，你需要执行的一个重要任务是修改实例的属性。你可以直接修改实例的属性，也可以编写方法以特定的方式进行修改。</p><h2 id="2-1-Car类"><a href="#2-1-Car类" class="headerlink" title="2.1 Car类"></a>2.1 Car类</h2><p>下面是一个表示汽车的类，它存储了有关汽车的信息，还有一个汇总这些信息的方法：</p><blockquote><p>car.py</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot; 创建一个表示汽车的类 &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, make, model, year</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot; 初始化描述汽车的属性 &quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.make = make</span><br><span class="line">        <span class="variable language_">self</span>.model = model</span><br><span class="line">        <span class="variable language_">self</span>.year = year</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_descriptive_name</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot; 返回整洁的描述信息 &quot;&quot;&quot;</span></span><br><span class="line">        long_name = <span class="built_in">str</span>(<span class="variable language_">self</span>.year) + <span class="string">&#x27; &#x27;</span> + <span class="variable language_">self</span>.make + <span class="string">&#x27; &#x27;</span> + <span class="variable language_">self</span>.model</span><br><span class="line">        <span class="keyword">return</span> long_name.title()</span><br><span class="line"></span><br><span class="line">my_new_car = Car(<span class="string">&#x27;audi&#x27;</span>, <span class="string">&#x27;a4&#x27;</span>, <span class="number">2016</span>)</span><br><span class="line"><span class="built_in">print</span>(my_new_car.get_descriptive_name())</span><br></pre></td></tr></table></figure><p>在上面的代码中，输出结果如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span> Audi A4</span><br></pre></td></tr></table></figure><h2 id="2-2-给属性指定默认值"><a href="#2-2-给属性指定默认值" class="headerlink" title="2.2 给属性指定默认值"></a>2.2 给属性指定默认值</h2><p>类中的每个属性都必须有初始值，哪怕这个值是0或是空字符。在有些情况下，如设置默认值时，在方法<code>__init__()</code>内指定这种初始值是可行的，如如果你对某个属性这样做了，就无需包含为它提供初始值的形参。</p><p>下面来添加一个名为<code>odometer_reading</code>的属性，其初始值总是为0。除此之外，还添加了一个名为<code>read_odometer()</code>的方法，用于读取汽车的里程表：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot; 创建一个表示汽车的类 &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, make, model, year</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot; 初始化描述汽车的属性 &quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.make = make</span><br><span class="line">        <span class="variable language_">self</span>.model = model</span><br><span class="line">        <span class="variable language_">self</span>.year = year</span><br><span class="line">        <span class="variable language_">self</span>.odometer_reading = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_descriptive_name</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot; 返回整洁的描述信息 &quot;&quot;&quot;</span></span><br><span class="line">        long_name = <span class="built_in">str</span>(<span class="variable language_">self</span>.year) + <span class="string">&#x27; &#x27;</span> + <span class="variable language_">self</span>.make + <span class="string">&#x27; &#x27;</span> + <span class="variable language_">self</span>.model</span><br><span class="line">        <span class="keyword">return</span> long_name.title()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">read_odometer</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot; 打印一条指出汽车里程的信息 &quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;This car has &quot;</span> + <span class="built_in">str</span>(<span class="variable language_">self</span>.odometer_reading) + <span class="string">&quot; miles on it.&quot;</span>)</span><br><span class="line"></span><br><span class="line">my_new_car = Car(<span class="string">&#x27;audi&#x27;</span>, <span class="string">&#x27;a4&#x27;</span>, <span class="number">2016</span>)</span><br><span class="line"><span class="built_in">print</span>(my_new_car.get_descriptive_name())</span><br><span class="line">my_new_car.read_odometer()</span><br></pre></td></tr></table></figure><p>上面这段代码打印的结果如下，由于未对汽车里程进行修改，因此汽车的里程还是0：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span> Audi A4</span><br><span class="line">This car has <span class="number">0</span> miles on it.</span><br></pre></td></tr></table></figure><h2 id="2-3-修改属性的值"><a href="#2-3-修改属性的值" class="headerlink" title="2.3 修改属性的值"></a>2.3 修改属性的值</h2><p>在Python中，有如下两种不同的方式可以修改属性的值：直接通过实例进行修改；通过方法进行设置。下面依次介绍这些方法。</p><h3 id="2-3-1-直接修改属性的值"><a href="#2-3-1-直接修改属性的值" class="headerlink" title="2.3.1 直接修改属性的值"></a>2.3.1 直接修改属性的值</h3><p>要修改属性的值，最简单的方式是通过实例直接访问它。下面的代码直接将里程表度数设置为23：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>():</span><br><span class="line">    --snip--</span><br><span class="line"></span><br><span class="line">my_new_car = Car(<span class="string">&#x27;audi&#x27;</span>, <span class="string">&#x27;a4&#x27;</span>, <span class="number">2016</span>)</span><br><span class="line"><span class="built_in">print</span>(my_new_car.get_descriptive_name())</span><br><span class="line"></span><br><span class="line">my_new_car.odometer_reading = <span class="number">23</span></span><br><span class="line">my_new_car.read_odometer()</span><br></pre></td></tr></table></figure><p>此时，<code>my_new_car</code>这个实例中的<code>odometer_reading</code>属性就被修改为23：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span> Audi A4</span><br><span class="line">This car has <span class="number">23</span> miles on it.</span><br></pre></td></tr></table></figure><h3 id="2-3-2-通过方法修改属性的值"><a href="#2-3-2-通过方法修改属性的值" class="headerlink" title="2.3.2 通过方法修改属性的值"></a>2.3.2 通过方法修改属性的值</h3><p>下面的例子演示了一个名为<code>update_odometer()</code>的方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>():</span><br><span class="line">    --snip--</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update_odometer</span>(<span class="params">self, mileage</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot; 将里程表读书设置为指定的值 &quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.odometer_reading = mileage</span><br><span class="line"></span><br><span class="line">my_new_car = Car(<span class="string">&#x27;audi&#x27;</span>, <span class="string">&#x27;a4&#x27;</span>, <span class="number">2016</span>)</span><br><span class="line"><span class="built_in">print</span>(my_new_car.get_descriptive_name())</span><br><span class="line"></span><br><span class="line">my_new_car.update_odometer(<span class="number">23</span>)</span><br><span class="line">my_new_car.read_odometer()</span><br></pre></td></tr></table></figure><p>上面的代码中添加了一个新的方法<code>update_odometer()</code>。这个方法接受一个里程值，并将其存储到<code>self.odometer_reading</code>中。上面的代码打印结果如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span> Audi A4</span><br><span class="line">This car has <span class="number">23</span> miles on it.</span><br></pre></td></tr></table></figure><h1 id="3-继承"><a href="#3-继承" class="headerlink" title="3. 继承"></a>3. 继承</h1><p>编写类时，并非总是要从空白开始。如果你要编写的类是另一个现成类的特殊版本，可使用继承。<strong>一个类继承另一个类时，它将自动获得另一个类的所有属性和方法</strong>。原有的类称为父类，而新类称为它的子类。子类继承了其父类的所有属性和方法，同时还可以定义自己的属性和方法。</p><h2 id="3-1-子类的方法-init"><a href="#3-1-子类的方法-init" class="headerlink" title="3.1 子类的方法__init__()"></a>3.1 子类的方法__init__()</h2><p>创建子类时的示例时，Python首先需要先给父类的所有属性赋值，为此，子类的方法<code>__init__()</code>需要依靠父类。</p><p>下面的代码创建一个简单的ElectricCar类，它具备Car类的所有功能：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot; 创建一个表示汽车的类 &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, make, model, year</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot; 初始化描述汽车的属性 &quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.make = make</span><br><span class="line">        <span class="variable language_">self</span>.model = model</span><br><span class="line">        <span class="variable language_">self</span>.year = year</span><br><span class="line">        <span class="variable language_">self</span>.odometer_reading = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_descriptive_name</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot; 返回整洁的描述信息 &quot;&quot;&quot;</span></span><br><span class="line">        long_name = <span class="built_in">str</span>(<span class="variable language_">self</span>.year) + <span class="string">&#x27; &#x27;</span> + <span class="variable language_">self</span>.make + <span class="string">&#x27; &#x27;</span> + <span class="variable language_">self</span>.model</span><br><span class="line">        <span class="keyword">return</span> long_name.title()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">read_odometer</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot; 打印一条指出汽车里程的信息 &quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;This car has &quot;</span> + <span class="built_in">str</span>(<span class="variable language_">self</span>.odometer_reading) + <span class="string">&quot; miles on it.&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update_odometer</span>(<span class="params">self, mileage</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot; 将里程表读书设置为指定的值 &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> mileage &gt;= <span class="variable language_">self</span>.odometer_reading:</span><br><span class="line">            <span class="variable language_">self</span>.odometer_reading = mileage</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;You can&#x27;t roll back an odometer!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ElectricCar</span>(<span class="title class_ inherited__">Car</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;创建一个表示电动汽车的类 &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, make, model, year</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot; 初始化父类的属性 &quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(make, model, year)</span><br><span class="line"></span><br><span class="line">my_tesla = ElectricCar(<span class="string">&#x27;tesla&#x27;</span>, <span class="string">&#x27;model s&#x27;</span>, <span class="number">2016</span>)</span><br><span class="line"><span class="built_in">print</span>(my_tesla.get_descriptive_name())</span><br></pre></td></tr></table></figure><p>创建子类时，父类必须包含在当前文件中，且位于子类前面，在上面的代码中，我们定义了子类<code>ElectricCar</code>。定义子类时，必须在括号内指定父类的名称。方法<code>__init__()</code>接受创建<code>Car</code>示例所需的信息。<code>super()</code>是一个特殊函数，帮助Python将父类和子类关联起来，这行代码让Python调用<code>ElectricCar</code>的父类的方法<code>__init__()</code>，让<code>ElectricCar</code>实例包含父类的所有属性。父类也称为超类，名称<code>super()</code>因此而得名。上面这段代码的输出结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span> Tesla Model S</span><br></pre></td></tr></table></figure><p>可以看到继承自<code>Car</code>类的<code>ElectricCar</code>类确实具有和其父类Car相同的功能。</p><h2 id="3-2-给子类定义属性和方法"><a href="#3-2-给子类定义属性和方法" class="headerlink" title="3.2 给子类定义属性和方法"></a>3.2 给子类定义属性和方法</h2><p>让一个类继承另一个类后，可添加区分子类和父类所需的新属性和方法，下面的代码添加一个电动车特有的属性（电瓶），以及一个描述该属性的方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>():</span><br><span class="line">    --snip--</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ElectricCar</span>(<span class="title class_ inherited__">Car</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot; 创建一个继承自汽车类的电动车类 &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, make, model, year</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;  电动车的特点，初始化父类的属性，再初始化电动车特有的属性 &quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(make, model, year)</span><br><span class="line">        <span class="variable language_">self</span>.battery_size = <span class="number">70</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">describe_battery</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot; 打印一条描述电瓶容量的消息 &quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;This car has a &quot;</span> + <span class="built_in">str</span>(<span class="variable language_">self</span>.battery_size) + <span class="string">&quot;-kWh battery.&quot;</span>)</span><br><span class="line"></span><br><span class="line">my_tesla = ElectricCar(<span class="string">&#x27;tesla&#x27;</span>, <span class="string">&#x27;model s&#x27;</span>, <span class="number">2016</span>)</span><br><span class="line"><span class="built_in">print</span>(my_tesla.get_descriptive_name())</span><br><span class="line">my_tesla.describe_battery()</span><br></pre></td></tr></table></figure><p>在上面这行代码中，添加了新属性<code>self.battery_size</code>，并设置初始值为70。根据<code>ElectricCar</code>类创建的所有实例都将包含这个属性，但所有<code>Car</code>实例都不包含它。除此之外，还添加了一个<code>describe_battery()</code>方法，它打印有关电瓶的信息。我们调用这个方法时，将看到一条电动车特有的描述：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span> Tesla Model S</span><br><span class="line">This car has a <span class="number">70</span>-kWh battery.</span><br></pre></td></tr></table></figure><h2 id="3-3-重写父类方法"><a href="#3-3-重写父类方法" class="headerlink" title="3.3 重写父类方法"></a>3.3 重写父类方法</h2><p>对于父类的方法，只要它不符合子类模拟的实物的行为，都可对其进行重写。为此，可在子类中定义一个这样的方法，即它与要重写的父类方法同名。这样，Python将不会考虑这个父类方法，而只关注你在子类中重新定义的该方法。</p><p>假设<code>Car</code>类有一个名为<code>fill_gas_tank()</code>的方法，它对全电动车来说毫无意义，下面演示了一种重写方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ElectricCar</span>(<span class="title class_ inherited__">Car</span>):</span><br><span class="line">    --snip--</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fill_gas_tank</span>():</span><br><span class="line">        <span class="string">&quot;&quot;&quot; 电动汽车没有邮箱 &quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;This car doesn&#x27;t need a gas tank!&quot;</span>)</span><br></pre></td></tr></table></figure><p>现在，如果有人对电动车调用方法<code>fill_gas_tank()</code>，Python将忽略<code>Car</code>类中的方法<code>fill_gas_tank()</code>。转而运行上述代码。使用继承时，可让子类保留从父类哪里继承而来的精华，并剔除不需要的糟粕。</p><h2 id="3-4-将实例用作属性"><a href="#3-4-将实例用作属性" class="headerlink" title="3.4 将实例用作属性"></a>3.4 将实例用作属性</h2><p>在Python中，可以将大型类拆分成多个协同工作的小类，例如在下面的代码中，将针对汽车电瓶的属性和方法提取出来，放到另一个名为<code>Battery</code>的类中，并将一个<code>Battery</code>实例用作<code>ElectricCar</code>类的一个属性：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>():</span><br><span class="line">    --snip--</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Battery</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot; 创建一个关于电动车电瓶的类 &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, battery_size=<span class="number">70</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot; 初始化电瓶的属性 &quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.battery_size = battery_size</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">describe_battery</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot; 打印一条描述电瓶容量的消息 &quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;This car has a &quot;</span> + <span class="built_in">str</span>(<span class="variable language_">self</span>.battery_size) + <span class="string">&quot;-kWh battery.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ElectricCar</span>(<span class="title class_ inherited__">Car</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot; 创建一个关于电动车的类 &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, make, model, year</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot; 初始化父类的属性，再初始化电动车特有的属性 &quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(make, model, year)</span><br><span class="line">        <span class="variable language_">self</span>.battery = Battery()</span><br><span class="line"></span><br><span class="line">my_tesla = ElectricCar(<span class="string">&#x27;tesla&#x27;</span>, <span class="string">&#x27;model s&#x27;</span>, <span class="number">2016</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(my_tesla.get_descriptive_name())</span><br><span class="line">my_tesla.battery.describe_battery()</span><br></pre></td></tr></table></figure><p>在上面的代码中，定义了一个名为<code>Battery</code>的新类，在<code>ElectricCar</code>这个类中，创建了一个名为<code>self.battery</code>的Battery实例。现在每个ElectricCar实例都包含一个自动创建的Battery实例。输出结果如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span> Tesla Model S</span><br><span class="line">This car has a <span class="number">70</span>-kWh battery.</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python学习笔记5—函数</title>
      <link href="/2024/12/26/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B05%E2%80%94%E5%87%BD%E6%95%B0/"/>
      <url>/2024/12/26/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B05%E2%80%94%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="1-函数的定义"><a href="#1-函数的定义" class="headerlink" title="1. 函数的定义"></a>1. 函数的定义</h1><p>在Python中，函数可按下面这种方式定义：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">greet_user</span>(<span class="params">username</span>): </span><br><span class="line">    <span class="string">&quot;&quot;&quot; 显示简单的问候语 &quot;&quot;&quot;</span> </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello, &quot;</span> + username.title() + <span class="string">&quot;!&quot;</span>) </span><br><span class="line"> </span><br><span class="line">greet_user(<span class="string">&#x27;jesse&#x27;</span>)</span><br></pre></td></tr></table></figure><p>上面这段代码演示了最简单的函数结构，第一行代码使用关键字def来定义一个函数，def后面的greet_user(username)为函数名，username叫做函数的形参，而’jesse’叫做实参。紧跟在def greet_user(username):后面的所有缩进行构成了函数体。””” 显示简单的问候语 “””叫做文档字符串，描述的函数是做什么的，文档字符串用三引号括起，Python使用它们来生成有关程序中函数的文档。要使用这个函数，可调用它，依次指定函数名以及要传入括号中的参数。上面这段代码的输出为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello, Jesse!</span><br></pre></td></tr></table></figure><h1 id="2-传递参数"><a href="#2-传递参数" class="headerlink" title="2. 传递参数"></a>2. 传递参数</h1><p>鉴于函数定义中可能包含多个形参，因此函数调用中也可能包含多个实参。向函数传递参数的方式很多，可使用位置实参，这要求实参的顺序与形参的顺序相同；也可使用关键字实参，其中每个实参由变量名和值组成；还可使用列表和字典。下面将一一介绍：</p><h2 id="2-1-位置实参"><a href="#2-1-位置实参" class="headerlink" title="2.1 位置实参"></a>2.1 位置实参</h2><p>在调用函数时，Python必须将函数调用中的每个实参都关联到函数定义中的一个形参，为此，最简单的关联方式是基于实参的顺序，这种关联方式被称为位置实参：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">describe_pet</span>(<span class="params">animal_type, pet_name</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot; 显示宠物的信息 &quot;&quot;&quot;</span> </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\nI have a &quot;</span> + animal_type + <span class="string">&quot;.&quot;</span>) </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;My &quot;</span> + animal_type + <span class="string">&quot;&#x27;s name is &quot;</span> + pet_name.title() + <span class="string">&quot;.&quot;</span>) </span><br><span class="line"> </span><br><span class="line">describe_pet(<span class="string">&#x27;hamster&#x27;</span>, <span class="string">&#x27;harry&#x27;</span>)</span><br></pre></td></tr></table></figure><p>如上面的代码所示，在函数调用中，实参’hamster’存储在形参animal_type中，而实参’harry’存储在形参pet_name中，即实参按位置依次存储在两个形参中，最后的输出结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">I have a hamster. </span><br><span class="line">My hamste<span class="string">r&#x27;s name is Harry.</span></span><br></pre></td></tr></table></figure><h2 id="2-2-关键字实参"><a href="#2-2-关键字实参" class="headerlink" title="2.2 关键字实参"></a>2.2 关键字实参</h2><p>关键字实参是传递给函数的名称—值对。在调用函数时，可在实参中将名称和值关联起来，这样在函数传递参数时就不会有参数传递错误的烦恼。关键字实参让你无需考虑函数调用中的实参顺序，还清楚地指出了函数调用中各个值的用途。如下所示为在调用函数时使用关键字实参：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">describe_pet</span>(<span class="params">animal_type, pet_name</span>): </span><br><span class="line">    <span class="string">&quot;&quot;&quot; 显示宠物的信息 &quot;&quot;&quot;</span> </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\nI have a &quot;</span> + animal_type + <span class="string">&quot;.&quot;</span>) </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;My &quot;</span> + animal_type + <span class="string">&quot;&#x27;s name is &quot;</span> + pet_name.title() + <span class="string">&quot;.&quot;</span>) </span><br><span class="line"> </span><br><span class="line">describe_pet(animal_type=<span class="string">&#x27;hamster&#x27;</span>, pet_name=<span class="string">&#x27;harry&#x27;</span>)</span><br></pre></td></tr></table></figure><p>在上面的代码中，在调用函数时使用了关键字实参，其输出结果与2.1中的结果一样，值得注意的是，关键字实参的顺序无关紧要，如下面两个函数的调用是等效的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">describe_pet(animal_type=<span class="string">&#x27;hamster&#x27;</span>, pet_name=<span class="string">&#x27;harry&#x27;</span>) </span><br><span class="line">describe_pet(pet_name=<span class="string">&#x27;harry&#x27;</span>, animal_type=<span class="string">&#x27;hamster&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="2-3-给形参指定默认值"><a href="#2-3-给形参指定默认值" class="headerlink" title="2.3 给形参指定默认值"></a>2.3 给形参指定默认值</h2><p>编写函数时，可给每个形参指定默认值。在调用函数中给形参提供了实参时，函数将使用指定的实参值，否则将使用形参的默认值，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">describe_pet</span>(<span class="params">pet_name, animal_type=<span class="string">&#x27;dog&#x27;</span></span>): </span><br><span class="line">    <span class="string">&quot;&quot;&quot; 显示宠物的信息 &quot;&quot;&quot;</span> </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\nI have a &quot;</span> + animal_type + <span class="string">&quot;.&quot;</span>) </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;My &quot;</span> + animal_type + <span class="string">&quot;&#x27;s name is &quot;</span> + pet_name.title() + <span class="string">&quot;.&quot;</span>) </span><br><span class="line"> </span><br><span class="line">describe_pet(pet_name=<span class="string">&#x27;willie&#x27;</span>)</span><br><span class="line">describe_pet(<span class="string">&#x27;willie&#x27;</span>)</span><br></pre></td></tr></table></figure><p>在上面的代码中，调用函数时，没有给形参animal_type传入实参的值，因此形参animal_type将使用默认值’dog’作为要传入的实参值，其输出结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">I have a dog. </span><br><span class="line">My dog<span class="string">&#x27;s name is Willie.</span></span><br><span class="line"><span class="string">I have a dog. </span></span><br><span class="line"><span class="string">My dog&#x27;</span>s name <span class="keyword">is</span> Willie.</span><br></pre></td></tr></table></figure><p>值得注意的是，在给形参指定默认值后，要是想用位置实参，则需要在函数定义时将指定了默认值的形参放在末尾，防止参数传递错误。</p><p>当然，你也可以在调用函数时传入实参以覆盖掉默认值，像下面这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">describe_pet(pet_name=<span class="string">&#x27;harry&#x27;</span>, animal_type=<span class="string">&#x27;hamster&#x27;</span>)</span><br><span class="line">describe_pet(<span class="string">&#x27;harry&#x27;</span>, <span class="string">&#x27;hamster&#x27;</span>)</span><br></pre></td></tr></table></figure><p>此时，函数的输出结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">I have a hamster.</span><br><span class="line">My hamste<span class="string">r&#x27;s name is Harry.</span></span><br><span class="line"><span class="string">I have a hamster.</span></span><br><span class="line"><span class="string">My hamster&#x27;</span>s name <span class="keyword">is</span> Harry.</span><br></pre></td></tr></table></figure><h1 id="3-返回值"><a href="#3-返回值" class="headerlink" title="3. 返回值"></a>3. 返回值</h1><h2 id="3-1-返回简单值"><a href="#3-1-返回简单值" class="headerlink" title="3.1 返回简单值"></a>3.1 返回简单值</h2><p>在Python的函数中，可以使用return来返回一个值，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_formatted_name</span>(<span class="params">first_name, last_name</span>): </span><br><span class="line">    <span class="string">&quot;&quot;&quot; 返回整洁的姓名 &quot;&quot;&quot;</span> </span><br><span class="line">    full_name = first_name + <span class="string">&#x27; &#x27;</span> + last_name </span><br><span class="line">    <span class="keyword">return</span> full_name.title()</span><br><span class="line"> </span><br><span class="line">musician = get_formatted_name(<span class="string">&#x27;jimi&#x27;</span>, <span class="string">&#x27;hendrix&#x27;</span>) </span><br><span class="line"><span class="built_in">print</span>(musician)</span><br></pre></td></tr></table></figure><p>在上面的代码中，调用函数get_formatted_name()时，会将整理好的姓名返回，并存储在变量musician中，其输出结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Jimi Hendrix</span><br></pre></td></tr></table></figure><h2 id="3-2-将形参的默认值指定为空字符串以实现实参可选"><a href="#3-2-将形参的默认值指定为空字符串以实现实参可选" class="headerlink" title="3.2 将形参的默认值指定为空字符串以实现实参可选"></a>3.2 将形参的默认值指定为空字符串以实现实参可选</h2><p>有时候，需要让实参变成可选的，这样使用函数的人就只需在必要时才提供额外的信息，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_formatted_name</span>(<span class="params">first_name, last_name, middle_name=<span class="string">&#x27;&#x27;</span></span>): </span><br><span class="line">    <span class="string">&quot;&quot;&quot; 返回整洁的姓名 &quot;&quot;&quot;</span> </span><br><span class="line">    <span class="keyword">if</span> middle_name: </span><br><span class="line">        full_name = first_name + <span class="string">&#x27; &#x27;</span> + middle_name + <span class="string">&#x27; &#x27;</span> + last_name </span><br><span class="line">    <span class="keyword">else</span>: </span><br><span class="line">        full_name = first_name + <span class="string">&#x27; &#x27;</span> + last_name <span class="keyword">return</span> full_name.title() </span><br><span class="line"> </span><br><span class="line">musician = get_formatted_name(<span class="string">&#x27;jimi&#x27;</span>, <span class="string">&#x27;hendrix&#x27;</span>) </span><br><span class="line"><span class="built_in">print</span>(musician) </span><br><span class="line"> </span><br><span class="line">musician = get_formatted_name(<span class="string">&#x27;john&#x27;</span>, <span class="string">&#x27;hooker&#x27;</span>, <span class="string">&#x27;lee&#x27;</span>) </span><br><span class="line"><span class="built_in">print</span>(musician)</span><br></pre></td></tr></table></figure><p>在上面的代码中，将形参middle_name指定为空字符串，这样在调用函数时就可不向其传入参数。</p><h2 id="3-3-返回字典或列表"><a href="#3-3-返回字典或列表" class="headerlink" title="3.3 返回字典或列表"></a>3.3 返回字典或列表</h2><p>函数可返回任何类型的值，包括字典和列表等较复杂的数据结构，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">build_person</span>(<span class="params">first_name, last_name</span>): </span><br><span class="line">    <span class="string">&quot;&quot;&quot; 返回一个字典，其中包含有关一个人的信息 &quot;&quot;&quot;</span> </span><br><span class="line">    person = &#123;<span class="string">&#x27;first&#x27;</span>: first_name, <span class="string">&#x27;last&#x27;</span>: last_name&#125; </span><br><span class="line">    <span class="keyword">return</span> person </span><br><span class="line"> </span><br><span class="line">musician = build_person(<span class="string">&#x27;jimi&#x27;</span>, <span class="string">&#x27;hendrix&#x27;</span>) </span><br><span class="line"><span class="built_in">print</span>(musician)</span><br></pre></td></tr></table></figure><p>其输出结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&#x27;first&#x27;</span>: <span class="string">&#x27;jimi&#x27;</span>, <span class="string">&#x27;last&#x27;</span>: <span class="string">&#x27;hendrix&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><h1 id="4-传递列表"><a href="#4-传递列表" class="headerlink" title="4. 传递列表"></a>4. 传递列表</h1><h2 id="4-1-向函数传递列表"><a href="#4-1-向函数传递列表" class="headerlink" title="4.1 向函数传递列表"></a>4.1 向函数传递列表</h2><p>有时候，向函数传递列表很有用，这种列表包含的可能是名字、数字或更复杂的对象（如字典）。将列表传递给函数后，函数就能直接访问其内容，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">greet_users</span>(<span class="params">names</span>): </span><br><span class="line">    <span class="string">&quot;&quot;&quot;向列表中的每位用户都发出简单的问候&quot;&quot;&quot;</span> </span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> names: </span><br><span class="line">        msg = <span class="string">&quot;Hello, &quot;</span> + name.title() + <span class="string">&quot;!&quot;</span> </span><br><span class="line">        <span class="built_in">print</span>(msg) </span><br><span class="line"> </span><br><span class="line">usernames = [<span class="string">&#x27;hannah&#x27;</span>, <span class="string">&#x27;ty&#x27;</span>, <span class="string">&#x27;margot&#x27;</span>]</span><br><span class="line">greet_users(usernames)</span><br></pre></td></tr></table></figure><p>在上面的代码中，将一个列表传入了函数，并在函数中对其进行遍历打印，其输出结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hello, Hannah! </span><br><span class="line">Hello, Ty! </span><br><span class="line">Hello, Margot!</span><br></pre></td></tr></table></figure><h2 id="4-2-在函数中修改列表"><a href="#4-2-在函数中修改列表" class="headerlink" title="4.2 在函数中修改列表"></a>4.2 在函数中修改列表</h2><p>将列表传递给函数后，函数就可对其进行修改，在函数中对这个列表所做的任何修改都是永久性的，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">print_models</span>(<span class="params">unprinted_designs, completed_models</span>): </span><br><span class="line">    <span class="string">&quot;&quot;&quot; </span></span><br><span class="line"><span class="string">    模拟打印每个设计，直到没有未打印的设计为止 </span></span><br><span class="line"><span class="string">    打印每个设计后，都将其移到列表completed_models中 </span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span> </span><br><span class="line">    <span class="keyword">while</span> unprinted_designs: </span><br><span class="line">        current_design = unprinted_designs.pop() </span><br><span class="line">        <span class="comment"># 模拟根据设计制作3D打印模型的过程 </span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Printing model: &quot;</span> + current_design) </span><br><span class="line">        completed_models.append(current_design) </span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show_completed_models</span>(<span class="params">completed_models</span>): </span><br><span class="line">    <span class="string">&quot;&quot;&quot; 显示打印好的所有模型 &quot;&quot;&quot;</span> </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\nThe following models have been printed:&quot;</span>) </span><br><span class="line">    <span class="keyword">for</span> completed_model <span class="keyword">in</span> completed_models: </span><br><span class="line">        <span class="built_in">print</span>(completed_model) </span><br><span class="line"> </span><br><span class="line">unprinted_designs = [<span class="string">&#x27;iphone case&#x27;</span>, <span class="string">&#x27;robot pendant&#x27;</span>, <span class="string">&#x27;dodecahedron&#x27;</span>] </span><br><span class="line">completed_models = [] </span><br><span class="line"> </span><br><span class="line">print_models(unprinted_designs, completed_models) </span><br><span class="line">show_completed_models(completed_models)</span><br></pre></td></tr></table></figure><p>在上面这段代码中，向函数print_models()传入一个具有三个元素的列表unprinted_designs和一个空列表completed_models，在函数中将列表unprinted_designs中的元素依次弹出，再依次存储在空列表completed_models中，调用print_models()函数后，原本具有三个元素的列表unprinted_designs变为空列表，而原本为空列表的completed_models则倒序存储有unprinted_designs中的元素，其输出结果如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Printing model: dodecahedron</span><br><span class="line">Printing model: robot pendant</span><br><span class="line">Printing model: iphone <span class="keyword">case</span></span><br><span class="line"> </span><br><span class="line">The following models have been printed:</span><br><span class="line">dodecahedron</span><br><span class="line">robot pendant</span><br><span class="line">iphone <span class="keyword">case</span></span><br></pre></td></tr></table></figure><h2 id="4-3-禁止函数修改列表（使用列表切片副本）"><a href="#4-3-禁止函数修改列表（使用列表切片副本）" class="headerlink" title="4.3 禁止函数修改列表（使用列表切片副本）"></a>4.3 禁止函数修改列表（使用列表切片副本）</h2><p>将原列表当作实参传入函数时，如果在函数对其进行修改，则该修改是不可逆的，如果想要将列表传入函数，又要原列表不发生变化，则可选择将列表的切片副本传入函数，这样既能得到传递原列表相同的结果，又能保证原列表不发生变化，其形式如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function_name(list_name[:])</span><br></pre></td></tr></table></figure><h1 id="5-传递任意数量的实参"><a href="#5-传递任意数量的实参" class="headerlink" title="5. 传递任意数量的实参"></a>5. 传递任意数量的实参</h1><p>如果你预先不知道函数需要接受多少个实参，则可以采用下面的方法使函数能够传递任意数量的实参：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">make_pizza</span>(<span class="params">*toppings</span>): </span><br><span class="line">    <span class="string">&quot;&quot;&quot; 打印顾客点的所有配料 &quot;&quot;&quot;</span> </span><br><span class="line">    <span class="built_in">print</span>(toppings) </span><br><span class="line"> </span><br><span class="line">make_pizza(<span class="string">&#x27;pepperoni&#x27;</span>) </span><br><span class="line">make_pizza(<span class="string">&#x27;mushrooms&#x27;</span>, <span class="string">&#x27;green peppers&#x27;</span>, <span class="string">&#x27;extra cheese&#x27;</span>)</span><br></pre></td></tr></table></figure><p>形参名*toppings中的星号让Python创建一个名为toppings的空元组，并将收到的所有值都封装到这个元组中，其输出结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="string">&#x27;pepperoni&#x27;</span>,) </span><br><span class="line">(<span class="string">&#x27;mushrooms&#x27;</span>, <span class="string">&#x27;green peppers&#x27;</span>, <span class="string">&#x27;extra cheese&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="5-1-结合使用位置实参和任意数量实参"><a href="#5-1-结合使用位置实参和任意数量实参" class="headerlink" title="5.1 结合使用位置实参和任意数量实参"></a>5.1 结合使用位置实参和任意数量实参</h2><p>如果要让函数接收不同类型的实参，必须在函数定义中将接纳任意数量实参的形参放在最后。Python先匹配位置实参和关键字实参，再将余下的实参都收集到最后一个形参中，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">make_pizza</span>(<span class="params">size, *toppings</span>): </span><br><span class="line">    <span class="string">&quot;&quot;&quot; 概述要制作的比萨 &quot;&quot;&quot;</span> </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\nMaking a &quot;</span> + <span class="built_in">str</span>(size) + <span class="string">&quot;-inch pizza with the following toppings:&quot;</span>) </span><br><span class="line">    <span class="keyword">for</span> topping <span class="keyword">in</span> toppings: </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;- &quot;</span> + topping) </span><br><span class="line"> </span><br><span class="line">make_pizza(<span class="number">16</span>, <span class="string">&#x27;pepperoni&#x27;</span>) </span><br><span class="line">make_pizza(<span class="number">12</span>, <span class="string">&#x27;mushrooms&#x27;</span>, <span class="string">&#x27;green peppers&#x27;</span>, <span class="string">&#x27;extra cheese&#x27;</span>)</span><br></pre></td></tr></table></figure><p>基于上述函数定义，Python将收到的第一个值存储在形参size中，并将其他的所有值都存储在元组toppings中，其使出结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Making a <span class="number">16</span>-inch pizza <span class="keyword">with</span> the following toppings:</span><br><span class="line">- pepperoni</span><br><span class="line"> </span><br><span class="line">Making a <span class="number">12</span>-inch pizza <span class="keyword">with</span> the following toppings:</span><br><span class="line">- mushrooms</span><br><span class="line">- green peppers</span><br><span class="line">- extra cheese</span><br></pre></td></tr></table></figure><h2 id="5-2-使用任意数量的关键字实参"><a href="#5-2-使用任意数量的关键字实参" class="headerlink" title="5.2 使用任意数量的关键字实参"></a>5.2 使用任意数量的关键字实参</h2><p>有时候，需要接受任意数量的实参，但预先不知道传递给函数的会是什么样的信息。在这种情况下，可将函数编写成能够接受任意数量的键值对，如下面的代码所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">build_profile</span>(<span class="params">first, last, **user_info</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot; 创建一个字典，其中包含我们知道的有关用户的一切 &quot;&quot;&quot;</span></span><br><span class="line">    profile = &#123;&#125;</span><br><span class="line">    profile[<span class="string">&#x27;first_name&#x27;</span>] = first</span><br><span class="line">    profile[<span class="string">&#x27;last_name&#x27;</span>] = last</span><br><span class="line">    <span class="keyword">for</span> key, value <span class="keyword">in</span> user_info.items():</span><br><span class="line">        profile[key] = value</span><br><span class="line">    <span class="keyword">return</span> profile</span><br><span class="line"> </span><br><span class="line">user_profile = build_profile(<span class="string">&#x27;albert&#x27;</span>, <span class="string">&#x27;einstein&#x27;</span>, location=<span class="string">&#x27;princeton&#x27;</span>, field=<span class="string">&#x27;physics&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(user_profile)</span><br></pre></td></tr></table></figure><p>函数build_profile()的定义要求提供名和姓，同时允许用户根据需要提供任意数量的名称—值对。形参**user_info中的两个星号让Python创建一个名为user_info的空字典，并将收到的所有名称—值对都封装到这个字典中。在这个函数中，可以像访问其他字典那样访问user_info中的名称—值对。</p><h1 id="6-将函数存储在模块中"><a href="#6-将函数存储在模块中" class="headerlink" title="6. 将函数存储在模块中"></a>6. 将函数存储在模块中</h1><p>函数的优点之一是使用它们可将代码与主程序分离。通过给函数指定描述性名称，可让主程序容易理解得多。进一步的，函数还可以存储在被称为模块的独立文件中，再将模块导入到主程序中。import语句允许再当前运行的程序文件中使用模块中的函数。导入模块的方法有很多种，下面将做一一介绍。</p><h2 id="6-1-导入整个模块"><a href="#6-1-导入整个模块" class="headerlink" title="6.1 导入整个模块"></a>6.1 导入整个模块</h2><p>要让函数是可导入的，得先创建模块。模块是扩展名为.py的文件，包含要导入到程序中的代码。下面来创建一个包含函数make_pizza()的模块，并将其保存在pizza.py中。</p><blockquote><p>pizza.py</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">make_pizza</span>(<span class="params">size, *toppings</span>): </span><br><span class="line">    <span class="string">&quot;&quot;&quot; 概述要制作的比萨 &quot;&quot;&quot;</span> </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\nMaking a &quot;</span> + <span class="built_in">str</span>(size) + <span class="string">&quot;-inch pizza with the following toppings:&quot;</span>) </span><br><span class="line">    <span class="keyword">for</span> topping <span class="keyword">in</span> toppings: </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;- &quot;</span> + topping)</span><br></pre></td></tr></table></figure><p>接下来，在pizza.py所在的目录中创建另一个名为making_pizzas.py的文件，这个文件导入刚创建的模块，再调用make_pizza()两次：</p><blockquote><p>making_pizzas.py</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pizza </span><br><span class="line"> </span><br><span class="line">pizza.make_pizza(<span class="number">16</span>, <span class="string">&#x27;pepperoni&#x27;</span>) </span><br><span class="line">pizza.make_pizza(<span class="number">12</span>, <span class="string">&#x27;mushrooms&#x27;</span>, <span class="string">&#x27;green peppers&#x27;</span>, <span class="string">&#x27;extra cheese&#x27;</span>)</span><br></pre></td></tr></table></figure><p>Python读取这个文件时，代码行import pizza让Python打开文件pizza.py，并将其中所有的函数都复制到这个程序中。你看不到复制的代码，因为这个程序运行时，Python再幕后复制这些代码，你只需要知道，在making_pizza.py中，可以使用pizza.py中定义的所有函数。要调用被导入的模块中的函数，可指定导入的模块的名称pizza和函 数名make_pizza()，并用句点分隔它们。这些代码的输出与没有导入模块的原始程序相同：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Making a <span class="number">16</span>-inch pizza <span class="keyword">with</span> the following toppings:</span><br><span class="line">- pepperoni</span><br><span class="line"> </span><br><span class="line">Making a <span class="number">12</span>-inch pizza <span class="keyword">with</span> the following toppings:</span><br><span class="line">- mushrooms</span><br><span class="line">- green peppers</span><br><span class="line">- extra cheese</span><br></pre></td></tr></table></figure><h2 id="6-2-导入特定的函数"><a href="#6-2-导入特定的函数" class="headerlink" title="6.2 导入特定的函数"></a>6.2 导入特定的函数</h2><p>还可以导入模块中的特定函数，这种导入方法的语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> module_name <span class="keyword">import</span> function_name</span><br></pre></td></tr></table></figure><p>通过用逗号分隔函数名，还可根据需要从模块中导入任意数量的函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> module_name <span class="keyword">import</span> function_0, function_1, function_2</span><br></pre></td></tr></table></figure><p>对于前面的making_pizzas.py示例，如果只想导入要使用的函数，代码将类似于下面这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pizza <span class="keyword">import</span> make_pizza </span><br><span class="line"> </span><br><span class="line">make_pizza(<span class="number">16</span>, <span class="string">&#x27;pepperoni&#x27;</span>) </span><br><span class="line">make_pizza(<span class="number">12</span>, <span class="string">&#x27;mushrooms&#x27;</span>, <span class="string">&#x27;green peppers&#x27;</span>, <span class="string">&#x27;extra cheese&#x27;</span>)</span><br></pre></td></tr></table></figure><p>若使用这种语法，调用函数时就无需使用句点。由于我们在import语句中显式地导入了函数make_pizza()，因此调用它时只需指定其名称。</p><h2 id="6-3-使用as给函数指定别名"><a href="#6-3-使用as给函数指定别名" class="headerlink" title="6.3 使用as给函数指定别名"></a>6.3 使用as给函数指定别名</h2><p>如果要导入的函数的名称可能与程序中现有的名称冲突，或者函数的名称太长，可将函数指定为另一个好辨识的别名，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pizza <span class="keyword">import</span> make_pizza <span class="keyword">as</span> mp </span><br><span class="line"> </span><br><span class="line">mp(<span class="number">16</span>, <span class="string">&#x27;pepperoni&#x27;</span>) </span><br><span class="line">mp(<span class="number">12</span>, <span class="string">&#x27;mushrooms&#x27;</span>, <span class="string">&#x27;green peppers&#x27;</span>, <span class="string">&#x27;extra cheese&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="6-4-使用as给模块指定别名"><a href="#6-4-使用as给模块指定别名" class="headerlink" title="6.4 使用as给模块指定别名"></a>6.4 使用as给模块指定别名</h2><p>除了给函数指定别名外，还可以给模块指定别名，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pizza <span class="keyword">as</span> p </span><br><span class="line">p.make_pizza(<span class="number">16</span>, <span class="string">&#x27;pepperoni&#x27;</span>) </span><br><span class="line">p.make_pizza(<span class="number">12</span>, <span class="string">&#x27;mushrooms&#x27;</span>, <span class="string">&#x27;green peppers&#x27;</span>, <span class="string">&#x27;extra cheese&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="6-5-导入模块中的所有函数"><a href="#6-5-导入模块中的所有函数" class="headerlink" title="6.5 导入模块中的所有函数"></a>6.5 导入模块中的所有函数</h2><p>使用星号（*）运算符可让Python导入模块中的所有函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pizza <span class="keyword">import</span> * </span><br><span class="line"> </span><br><span class="line">make_pizza(<span class="number">16</span>, <span class="string">&#x27;pepperoni&#x27;</span>) </span><br><span class="line">make_pizza(<span class="number">12</span>, <span class="string">&#x27;mushrooms&#x27;</span>, <span class="string">&#x27;green peppers&#x27;</span>, <span class="string">&#x27;extra cheese&#x27;</span>)</span><br></pre></td></tr></table></figure><p>当然在使用并非自己编写的大型模块时，不建议使用这种导入方法，它很可能会导致多个函数名称相同，从而互相覆盖的问题，<strong>正确的做法是，要么只导入你需要使用的函数，要么导入整个模块并使用句点表示法。</strong></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python学习笔记4—字典</title>
      <link href="/2024/12/26/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04%E2%80%94%E5%AD%97%E5%85%B8/"/>
      <url>/2024/12/26/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04%E2%80%94%E5%AD%97%E5%85%B8/</url>
      
        <content type="html"><![CDATA[<h1 id="1-字典的创建和访问字典中的值"><a href="#1-字典的创建和访问字典中的值" class="headerlink" title="1. 字典的创建和访问字典中的值"></a>1. 字典的创建和访问字典中的值</h1><p>在Pyhton中，字典是一系列键值对，每个键都与一个值相关联，可以使用键来访问与之相关联的值。与键相关联的值可以是数字、字符串、列表乃至字典。在Python中，字典用放在花括号{}中的一系列键值对表示，如下面就是一个字典：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alien_0 = &#123;<span class="string">&#x27;color&#x27;</span>: <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;points&#x27;</span>: <span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure><p>键值对是两个相关联的值，指定键时，Python将返回与之相关联的值。键和值之间用冒号分隔，而键值对之间用逗号分隔。</p><p>要获取与键相关联的值，可依次指定字典名和放在方括号内的键，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alien_0 = &#123;<span class="string">&#x27;color&#x27;</span>: <span class="string">&#x27;green&#x27;</span>&#125; </span><br><span class="line"><span class="built_in">print</span>(alien_0[<span class="string">&#x27;color&#x27;</span>])</span><br></pre></td></tr></table></figure><p>这将返回字典中alien_0中与键’color’相关联的值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">green</span><br></pre></td></tr></table></figure><h1 id="2-在字典中添加键值对"><a href="#2-在字典中添加键值对" class="headerlink" title="2. 在字典中添加键值对"></a>2. 在字典中添加键值对</h1><p>字典是一种动态结构，可随时在其中添加键值对。要添加键值对，可依次指定字典名、用方括号括起的键和相关联的值，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">alien_0 = &#123;<span class="string">&#x27;color&#x27;</span>: <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;points&#x27;</span>: <span class="number">5</span>&#125; </span><br><span class="line"><span class="built_in">print</span>(alien_0) </span><br><span class="line"> </span><br><span class="line">alien_0[<span class="string">&#x27;x_position&#x27;</span>] = <span class="number">0</span></span><br><span class="line">alien_0[<span class="string">&#x27;y_position&#x27;</span>] = <span class="number">25</span></span><br><span class="line"><span class="built_in">print</span>(alien_0)</span><br></pre></td></tr></table></figure><p>在这段代码中，首先定义了一个字典alien_0，然后在里面添加了两个键值对，其输出为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&#x27;color&#x27;</span>: <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;points&#x27;</span>: <span class="number">5</span>&#125; </span><br><span class="line">&#123;<span class="string">&#x27;color&#x27;</span>: <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;points&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;x_position&#x27;</span>: <span class="number">0</span>， <span class="string">&#x27;y_position&#x27;</span>: <span class="number">25</span>&#125;</span><br></pre></td></tr></table></figure><p>这个字典的最终版本包含四个键值对。注意，<strong>在Python3.6及更早的版本中，键值对的排列顺序与添加顺序不同，及在字典中键值对的排列顺序是无序的。Python不关心键值对的添加顺序，而只关心键和值之间的关联关系。而在Python3.7及以上版本中，字典中键值对的顺序是有序的。</strong></p><h1 id="3-修改字典中的值"><a href="#3-修改字典中的值" class="headerlink" title="3. 修改字典中的值"></a>3. 修改字典中的值</h1><p>要修改字典中的值，可依次指定字典名、用方括号括起的键以及与该键相关联的新值，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">alien_0 = &#123;<span class="string">&#x27;color&#x27;</span>: <span class="string">&#x27;green&#x27;</span>&#125; </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The alien is &quot;</span> + alien_0[<span class="string">&#x27;color&#x27;</span>] + <span class="string">&quot;.&quot;</span>) </span><br><span class="line"> </span><br><span class="line">alien_0[<span class="string">&#x27;color&#x27;</span>] = <span class="string">&#x27;yellow&#x27;</span> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The alien is now &quot;</span> + alien_0[<span class="string">&#x27;color&#x27;</span>] + <span class="string">&quot;.&quot;</span>)</span><br></pre></td></tr></table></figure><p>则输出结果如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">The alien <span class="keyword">is</span> green. </span><br><span class="line">The alien <span class="keyword">is</span> now yellow.</span><br></pre></td></tr></table></figure><h1 id="4-使用del语句删除键值对"><a href="#4-使用del语句删除键值对" class="headerlink" title="4. 使用del语句删除键值对"></a>4. 使用del语句删除键值对</h1><p>对于字典中不再需要的信息，可使用del语句将相应的键值对彻底删除。使用del语句时，必须指定字典名和要删除的键：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">alien_0 = &#123;<span class="string">&#x27;color&#x27;</span>: <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;points&#x27;</span>: <span class="number">5</span>&#125; </span><br><span class="line"><span class="built_in">print</span>(alien_0) </span><br><span class="line"> </span><br><span class="line"><span class="keyword">del</span> alien_0[<span class="string">&#x27;points&#x27;</span>] </span><br><span class="line"><span class="built_in">print</span>(alien_0)</span><br></pre></td></tr></table></figure><p>在上面这段代码中，将键’points’从字典alien_0中删除，同时删除与这个键相关联的值，其输出结果如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&#x27;color&#x27;</span>: <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;points&#x27;</span>: <span class="number">5</span>&#125; </span><br><span class="line">&#123;<span class="string">&#x27;color&#x27;</span>: <span class="string">&#x27;green&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><h1 id="5-遍历字典"><a href="#5-遍历字典" class="headerlink" title="5. 遍历字典"></a>5. 遍历字典</h1><p>Python支持对字典的遍历，并且有多种遍历字典的方式：可遍历字典的所有键值对、键或值。<strong>注意，在Python3.7及更高版本中，由于字典的排列顺序是有序的，因此遍历返回的值也是按顺序的。</strong></p><h2 id="5-1-遍历字典中所有的键值对（items-方法）"><a href="#5-1-遍历字典中所有的键值对（items-方法）" class="headerlink" title="5.1 遍历字典中所有的键值对（items()方法）"></a>5.1 遍历字典中所有的键值对（items()方法）</h2><p>下面的字典存储一名用户的用户名、名和姓：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">user_0 = &#123; </span><br><span class="line">    <span class="string">&#x27;username&#x27;</span>: <span class="string">&#x27;efermi&#x27;</span>, </span><br><span class="line">    <span class="string">&#x27;first&#x27;</span>: <span class="string">&#x27;enrico&#x27;</span>, </span><br><span class="line">    <span class="string">&#x27;last&#x27;</span>: <span class="string">&#x27;fermi&#x27;</span>, </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以使用for循环来遍历这个字典：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">user_0 = &#123; </span><br><span class="line">    <span class="string">&#x27;username&#x27;</span>: <span class="string">&#x27;efermi&#x27;</span>, </span><br><span class="line">    <span class="string">&#x27;first&#x27;</span>: <span class="string">&#x27;enrico&#x27;</span>, </span><br><span class="line">    <span class="string">&#x27;last&#x27;</span>: <span class="string">&#x27;fermi&#x27;</span>, </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> user_0.items():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\nKey: &quot;</span> + key)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Value: &quot;</span> + value)</span><br></pre></td></tr></table></figure><p>在上面这段代码中，要编写用于遍历字典的for循环，可声明两个变量，用于存储键值对中的一对键和值。for语句的第二部分包含字典名和方法items()，它返回一个键值对列表。接下来，for循环依次将每个键值对存储到指定的两个变量中，输出结果如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Key: username </span><br><span class="line">Value: efermi</span><br><span class="line"> </span><br><span class="line">Key: first </span><br><span class="line">Value: enrico </span><br><span class="line"> </span><br><span class="line">Key: last </span><br><span class="line">Value: fermi </span><br></pre></td></tr></table></figure><h2 id="5-2-遍历字典中所有的键（keys-方法）"><a href="#5-2-遍历字典中所有的键（keys-方法）" class="headerlink" title="5.2 遍历字典中所有的键（keys()方法）"></a>5.2 遍历字典中所有的键（keys()方法）</h2><p>在不需要使用字典中的值时，方法keys()很有用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">favorite_languages = &#123;</span><br><span class="line">    <span class="string">&#x27;jen&#x27;</span>: <span class="string">&#x27;python&#x27;</span>, </span><br><span class="line">    <span class="string">&#x27;sarah&#x27;</span>: <span class="string">&#x27;c&#x27;</span>, </span><br><span class="line">    <span class="string">&#x27;edward&#x27;</span>: <span class="string">&#x27;ruby&#x27;</span>, </span><br><span class="line">    <span class="string">&#x27;phil&#x27;</span>: <span class="string">&#x27;python&#x27;</span>, </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> favorite_languages.keys(): </span><br><span class="line">    <span class="built_in">print</span>(name.title())</span><br></pre></td></tr></table></figure><p>上面的代码提取字典中的所有键，并依次将它们存储到变量name中，输出结果如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Jen </span><br><span class="line">Sarah </span><br><span class="line">Edward</span><br><span class="line">Phil </span><br></pre></td></tr></table></figure><p>注意，遍历字典时，会默认遍历所有的键，因此，如果将上述代码中的for name in favorite_languages.keys(): 替换为for name in favorite_languages:，则输出结果不变。</p><h2 id="5-3-遍历字典中所有的值（values-方法，函数set-）"><a href="#5-3-遍历字典中所有的值（values-方法，函数set-）" class="headerlink" title="5.3 遍历字典中所有的值（values()方法，函数set()）"></a>5.3 遍历字典中所有的值（values()方法，函数set()）</h2><p>在不需要使用字典中的键时，方法values()很有用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">favorite_languages = &#123;</span><br><span class="line">    <span class="string">&#x27;jen&#x27;</span>: <span class="string">&#x27;python&#x27;</span>, </span><br><span class="line">    <span class="string">&#x27;sarah&#x27;</span>: <span class="string">&#x27;c&#x27;</span>, </span><br><span class="line">    <span class="string">&#x27;edward&#x27;</span>: <span class="string">&#x27;ruby&#x27;</span>, </span><br><span class="line">    <span class="string">&#x27;phil&#x27;</span>: <span class="string">&#x27;python&#x27;</span>, </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The following languages have been mentioned:&quot;</span>) </span><br><span class="line"><span class="keyword">for</span> language <span class="keyword">in</span> favorite_languages.values():</span><br><span class="line">    <span class="built_in">print</span>(language.title())</span><br></pre></td></tr></table></figure><p>这条for语句提取字典中的每个值，并将它们依次存储到变量language中。输出结果如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">The following languages have been mentioned:</span><br><span class="line">Python</span><br><span class="line">C</span><br><span class="line">Ruby</span><br><span class="line">Python</span><br></pre></td></tr></table></figure><p>这种做法提取字典中所有的值，而没有考虑重复。使用函数set()来生成一个列表，生成的列表中每个元素都是独一无二的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">favorite_languages = &#123;</span><br><span class="line">    <span class="string">&#x27;jen&#x27;</span>: <span class="string">&#x27;python&#x27;</span>, </span><br><span class="line">    <span class="string">&#x27;sarah&#x27;</span>: <span class="string">&#x27;c&#x27;</span>, </span><br><span class="line">    <span class="string">&#x27;edward&#x27;</span>: <span class="string">&#x27;ruby&#x27;</span>, </span><br><span class="line">    <span class="string">&#x27;phil&#x27;</span>: <span class="string">&#x27;python&#x27;</span>, </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The following languages have been mentioned:&quot;</span>) </span><br><span class="line"><span class="keyword">for</span> language <span class="keyword">in</span> <span class="built_in">set</span>(favorite_languages.values()):</span><br><span class="line">    <span class="built_in">print</span>(language.title())</span><br></pre></td></tr></table></figure><p>此时输出的结果是一个不重复的列表，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">The following languages have been mentioned:</span><br><span class="line">Ruby</span><br><span class="line">Python</span><br><span class="line">C</span><br></pre></td></tr></table></figure><h1 id="6-嵌套"><a href="#6-嵌套" class="headerlink" title="6. 嵌套"></a>6. 嵌套</h1><p>有时候，需要将一系列字典存储在列表中，或将列表作为值存储在字典中，这称为嵌套。你可以在列表中嵌套字典、在字典中嵌套列表甚至在字典中嵌套字典。</p><h2 id="6-1-在列表中嵌套字典"><a href="#6-1-在列表中嵌套字典" class="headerlink" title="6.1 在列表中嵌套字典"></a>6.1 在列表中嵌套字典</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">alien_0 = &#123;<span class="string">&#x27;color&#x27;</span>: <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;points&#x27;</span>: <span class="number">5</span>&#125; </span><br><span class="line">alien_1 = &#123;<span class="string">&#x27;color&#x27;</span>: <span class="string">&#x27;yellow&#x27;</span>, <span class="string">&#x27;points&#x27;</span>: <span class="number">10</span>&#125; </span><br><span class="line">alien_2 = &#123;<span class="string">&#x27;color&#x27;</span>: <span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;points&#x27;</span>: <span class="number">15</span>&#125; </span><br><span class="line"> </span><br><span class="line">aliens = [alien_0, alien_1, alien_2]</span><br><span class="line"><span class="keyword">for</span> alien <span class="keyword">in</span> aliens:</span><br><span class="line">    <span class="built_in">print</span>(alien)</span><br></pre></td></tr></table></figure><p>此时的输出结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&#x27;color&#x27;</span>: <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;points&#x27;</span>: <span class="number">5</span>&#125; </span><br><span class="line">&#123;<span class="string">&#x27;color&#x27;</span>: <span class="string">&#x27;yellow&#x27;</span>, <span class="string">&#x27;points&#x27;</span>: <span class="number">10</span>&#125; </span><br><span class="line">&#123;<span class="string">&#x27;color&#x27;</span>: <span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;points&#x27;</span>: <span class="number">15</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="6-2-在字典中嵌套列表"><a href="#6-2-在字典中嵌套列表" class="headerlink" title="6.2 在字典中嵌套列表"></a>6.2 在字典中嵌套列表</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pizza = &#123;</span><br><span class="line">    <span class="string">&#x27;crust&#x27;</span>: <span class="string">&#x27;thick&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;toppings&#x27;</span>: [<span class="string">&#x27;mushrooms&#x27;</span>, <span class="string">&#x27;extra cheese&#x27;</span>],</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;You ordered a &quot;</span> + pizza[<span class="string">&#x27;crust&#x27;</span>] + <span class="string">&quot;-crust pizza &quot;</span> + <span class="string">&quot;with the following toppings:&quot;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> topping <span class="keyword">in</span> pizza[<span class="string">&#x27;toppings&#x27;</span>]:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\t&quot;</span> + topping)</span><br></pre></td></tr></table></figure><p>此时的输出结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">You ordered a thick-crust pizza <span class="keyword">with</span> the following toppings:</span><br><span class="line">mushrooms</span><br><span class="line">extra cheese</span><br></pre></td></tr></table></figure><p>每当需要在字典中将一个键关联到多个值时，都可以在字典中嵌套一个列表，下面是一个经典的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">favorite_languages = &#123;</span><br><span class="line">    <span class="string">&#x27;jen&#x27;</span>: [<span class="string">&#x27;python&#x27;</span>, <span class="string">&#x27;ruby&#x27;</span>],</span><br><span class="line">    <span class="string">&#x27;sarah&#x27;</span>: [<span class="string">&#x27;c&#x27;</span>],</span><br><span class="line">    <span class="string">&#x27;edward&#x27;</span>: [<span class="string">&#x27;ruby&#x27;</span>, <span class="string">&#x27;go&#x27;</span>],</span><br><span class="line">    <span class="string">&#x27;phil&#x27;</span>: [<span class="string">&#x27;python&#x27;</span>, <span class="string">&#x27;haskell&#x27;</span>],</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> name, languages <span class="keyword">in</span> favorite_languages.items():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span> + name.title() + <span class="string">&quot;&#x27;s favorite languages are:&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> language <span class="keyword">in</span> languages:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;\t&quot;</span> + language.title())</span><br></pre></td></tr></table></figure><p>此时的输出结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Jen<span class="string">&#x27;s favorite languages are:</span></span><br><span class="line"><span class="string">Python</span></span><br><span class="line"><span class="string">Ruby</span></span><br><span class="line"><span class="string">Sarah&#x27;</span>s favorite languages are:</span><br><span class="line">C</span><br><span class="line"> </span><br><span class="line">Edward<span class="string">&#x27;s favorite languages are:</span></span><br><span class="line"><span class="string">Ruby</span></span><br><span class="line"><span class="string">Go</span></span><br><span class="line"><span class="string">Phil&#x27;</span>s favorite languages are:</span><br><span class="line">Python</span><br><span class="line">Haskell</span><br></pre></td></tr></table></figure><h2 id="6-3-在字典中嵌套字典"><a href="#6-3-在字典中嵌套字典" class="headerlink" title="6.3 在字典中嵌套字典"></a>6.3 在字典中嵌套字典</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">users = &#123;</span><br><span class="line">    <span class="string">&#x27;aeinstein&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;first&#x27;</span>: <span class="string">&#x27;albert&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;last&#x27;</span>: <span class="string">&#x27;einstein&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;location&#x27;</span>: <span class="string">&#x27;princeton&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line"> </span><br><span class="line">    <span class="string">&#x27;mcurie&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;first&#x27;</span>: <span class="string">&#x27;marie&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;last&#x27;</span>: <span class="string">&#x27;curie&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;location&#x27;</span>: <span class="string">&#x27;paris&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> username, user_info <span class="keyword">in</span> users.items():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\nUsername: &quot;</span> + username)</span><br><span class="line">    full_name = user_info[<span class="string">&#x27;first&#x27;</span>] + <span class="string">&quot; &quot;</span> + user_info[<span class="string">&#x27;last&#x27;</span>]</span><br><span class="line">    location = user_info[<span class="string">&#x27;location&#x27;</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\tFull name: &quot;</span> + full_name.title())</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\tLocation: &quot;</span> + location.title())</span><br></pre></td></tr></table></figure><p>其输出结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Username: aeinstein</span><br><span class="line">Full name: Albert Einstein</span><br><span class="line">Location: Princeton</span><br><span class="line"> </span><br><span class="line">Username: mcurie</span><br><span class="line">Full name: Marie Curie</span><br><span class="line">Location: Paris</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python学习笔记3—元组</title>
      <link href="/2024/12/26/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03%E2%80%94%E5%85%83%E7%BB%84/"/>
      <url>/2024/12/26/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03%E2%80%94%E5%85%83%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="1-元组的创建"><a href="#1-元组的创建" class="headerlink" title="1. 元组的创建"></a>1. 元组的创建</h1><p>在Python中元组的定义和用法与列表相似，<strong>列表用方括号[]表示</strong>，而<strong>元组用圆括号()表示</strong>，与列表不同的是<strong>元组中的元素不可修改</strong>，除此之外，<strong>Python的列表长度是可变的，而元组长度不可变</strong>，元组的定义如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dimensions = (<span class="number">200</span>, <span class="number">50</span>)</span><br><span class="line"><span class="built_in">print</span>(dimensions[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(dimensions[<span class="number">1</span>])</span><br></pre></td></tr></table></figure><p>在上面的代码中，先定义了元组dimensions，然后输出索引为0和1的两个元素，其输出结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">200</span></span><br><span class="line"><span class="number">50</span></span><br></pre></td></tr></table></figure><p>如果尝试修改该元组中某个元素的值，则会导致Python报错，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dimensions = (<span class="number">200</span>, <span class="number">50</span>) </span><br><span class="line">dimensions[<span class="number">0</span>] = <span class="number">250</span></span><br></pre></td></tr></table></figure><p>此时会返回如下错误：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;pyshell#1&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    dimensions[<span class="number">0</span>] = <span class="number">250</span></span><br><span class="line">TypeError: <span class="string">&#x27;tuple&#x27;</span> <span class="built_in">object</span> does <span class="keyword">not</span> support item assignment</span><br></pre></td></tr></table></figure><h1 id="2-遍历元组中的所有值"><a href="#2-遍历元组中的所有值" class="headerlink" title="2. 遍历元组中的所有值"></a>2. 遍历元组中的所有值</h1><p>和列表一样，也可以使用for循环来遍历元组中的所有值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dimensions = (<span class="number">200</span>, <span class="number">50</span>) </span><br><span class="line"><span class="keyword">for</span> dimension <span class="keyword">in</span> dimensions: </span><br><span class="line">    <span class="built_in">print</span>(dimension)</span><br></pre></td></tr></table></figure><p>此时会打印出元组中所有元素的值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">200</span></span><br><span class="line"><span class="number">50</span></span><br></pre></td></tr></table></figure><h1 id="3-修改元组变量"><a href="#3-修改元组变量" class="headerlink" title="3. 修改元组变量"></a>3. 修改元组变量</h1><p>虽然不能更改元组变量中元素的值，但是可以给该元组变量重新赋值，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dimensions = (<span class="number">200</span>, <span class="number">50</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Original dimensions:&quot;</span>) </span><br><span class="line"><span class="keyword">for</span> dimension <span class="keyword">in</span> dimensions:</span><br><span class="line">    <span class="built_in">print</span>(dimension) </span><br><span class="line"> </span><br><span class="line">dimensions = (<span class="number">400</span>, <span class="number">100</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nModified dimensions:&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> dimension <span class="keyword">in</span> dimensions: </span><br><span class="line">    <span class="built_in">print</span>(dimension)</span><br></pre></td></tr></table></figure><p>这段代码先定义了一个元组dimensions，并将其存储的尺寸打印了出来，接下来，将一个新元组存储到变量dimensions中，然后再次打印新的尺寸，此时Pyhton不会报错，因为给元组变量赋值是合法的，其输出结果如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Original dimensions: </span><br><span class="line"><span class="number">200</span> </span><br><span class="line"><span class="number">50</span> </span><br><span class="line"> </span><br><span class="line">Modified dimensions: </span><br><span class="line"><span class="number">400</span> </span><br><span class="line"><span class="number">100</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python学习笔记2—列表的进阶操作</title>
      <link href="/2024/12/26/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02%E2%80%94%E5%88%97%E8%A1%A8%E7%9A%84%E8%BF%9B%E9%98%B6%E6%93%8D%E4%BD%9C/"/>
      <url>/2024/12/26/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02%E2%80%94%E5%88%97%E8%A1%A8%E7%9A%84%E8%BF%9B%E9%98%B6%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="1-使用for循环进行列表遍历"><a href="#1-使用for循环进行列表遍历" class="headerlink" title="1. 使用for循环进行列表遍历"></a>1. 使用for循环进行列表遍历</h1><p>假设我们有一个魔术师名单，需要将其中每个魔术师的名字都打印出来，则可以用for 循环进行遍历并打印，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">magicians = [<span class="string">&#x27;alice&#x27;</span>, <span class="string">&#x27;david&#x27;</span>, <span class="string">&#x27;carolina&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> magician <span class="keyword">in</span> magicians:</span><br><span class="line">    <span class="built_in">print</span>(magician)</span><br></pre></td></tr></table></figure><p>这段代码从列表magicians中取出一个名字，并将其存储在变量magician中，进而将其打印，其输出结果如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alice </span><br><span class="line">david </span><br><span class="line">carolina</span><br></pre></td></tr></table></figure><h1 id="2-创建数值列表"><a href="#2-创建数值列表" class="headerlink" title="2. 创建数值列表"></a>2. 创建数值列表</h1><h2 id="2-1-使用函数range"><a href="#2-1-使用函数range" class="headerlink" title="2.1 使用函数range()"></a>2.1 使用函数range()</h2><p>使用函数range()可以生成一些数字，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">5</span>): </span><br><span class="line">    <span class="built_in">print</span>(value)</span><br></pre></td></tr></table></figure><p>则打印的结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> </span><br><span class="line"><span class="number">2</span> </span><br><span class="line"><span class="number">3</span> </span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><p>需要注意的是，range(1,5)只是打印数字1-4，并且range(1,5)并不会生成一个包含数字1-4的列表。</p><h2 id="2-2-使用函数range-和函数list-创建数值列表"><a href="#2-2-使用函数range-和函数list-创建数值列表" class="headerlink" title="2.2 使用函数range()和函数list()创建数值列表"></a>2.2 使用函数range()和函数list()创建数值列表</h2><p>上面提到了使用range()并不会生成列表，要相将其结果直接转换为列表，可以使用函数list()，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">numbers = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">6</span>)) </span><br><span class="line"><span class="built_in">print</span>(numbers)</span><br></pre></td></tr></table></figure><p>则此时的输出结果为一个包含数字1~5的数值列表：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure><p>使用函数range()时，还可指定步长。例如，下面的代码打印1~10内的偶数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">even_numbers = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">2</span>,<span class="number">11</span>,<span class="number">2</span>)) </span><br><span class="line"><span class="built_in">print</span>(even_numbers)</span><br></pre></td></tr></table></figure><p>在这段代码中，函数range()从2开始数，然后不断地加2，直到达到或超过终值11，因此输出如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>]</span><br></pre></td></tr></table></figure><h1 id="3-列表解析"><a href="#3-列表解析" class="headerlink" title="3. 列表解析"></a>3. 列表解析</h1><p>列表解析将for循环和创建新元素的代码合并成一行，并自动附加新元素，如可以使用以下方法快速生成一组平方数列表：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">squares = [value**<span class="number">2</span> <span class="keyword">for</span> value <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">11</span>)] </span><br><span class="line"><span class="built_in">print</span>(squares)</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>, <span class="number">100</span>]</span><br></pre></td></tr></table></figure><h1 id="4-列表的切片"><a href="#4-列表的切片" class="headerlink" title="4. 列表的切片"></a>4. 列表的切片</h1><h2 id="4-1-切片"><a href="#4-1-切片" class="headerlink" title="4.1 切片"></a>4.1 切片</h2><p>要创建切片，可指定要使用的第一个元素和最后一个元素的索引，与函数range()一样，切片的区间同样是左闭右开的，下面的示例处理的是一个运动队成员列表：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">players = [<span class="string">&#x27;charles&#x27;</span>, <span class="string">&#x27;martina&#x27;</span>, <span class="string">&#x27;michael&#x27;</span>, <span class="string">&#x27;florence&#x27;</span>, <span class="string">&#x27;eli&#x27;</span>] </span><br><span class="line"><span class="built_in">print</span>(players[<span class="number">0</span>:<span class="number">3</span>])</span><br></pre></td></tr></table></figure><p>此处将原列表的前三个元素切片，输出的仍然是一个列表：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&#x27;charles&#x27;</span>, <span class="string">&#x27;martina&#x27;</span>, <span class="string">&#x27;michael&#x27;</span>]</span><br></pre></td></tr></table></figure><p>如果没有指定第一个索引，则Python将自动从列表开头开始：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">players = [<span class="string">&#x27;charles&#x27;</span>, <span class="string">&#x27;martina&#x27;</span>, <span class="string">&#x27;michael&#x27;</span>, <span class="string">&#x27;florence&#x27;</span>, <span class="string">&#x27;eli&#x27;</span>] </span><br><span class="line"><span class="built_in">print</span>(players[:<span class="number">4</span>])</span><br></pre></td></tr></table></figure><p>此时输出的是索引为0~3的列表中的元素组成的新列表：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&#x27;charles&#x27;</span>, <span class="string">&#x27;martina&#x27;</span>, <span class="string">&#x27;michael&#x27;</span>, <span class="string">&#x27;florence&#x27;</span>]</span><br></pre></td></tr></table></figure><p>要让切片终止于末尾，也可以用类似的语法，不指定后面的索引：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">players = [<span class="string">&#x27;charles&#x27;</span>, <span class="string">&#x27;martina&#x27;</span>, <span class="string">&#x27;michael&#x27;</span>, <span class="string">&#x27;florence&#x27;</span>, <span class="string">&#x27;eli&#x27;</span>] </span><br><span class="line"><span class="built_in">print</span>(players[<span class="number">2</span>:])</span><br></pre></td></tr></table></figure><p>则此时输出的为原列表中索引为2及其后面的所有元素组成的新列表：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&#x27;michael&#x27;</span>, <span class="string">&#x27;florence&#x27;</span>, <span class="string">&#x27;eli&#x27;</span>]</span><br></pre></td></tr></table></figure><h2 id="4-2-遍历切片"><a href="#4-2-遍历切片" class="headerlink" title="4.2 遍历切片"></a>4.2 遍历切片</h2><p>由于列表的切片也是列表，因此其遍历方法和列表的遍历方法相同，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">players = [<span class="string">&#x27;charles&#x27;</span>, <span class="string">&#x27;martina&#x27;</span>, <span class="string">&#x27;michael&#x27;</span>, <span class="string">&#x27;florence&#x27;</span>, <span class="string">&#x27;eli&#x27;</span>] </span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Here are the first three players on my team:&quot;</span>) </span><br><span class="line"><span class="keyword">for</span> player <span class="keyword">in</span> players[:<span class="number">3</span>]:</span><br><span class="line">    <span class="built_in">print</span>(player.title())</span><br></pre></td></tr></table></figure><p>此处遍历的是列表中的前3个元素：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Here are the first three players on my team: </span><br><span class="line">Charles </span><br><span class="line">Martina </span><br><span class="line">Michael</span><br></pre></td></tr></table></figure><h2 id="4-3-复制列表"><a href="#4-3-复制列表" class="headerlink" title="4.3 复制列表"></a>4.3 复制列表</h2><p><strong>要复制列表，可创建一个包含整个列表的切片，方法是同时省略起始索引和终止索引（[:]）</strong>。这让Python创建一个始于第一个元素，终止于最后一个元素的切片，即复制整个列表，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">my_foods = [<span class="string">&#x27;pizza&#x27;</span>, <span class="string">&#x27;falafel&#x27;</span>, <span class="string">&#x27;carrot cake&#x27;</span>]</span><br><span class="line">friend_foods = my_foods[:]</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;My favorite foods are:&quot;</span>) </span><br><span class="line"><span class="built_in">print</span>(my_foods) </span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nMy friend&#x27;s favorite foods are:&quot;</span>) </span><br><span class="line"><span class="built_in">print</span>(friend_foods)</span><br></pre></td></tr></table></figure><p>这段代码中首先创建了一个名为my_foods的食品列表，然后创建了一个名为friend_foods的新列表，在不指定任何引的情况下从列表my_foods中提取一个切片，从而创建了这个列表的副本，再将该副本存储到变量friend_foods中。打印每个列表后，发现它们包含的食品相同：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">My favorite foods are: </span><br><span class="line">[<span class="string">&#x27;pizza&#x27;</span>, <span class="string">&#x27;falafel&#x27;</span>, <span class="string">&#x27;carrot cake&#x27;</span>] </span><br><span class="line"> </span><br><span class="line">My friend<span class="string">&#x27;s favorite foods are: </span></span><br><span class="line"><span class="string">[&#x27;</span>pizza<span class="string">&#x27;, &#x27;</span>falafel<span class="string">&#x27;, &#x27;</span>carrot cake<span class="string">&#x27;]</span></span><br></pre></td></tr></table></figure><p>为核实确实有两个列表，下面在每个列表中都添加一种食品，并核实每个列表都记录了相应人员喜欢的食品：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">my_foods = [<span class="string">&#x27;pizza&#x27;</span>, <span class="string">&#x27;falafel&#x27;</span>, <span class="string">&#x27;carrot cake&#x27;</span>] </span><br><span class="line">friend_foods = my_foods[:]</span><br><span class="line"> </span><br><span class="line">my_foods.append(<span class="string">&#x27;cannoli&#x27;</span>)</span><br><span class="line">friend_foods.append(<span class="string">&#x27;ice cream&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;My favorite foods are:&quot;</span>) </span><br><span class="line"><span class="built_in">print</span>(my_foods)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nMy friend&#x27;s favorite foods are:&quot;</span>) </span><br><span class="line"><span class="built_in">print</span>(friend_foods)</span><br></pre></td></tr></table></figure><p>此时的输出结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">My favorite foods are: </span><br><span class="line">[<span class="string">&#x27;pizza&#x27;</span>, <span class="string">&#x27;falafel&#x27;</span>, <span class="string">&#x27;carrot cake&#x27;</span>, <span class="string">&#x27;cannoli&#x27;</span>]</span><br><span class="line"> </span><br><span class="line">My friend<span class="string">&#x27;s favorite foods are: </span></span><br><span class="line"><span class="string">[&#x27;</span>pizza<span class="string">&#x27;, &#x27;</span>falafel<span class="string">&#x27;, &#x27;</span>carrot cake<span class="string">&#x27;, &#x27;</span>ice cream<span class="string">&#x27;]</span></span><br></pre></td></tr></table></figure><p>可以看到，原列表的输出与复制后列表的输出结果不同，说明原列表与复制的列表是互相独立的如果我们只是<strong>简单地将my_foods赋给friend_foods，就不能得到两个列表</strong>，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">my_foods = [<span class="string">&#x27;pizza&#x27;</span>, <span class="string">&#x27;falafel&#x27;</span>, <span class="string">&#x27;carrot cake&#x27;</span>] </span><br><span class="line"> </span><br><span class="line">friend_foods = my_foods</span><br><span class="line"> </span><br><span class="line">my_foods.append(<span class="string">&#x27;cannoli&#x27;</span>) </span><br><span class="line">friend_foods.append(<span class="string">&#x27;ice cream&#x27;</span>) </span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;My favorite foods are:&quot;</span>) </span><br><span class="line"><span class="built_in">print</span>(my_foods) </span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nMy friend&#x27;s favorite foods are:&quot;</span>) </span><br><span class="line"><span class="built_in">print</span>(friend_foods)</span><br></pre></td></tr></table></figure><p>此时的输出结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">My favorite foods are: </span><br><span class="line">[<span class="string">&#x27;pizza&#x27;</span>, <span class="string">&#x27;falafel&#x27;</span>, <span class="string">&#x27;carrot cake&#x27;</span>, <span class="string">&#x27;cannoli&#x27;</span>, <span class="string">&#x27;ice cream&#x27;</span>] </span><br><span class="line"> </span><br><span class="line">My friend<span class="string">&#x27;s favorite foods are: </span></span><br><span class="line"><span class="string">[&#x27;</span>pizza<span class="string">&#x27;, &#x27;</span>falafel<span class="string">&#x27;, &#x27;</span>carrot cake<span class="string">&#x27;, &#x27;</span>cannoli<span class="string">&#x27;, &#x27;</span>ice cream<span class="string">&#x27;]</span></span><br></pre></td></tr></table></figure><p>可以看到这两个列表是完全相同的，对其中一个列表进行操作也会导致另一个列表发生变化。</p><h1 id="5-使用if语句判断列表是否非空"><a href="#5-使用if语句判断列表是否非空" class="headerlink" title="5. 使用if语句判断列表是否非空"></a>5. 使用if语句判断列表是否非空</h1><p>首先看下面一段代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">requested_toppings = []</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> requested_toppings:</span><br><span class="line">    <span class="keyword">for</span> requested_topping <span class="keyword">in</span> requested_toppings: </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Adding &quot;</span> + requested_topping + <span class="string">&quot;.&quot;</span>) </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\nFinished making your pizza！&quot;</span>) </span><br><span class="line"><span class="keyword">else</span>: </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Are you sure you want a plain pizza？&quot;</span>)</span><br></pre></td></tr></table></figure><p>在这段代码中，首先创建了一个空列表，其中不包含任何元素，然后对其用if语句进行了检查，若列表非空，则会打印出列表中的所有元素，否则返回else处打印的语句：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Are you sure you want a plain pizza？</span><br></pre></td></tr></table></figure><h1 id="6-使用关键字in或not-in检查特定元素是否在列表中"><a href="#6-使用关键字in或not-in检查特定元素是否在列表中" class="headerlink" title="6. 使用关键字in或not in检查特定元素是否在列表中"></a>6. 使用关键字in或not in检查特定元素是否在列表中</h1><p>要判断特定的值是否已包含在列表中，可使用关键字in：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">requested_toppings = [<span class="string">&#x27;mushrooms&#x27;</span>, <span class="string">&#x27;onions&#x27;</span>, <span class="string">&#x27;pineapple&#x27;</span>]</span><br><span class="line"><span class="string">&#x27;mushrooms&#x27;</span> <span class="keyword">in</span> requested_toppings</span><br><span class="line"><span class="string">&#x27;pepperoni&#x27;</span> <span class="keyword">in</span> requested_toppings</span><br></pre></td></tr></table></figure><p>此时由于列表中确实含有元素’mushrooms’，因此会返回True，而’pepperoni’不在列表元素中，因此会返回False。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python学习笔记1—列表的简单操作</title>
      <link href="/2024/12/25/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01%E2%80%94%E5%88%97%E8%A1%A8%E7%9A%84%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/"/>
      <url>/2024/12/25/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01%E2%80%94%E5%88%97%E8%A1%A8%E7%9A%84%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="1-列表的定义"><a href="#1-列表的定义" class="headerlink" title="1. 列表的定义"></a>1. 列表的定义</h1><p>在Pyhton中，用[]来表示列表。并用逗号来分隔其中的元素，在下方是一个简单的列表示例，这个列表包含几种自行车：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bicycles = [<span class="string">&#x27;trek&#x27;</span>, <span class="string">&#x27;cannondale&#x27;</span>, <span class="string">&#x27;redline&#x27;</span>, <span class="string">&#x27;specialized&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(bicycles)</span><br></pre></td></tr></table></figure><p>下方为打印结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&#x27;trek&#x27;</span>, <span class="string">&#x27;cannondale&#x27;</span>, <span class="string">&#x27;redline&#x27;</span>, <span class="string">&#x27;specialized&#x27;</span>]</span><br></pre></td></tr></table></figure><h1 id="2-访问列表元素"><a href="#2-访问列表元素" class="headerlink" title="2. 访问列表元素"></a>2. 访问列表元素</h1><p>在Python中，可以通过索引来访问列表元素，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bicycles = [<span class="string">&#x27;trek&#x27;</span>, <span class="string">&#x27;cannondale&#x27;</span>, <span class="string">&#x27;redline&#x27;</span>, <span class="string">&#x27;specialized&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(bicycles[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trek</span><br></pre></td></tr></table></figure><p>在Python中，列表的索引从0开始，同时Python为访问最后一个列表元素提供了一种特殊语法。<strong>通过将索引指定为-1，可让Python返回最后一个列表元素</strong>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bicycles = [<span class="string">&#x27;trek&#x27;</span>, <span class="string">&#x27;cannondale&#x27;</span>, <span class="string">&#x27;redline&#x27;</span>, <span class="string">&#x27;specialized&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(bicycles[-<span class="number">1</span>])</span><br></pre></td></tr></table></figure><p>此时的输出结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">specialized</span><br></pre></td></tr></table></figure><h1 id="3-列表的改、增、删"><a href="#3-列表的改、增、删" class="headerlink" title="3. 列表的改、增、删"></a>3. 列表的改、增、删</h1><h2 id="3-1-列表元素的修改"><a href="#3-1-列表元素的修改" class="headerlink" title="3.1 列表元素的修改"></a>3.1 列表元素的修改</h2><p>要对列表中的值进行修改，可以用下面这种方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">motorcycles = [<span class="string">&#x27;honda&#x27;</span>, <span class="string">&#x27;yamaha&#x27;</span>, <span class="string">&#x27;suzuki&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(motorcycles) </span><br><span class="line"></span><br><span class="line">motorcycles[<span class="number">0</span>] = <span class="string">&#x27;ducati&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(motorcycles)</span><br></pre></td></tr></table></figure><p>则列表中的第一个元素’honda’被修改为’ducati’，输出如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&#x27;honda&#x27;</span>, <span class="string">&#x27;yamaha&#x27;</span>, <span class="string">&#x27;suzuki&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;ducati&#x27;</span>, <span class="string">&#x27;yamaha&#x27;</span>, <span class="string">&#x27;suzuki&#x27;</span>]</span><br></pre></td></tr></table></figure><h2 id="3-2-列表元素的添加"><a href="#3-2-列表元素的添加" class="headerlink" title="3.2 列表元素的添加"></a>3.2 列表元素的添加</h2><h3 id="3-2-1-使用方法append-在列表末尾添加元素"><a href="#3-2-1-使用方法append-在列表末尾添加元素" class="headerlink" title="3.2.1 使用方法append()在列表末尾添加元素"></a>3.2.1 使用方法append()在列表末尾添加元素</h3><p>使用方法append()在列表末尾添加元素，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">motorcycles = [<span class="string">&#x27;honda&#x27;</span>, <span class="string">&#x27;yamaha&#x27;</span>, <span class="string">&#x27;suzuki&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(motorcycles)</span><br><span class="line"></span><br><span class="line">motorcycles.append(<span class="string">&#x27;ducati&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(motorcycles)</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&#x27;honda&#x27;</span>, <span class="string">&#x27;yamaha&#x27;</span>, <span class="string">&#x27;suzuki&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;honda&#x27;</span>, <span class="string">&#x27;yamaha&#x27;</span>, <span class="string">&#x27;suzuki&#x27;</span>, <span class="string">&#x27;ducati&#x27;</span>]</span><br></pre></td></tr></table></figure><h3 id="3-2-2-使用方法insert-在列表中插入元素"><a href="#3-2-2-使用方法insert-在列表中插入元素" class="headerlink" title="3.2.2 使用方法insert()在列表中插入元素"></a>3.2.2 使用方法insert()在列表中插入元素</h3><p>使用方法insert()可以列表的任何位置添加元素，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">motorcycles = [<span class="string">&#x27;honda&#x27;</span>, <span class="string">&#x27;yamaha&#x27;</span>, <span class="string">&#x27;suzuki&#x27;</span>]</span><br><span class="line"></span><br><span class="line">motorcycles.insert(<span class="number">0</span>, <span class="string">&#x27;ducati&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(motorcycles)</span><br></pre></td></tr></table></figure><p>此处将’ducati’存储在索引0处，其余元素均向右移动一个位置，输出结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&#x27;ducati&#x27;</span>, <span class="string">&#x27;honda&#x27;</span>, <span class="string">&#x27;yamaha&#x27;</span>, <span class="string">&#x27;suzuki&#x27;</span>]</span><br></pre></td></tr></table></figure><h2 id="3-3-在列表中删除元素"><a href="#3-3-在列表中删除元素" class="headerlink" title="3.3 在列表中删除元素"></a>3.3 在列表中删除元素</h2><h3 id="3-3-1-使用def语句删除元素（根据索引删除）"><a href="#3-3-1-使用def语句删除元素（根据索引删除）" class="headerlink" title="3.3.1 使用def语句删除元素（根据索引删除）"></a>3.3.1 使用def语句删除元素（根据索引删除）</h3><p>如果知道要删除的元素在列表中的位置，可使用del语句，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">motorcycles = [<span class="string">&#x27;honda&#x27;</span>, <span class="string">&#x27;yamaha&#x27;</span>, <span class="string">&#x27;suzuki&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(motorcycles) </span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> motorcycles[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(motorcycles)</span><br></pre></td></tr></table></figure><p>此处用del删除了列表中索引为0的元素’honda’，输出结果为:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&#x27;honda&#x27;</span>, <span class="string">&#x27;yamaha&#x27;</span>, <span class="string">&#x27;suzuki&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;yamaha&#x27;</span>, <span class="string">&#x27;suzuki&#x27;</span>]</span><br></pre></td></tr></table></figure><h3 id="3-2-2-使用pop-方法删除元素（根据索引删除，可将删除值再利用）"><a href="#3-2-2-使用pop-方法删除元素（根据索引删除，可将删除值再利用）" class="headerlink" title="3.2.2 使用pop()方法删除元素（根据索引删除，可将删除值再利用）"></a>3.2.2 使用pop()方法删除元素（根据索引删除，可将删除值再利用）</h3><p>有时候，需要将元素从列表中删除，并接着使用它的值，就可以使用方法pop()，它可以删除列表末尾的元素，并让你能够接着使用它，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">motorcycles = [<span class="string">&#x27;honda&#x27;</span>, <span class="string">&#x27;yamaha&#x27;</span>, <span class="string">&#x27;suzuki&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(motorcycles)</span><br><span class="line"></span><br><span class="line">popped_motorcycle = motorcycles.pop()</span><br><span class="line"><span class="built_in">print</span>(motorcycles)</span><br><span class="line"><span class="built_in">print</span>(popped_motorcycle)</span><br></pre></td></tr></table></figure><p>此处将列表末尾元素’suzuki’删除，并将其存储在变量poped_motorcycle中，输出结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&#x27;honda&#x27;</span>, <span class="string">&#x27;yamaha&#x27;</span>, <span class="string">&#x27;suzuki&#x27;</span>] </span><br><span class="line">[<span class="string">&#x27;honda&#x27;</span>, <span class="string">&#x27;yamaha&#x27;</span>] </span><br><span class="line">suzuki</span><br></pre></td></tr></table></figure><p>也可以用pop()方法弹出列表中任意位置处的元素，只需要在方法的括号中指定要删除的元素的索引即可，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">motorcycles = [<span class="string">&#x27;honda&#x27;</span>, <span class="string">&#x27;yamaha&#x27;</span>, <span class="string">&#x27;suzuki&#x27;</span>]</span><br><span class="line">first_owned = motorcycles.pop(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;The first motorcycle I owned was a &#x27;</span> + first_owned.title() + <span class="string">&#x27;.&#x27;</span>)</span><br></pre></td></tr></table></figure><p>此处将列表中索引为0的元素’honda’弹出，并赋给变量first_owned，输出结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The first motorcycle I owned was a Honda.</span><br></pre></td></tr></table></figure><h3 id="3-3-3-使用remove-方法删除元素（根据值删除元素）"><a href="#3-3-3-使用remove-方法删除元素（根据值删除元素）" class="headerlink" title="3.3.3 使用remove()方法删除元素（根据值删除元素）"></a>3.3.3 使用remove()方法删除元素（根据值删除元素）</h3><p>有时候，你不知道要从列表中删除的值的索引，如果你只知道要删除的元素的值，则可以使用方法remove()，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">motorcycles = [<span class="string">&#x27;honda&#x27;</span>, <span class="string">&#x27;yamaha&#x27;</span>, <span class="string">&#x27;suzuki&#x27;</span>, <span class="string">&#x27;ducati&#x27;</span>] </span><br><span class="line"><span class="built_in">print</span>(motorcycles) </span><br><span class="line"></span><br><span class="line">motorcycles.remove(<span class="string">&#x27;ducati&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(motorcycles)</span><br></pre></td></tr></table></figure><p>此处将列表元素’ducati’从列表中删除，使用remove()方法删除元素时，也可接着使用它的值，下边删除值’ducati’，并打印一条消息，指出要将其从列表中删除的原因:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">motorcycles = [<span class="string">&#x27;honda&#x27;</span>, <span class="string">&#x27;yamaha&#x27;</span>, <span class="string">&#x27;suzuki&#x27;</span>, <span class="string">&#x27;ducati&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(motorcycles) </span><br><span class="line">too_expensive = <span class="string">&#x27;ducati&#x27;</span></span><br><span class="line"></span><br><span class="line">motorcycles.remove(too_expensive)</span><br><span class="line"><span class="built_in">print</span>(motorcycles) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nA &quot;</span> + too_expensive.title() + <span class="string">&quot; is too expensive for me.&quot;</span>)</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&#x27;honda&#x27;</span>, <span class="string">&#x27;yamaha&#x27;</span>, <span class="string">&#x27;suzuki&#x27;</span>, <span class="string">&#x27;ducati&#x27;</span>] </span><br><span class="line">[<span class="string">&#x27;honda&#x27;</span>, <span class="string">&#x27;yamaha&#x27;</span>, <span class="string">&#x27;suzuki&#x27;</span>] </span><br><span class="line"></span><br><span class="line">A Ducati <span class="keyword">is</span> too expensive <span class="keyword">for</span> me.</span><br></pre></td></tr></table></figure><h1 id="4-列表的排序和求长度"><a href="#4-列表的排序和求长度" class="headerlink" title="4. 列表的排序和求长度"></a>4. 列表的排序和求长度</h1><h2 id="4-1-使用方法sort-对列表进行永久性排序"><a href="#4-1-使用方法sort-对列表进行永久性排序" class="headerlink" title="4.1 使用方法sort()对列表进行永久性排序"></a>4.1 使用方法sort()对列表进行永久性排序</h2><p>假设你有一个汽车列表，并要让其中的汽车按字母顺序排序，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cars = [<span class="string">&#x27;bmw&#x27;</span>, <span class="string">&#x27;audi&#x27;</span>, <span class="string">&#x27;toyota&#x27;</span>, <span class="string">&#x27;subaru&#x27;</span>] </span><br><span class="line">cars.sort()</span><br><span class="line"><span class="built_in">print</span>(cars)</span><br></pre></td></tr></table></figure><p>现在，汽车是按字母顺序排列的，并且再也无法恢复到原来的排列顺序，输出结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&#x27;audi&#x27;</span>, <span class="string">&#x27;bmw&#x27;</span>, <span class="string">&#x27;subaru&#x27;</span>, <span class="string">&#x27;toyota&#x27;</span>]</span><br></pre></td></tr></table></figure><p>你还可以按与字母顺序想法的顺序排列列表元素，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cars = [<span class="string">&#x27;bmw&#x27;</span>, <span class="string">&#x27;audi&#x27;</span>, <span class="string">&#x27;toyota&#x27;</span>, <span class="string">&#x27;subaru&#x27;</span>] </span><br><span class="line">cars.sort(reverse=<span class="literal">True</span>) </span><br><span class="line"><span class="built_in">print</span>(cars)</span><br></pre></td></tr></table></figure><p>则输出结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&#x27;toyota&#x27;</span>, <span class="string">&#x27;subaru&#x27;</span>, <span class="string">&#x27;bmw&#x27;</span>, <span class="string">&#x27;audi&#x27;</span>]</span><br></pre></td></tr></table></figure><h2 id="4-2-使用函数sorted-对列表进行临时排序"><a href="#4-2-使用函数sorted-对列表进行临时排序" class="headerlink" title="4.2 使用函数sorted()对列表进行临时排序"></a>4.2 使用函数sorted()对列表进行临时排序</h2><p>要保留列表元素原来的排列顺序，同时以特定的顺序呈现它们，可使 用函数sorted()。函数sorted()让你能够按特定顺序显示列表元 素，同时不影响它们在列表中的原始排列顺序。如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cars = [<span class="string">&#x27;bmw&#x27;</span>, <span class="string">&#x27;audi&#x27;</span>, <span class="string">&#x27;toyota&#x27;</span>, <span class="string">&#x27;subaru&#x27;</span>] </span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Here is the original list:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(cars) </span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nHere is the sorted list:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sorted</span>(cars)) </span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nHere is the original list again:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(cars)</span><br></pre></td></tr></table></figure><p>则输出结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Here <span class="keyword">is</span> the original <span class="built_in">list</span>:</span><br><span class="line">[<span class="string">&#x27;bmw&#x27;</span>, <span class="string">&#x27;audi&#x27;</span>, <span class="string">&#x27;toyota&#x27;</span>, <span class="string">&#x27;subaru&#x27;</span>]</span><br><span class="line"></span><br><span class="line">Here <span class="keyword">is</span> the <span class="built_in">sorted</span> <span class="built_in">list</span>: </span><br><span class="line">[<span class="string">&#x27;audi&#x27;</span>, <span class="string">&#x27;bmw&#x27;</span>, <span class="string">&#x27;subaru&#x27;</span>, <span class="string">&#x27;toyota&#x27;</span>]</span><br><span class="line"></span><br><span class="line">Here <span class="keyword">is</span> the original <span class="built_in">list</span> again:</span><br><span class="line">[<span class="string">&#x27;bmw&#x27;</span>, <span class="string">&#x27;audi&#x27;</span>, <span class="string">&#x27;toyota&#x27;</span>, <span class="string">&#x27;subaru&#x27;</span>]</span><br></pre></td></tr></table></figure><p>注意，调用函数sorted()后，列表元素的排列顺序并没有变。如果你要按与字母顺序相反的顺序显示列表，也可向函数 sorted()传递参数reverse&#x3D;True。</p><h2 id="4-3-使用方法reverse-对列表顺序永久倒转"><a href="#4-3-使用方法reverse-对列表顺序永久倒转" class="headerlink" title="4.3 使用方法reverse()对列表顺序永久倒转"></a>4.3 使用方法reverse()对列表顺序永久倒转</h2><p>要反转列表元素的排列顺序，可使用方法reverse()，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cars = [<span class="string">&#x27;bmw&#x27;</span>, <span class="string">&#x27;audi&#x27;</span>, <span class="string">&#x27;toyota&#x27;</span>, <span class="string">&#x27;subaru&#x27;</span>] </span><br><span class="line"><span class="built_in">print</span>(cars) </span><br><span class="line"></span><br><span class="line">cars.reverse() </span><br><span class="line"><span class="built_in">print</span>(cars)</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[&#x27;bmw&#x27;, &#x27;audi&#x27;, &#x27;toyota&#x27;, &#x27;subaru&#x27;] </span><br><span class="line">[&#x27;subaru&#x27;, &#x27;toyota&#x27;, &#x27;audi&#x27;, &#x27;bmw&#x27;]</span><br></pre></td></tr></table></figure><h2 id="4-4-使用函数len-快速获取列表长度"><a href="#4-4-使用函数len-快速获取列表长度" class="headerlink" title="4.4 使用函数len()快速获取列表长度"></a>4.4 使用函数len()快速获取列表长度</h2><p>使用函数len()可快速获悉列表的长度。在下面的示例中，列表包含4 个元素，因此其长度为4：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cars = [<span class="string">&#x27;bmw&#x27;</span>, <span class="string">&#x27;audi&#x27;</span>, <span class="string">&#x27;toyota&#x27;</span>, <span class="string">&#x27;subaru&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(cars))</span><br></pre></td></tr></table></figure><p>此处输出结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/12/15/hello-world/"/>
      <url>/2024/12/15/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
